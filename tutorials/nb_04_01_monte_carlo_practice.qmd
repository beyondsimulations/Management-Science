---
title: "Notebook 4.1 - Monte Carlo Simulation Practice"
subtitle: "Management Science - Building Your Crystal Ball"
code-links:
  - text: Python
    href: nb_04_01_monte_carlo_practice.py
    icon: hand-thumbs-up
---

## Introduction: From Uncertainty to Insight

Welcome back, consultant! In the lecture, we saw how Monte Carlo simulation helps us make decisions when the future is uncertain. Now it's time to build your own simulations.

**Your Client Today:** CoffeeHub - a chain considering opening a new location

**The Question:** Should they open the new coffee shop? What's the risk?

```{python}
#| eval: true
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)
print("Libraries loaded! Let's simulate the future of CoffeeHub ☕")
```

## Section 1: Modeling Single Variables (15 min)

### Understanding Uncertainty

Every business variable has uncertainty. Let's model daily customer traffic:

```{python}
#| eval: true
# Historical data shows:
# - Average: 100 customers per day
# - Standard deviation: 20 customers
# - Roughly follows normal distribution

# Simulate one possible day
one_day = np.random.normal(loc=100, scale=20)
print(f"Tomorrow we might have {one_day:.0f} customers")

# But one day doesn't tell us much. Let's simulate a whole year!
year_of_days = np.random.normal(loc=100, scale=20, size=365)
print(f"\nYear simulation:")
print(f"  Average: {year_of_days.mean():.1f} customers/day")
print(f"  Best day: {year_of_days.max():.0f} customers")
print(f"  Worst day: {year_of_days.min():.0f} customers")
```

:::{.callout-note}
## Key Concept
`np.random.normal(loc, scale, size)` generates random numbers from a normal (bell curve) distribution:
- `loc`: The center (mean/average)
- `scale`: The spread (standard deviation)
- `size`: How many numbers to generate
:::

### Exercise 1.1: Model Average Purchase Amount

The average purchase per customer also varies. Historical data shows:
- Mean: €10
- But it ranges uniformly between €8 and €12

```{python}
#| eval: false
# YOUR CODE BELOW
# Simulate 365 days of average purchase amounts using uniform distribution
avg_purchases = 

# Calculate statistics
print(f"Purchase amount statistics:")
print(f"  Mean: €{}")
print(f"  Min: €{}")
print(f"  Max: €{}")
```

:::{.content-visible when-profile="solutions"}
```{python}
#| eval: true
# SOLUTION
avg_purchases = np.random.uniform(8, 12, size=365)

print(f"Purchase amount statistics:")
print(f"  Mean: €{avg_purchases.mean():.2f}")
print(f"  Min: €{avg_purchases.min():.2f}")
print(f"  Max: €{avg_purchases.max():.2f}")
```
:::

### Exercise 1.2: Visualize the Uncertainty

Create a histogram to visualize the distribution of daily customers:

```{python}
#| eval: false
# YOUR CODE BELOW
# Create a histogram of year_of_days with 30 bins
plt.figure(figsize=(10, 5))

plt.xlabel('Number of Customers')
plt.ylabel('Frequency (Days)')
plt.title('Distribution of Daily Customers Over One Year')
plt.grid(True, alpha=0.3)
plt.show()
```

:::{.content-visible when-profile="solutions"}
```{python}
#| eval: true
# SOLUTION
plt.figure(figsize=(10, 5))
plt.hist(year_of_days, bins=30, edgecolor='black', alpha=0.7)
plt.axvline(year_of_days.mean(), color='red', linestyle='--', 
            label=f'Mean: {year_of_days.mean():.1f}')
plt.xlabel('Number of Customers')
plt.ylabel('Frequency (Days)')
plt.title('Distribution of Daily Customers Over One Year')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
```
:::

## Section 2: Building a Business Simulation (15 min)

### Combining Multiple Uncertainties

Real businesses have many uncertain variables. Let's build a complete coffee shop simulator:

```{python}
#| eval: true
def simulate_coffee_shop_day():
    """Simulate one day of coffee shop operations"""
    # Uncertain variables
    customers = np.random.normal(100, 20)  # Number of customers
    avg_purchase = np.random.uniform(8, 12)  # Average purchase amount
    
    # Calculate revenue
    revenue = customers * avg_purchase
    
    # Fixed and variable costs
    fixed_costs = 500  # Rent, salaries, etc.
    variable_cost_rate = 0.35  # 35% of revenue
    variable_costs = variable_cost_rate * revenue
    
    # Calculate profit
    profit = revenue - fixed_costs - variable_costs
    
    return {
        'customers': customers,
        'avg_purchase': avg_purchase,
        'revenue': revenue,
        'profit': profit
    }

# Test one day
one_day_result = simulate_coffee_shop_day()
print("One day simulation:")
for key, value in one_day_result.items():
    if key == 'customers':
        print(f"  {key}: {value:.0f}")
    else:
        print(f"  {key}: €{value:.2f}")
```

### Exercise 2.1: Simulate Many Days

Now simulate 1,000 days to understand the range of outcomes:

```{python}
#| eval: false
# YOUR CODE BELOW
# Run simulation for 1000 days and collect results
n_simulations = 1000
results = []

for i in range(n_simulations):
    # Simulate one day and append to results
    
    
# Convert to DataFrame for analysis
df_results = pd.DataFrame(results)

# Calculate key metrics
print(f"1,000 Day Simulation Results:")
print(f"  Average daily profit: €{}")
print(f"  Probability of loss: {}%")
print(f"  Best day profit: €{}")
print(f"  Worst day profit: €{}")
```

:::{.content-visible when-profile="solutions"}
```{python}
#| eval: true
# SOLUTION
n_simulations = 1000
results = []

for i in range(n_simulations):
    day_result = simulate_coffee_shop_day()
    results.append(day_result)

df_results = pd.DataFrame(results)

print(f"1,000 Day Simulation Results:")
print(f"  Average daily profit: €{df_results['profit'].mean():.2f}")
print(f"  Probability of loss: {(df_results['profit'] < 0).mean()*100:.1f}%")
print(f"  Best day profit: €{df_results['profit'].max():.2f}")
print(f"  Worst day profit: €{df_results['profit'].min():.2f}")
```
:::

### Exercise 2.2: Risk Analysis

Calculate the Value at Risk (VaR) - what's the profit threshold for the worst 5% of days?

```{python}
#| eval: false
# YOUR CODE BELOW
# Calculate the 5th percentile of profit
var_5 = 

print(f"Value at Risk (5%): €{}")
print(f"Interpretation: There's a 5% chance of daily profit being below €{}")

# How many days out of 1000 had losses?
loss_days = 
print(f"\nDays with losses: {} out of {n_simulations}")
```

:::{.content-visible when-profile="solutions"}
```{python}
#| eval: true
# SOLUTION
var_5 = np.percentile(df_results['profit'], 5)

print(f"Value at Risk (5%): €{var_5:.2f}")
print(f"Interpretation: There's a 5% chance of daily profit being below €{var_5:.2f}")

loss_days = (df_results['profit'] < 0).sum()
print(f"\nDays with losses: {loss_days} out of {n_simulations}")
```
:::

### Visualizing Results

```{python}
#| eval: true
# Create a comprehensive visualization
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Profit distribution
axes[0].hist(df_results['profit'], bins=50, edgecolor='black', alpha=0.7)
axes[0].axvline(df_results['profit'].mean(), color='green', linestyle='--', 
                label=f"Mean: €{df_results['profit'].mean():.0f}")
axes[0].axvline(0, color='red', linestyle='-', linewidth=2, label='Break-even')
axes[0].axvline(var_5, color='orange', linestyle='--', label=f'VaR 5%: €{var_5:.0f}')
axes[0].set_xlabel('Daily Profit (€)')
axes[0].set_ylabel('Frequency')
axes[0].set_title('Distribution of Daily Profits (1,000 simulations)')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Revenue vs Customers scatter
axes[1].scatter(df_results['customers'], df_results['revenue'], alpha=0.5)
axes[1].set_xlabel('Number of Customers')
axes[1].set_ylabel('Revenue (€)')
axes[1].set_title('Revenue vs Customer Count')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Section 3: Advanced Analysis - Monthly Performance (15 min)

### From Daily to Monthly

Management wants to know monthly performance, not daily. Let's aggregate:

```{python}
#| eval: true
def simulate_month(days=30):
    """Simulate one month of operations"""
    daily_profits = []
    
    for day in range(days):
        result = simulate_coffee_shop_day()
        daily_profits.append(result['profit'])
    
    return {
        'total_profit': sum(daily_profits),
        'avg_daily_profit': np.mean(daily_profits),
        'worst_day': min(daily_profits),
        'best_day': max(daily_profits),
        'profitable_days': sum(p > 0 for p in daily_profits)
    }

# Test one month
month_result = simulate_month()
print("One month simulation:")
for key, value in month_result.items():
    if key == 'profitable_days':
        print(f"  {key}: {value} out of 30")
    else:
        print(f"  {key}: €{value:.2f}")
```

### Exercise 3.1: Annual Projection

Simulate 12 months to project annual performance:

```{python}
#| eval: false
# YOUR CODE BELOW
# Simulate 12 months
monthly_results = []

for month in range(12):
    # Simulate each month
    
    
# Calculate annual metrics
annual_profit = 
profitable_months = 

print(f"Annual Projection:")
print(f"  Total profit: €{}")
print(f"  Profitable months: {} out of 12")
print(f"  Average monthly profit: €{}")
```

:::{.content-visible when-profile="solutions"}
```{python}
#| eval: true
# SOLUTION
monthly_results = []

for month in range(12):
    month_result = simulate_month()
    monthly_results.append(month_result['total_profit'])

annual_profit = sum(monthly_results)
profitable_months = sum(p > 0 for p in monthly_results)

print(f"Annual Projection:")
print(f"  Total profit: €{annual_profit:.2f}")
print(f"  Profitable months: {profitable_months} out of 12")
print(f"  Average monthly profit: €{np.mean(monthly_results):.2f}")
```
:::

### Exercise 3.2: Scenario Analysis

What if we could increase average purchase by €1 through upselling?

```{python}
#| eval: false
# YOUR CODE BELOW
def simulate_improved_shop_day():
    """Simulate with €1 higher average purchase"""
    customers = np.random.normal(100, 20)
    # Increase the average purchase range by €1
    avg_purchase = 
    
    revenue = customers * avg_purchase
    fixed_costs = 500
    variable_costs = 0.35 * revenue
    profit = revenue - fixed_costs - variable_costs
    
    return profit

# Run 1000 simulations with improvement
improved_profits = []
for i in range(1000):
    
    
# Compare to original
print(f"Original average profit: €{df_results['profit'].mean():.2f}")
print(f"Improved average profit: €{}")
print(f"Profit increase: €{}")
```

:::{.content-visible when-profile="solutions"}
```{python}
#| eval: true
# SOLUTION
def simulate_improved_shop_day():
    """Simulate with €1 higher average purchase"""
    customers = np.random.normal(100, 20)
    avg_purchase = np.random.uniform(9, 13)  # Increased by €1
    
    revenue = customers * avg_purchase
    fixed_costs = 500
    variable_costs = 0.35 * revenue
    profit = revenue - fixed_costs - variable_costs
    
    return profit

improved_profits = []
for i in range(1000):
    improved_profits.append(simulate_improved_shop_day())

improved_profits = np.array(improved_profits)

print(f"Original average profit: €{df_results['profit'].mean():.2f}")
print(f"Improved average profit: €{improved_profits.mean():.2f}")
print(f"Profit increase: €{improved_profits.mean() - df_results['profit'].mean():.2f}")
```
:::

### Challenge Exercise: Break-even Analysis

At what customer level does the shop break even on average?

```{python}
#| eval: false
# YOUR CODE BELOW
# Test different customer levels
customer_levels = range(50, 150, 10)
avg_profits = []

for level in customer_levels:
    # Simulate with this customer level
    day_profits = []
    for _ in range(100):
        customers = np.random.normal(level, 20)
        avg_purchase = np.random.uniform(8, 12)
        revenue = customers * avg_purchase
        profit = revenue - 500 - 0.35 * revenue
        day_profits.append(profit)
    
    avg_profits.append(np.mean(day_profits))

# Find break-even point
# YOUR CODE TO FIND AND PRINT THE BREAK-EVEN CUSTOMER LEVEL

# Visualize
plt.figure(figsize=(10, 5))
# YOUR PLOTTING CODE
```

:::{.content-visible when-profile="solutions"}
```{python}
#| eval: true
# SOLUTION
customer_levels = range(50, 150, 10)
avg_profits = []

for level in customer_levels:
    day_profits = []
    for _ in range(100):
        customers = np.random.normal(level, 20)
        avg_purchase = np.random.uniform(8, 12)
        revenue = customers * avg_purchase
        profit = revenue - 500 - 0.35 * revenue
        day_profits.append(profit)
    
    avg_profits.append(np.mean(day_profits))

# Find break-even point
for i, profit in enumerate(avg_profits):
    if profit > 0:
        print(f"Break-even at approximately {customer_levels[i]} customers per day")
        break

# Visualize
plt.figure(figsize=(10, 5))
plt.plot(customer_levels, avg_profits, marker='o')
plt.axhline(y=0, color='red', linestyle='--', label='Break-even')
plt.xlabel('Average Customers per Day')
plt.ylabel('Average Profit (€)')
plt.title('Profit vs Customer Volume')
plt.grid(True, alpha=0.3)
plt.legend()
plt.show()
```
:::

## Summary & Reflection

Congratulations! You've built a complete Monte Carlo simulation for business decision-making.

**Key Skills You've Developed:**
1. ✅ Modeling uncertainty with probability distributions
2. ✅ Combining multiple uncertain variables
3. ✅ Running thousands of simulations
4. ✅ Calculating risk metrics (VaR, probability of loss)
5. ✅ Scenario analysis and sensitivity testing

:::{.callout-important}
## Remember
Monte Carlo simulation doesn't predict the future - it shows you all possible futures and their probabilities. This helps you make informed decisions under uncertainty.
:::

**Reflection Questions:**
1. Would you recommend opening the coffee shop based on your analysis?
2. What additional uncertainties might we want to model?
3. How would seasonal variation affect our simulation?

:::{.callout-tip}
## Next Up: Competition
Use these techniques to tackle the TechVenture investment challenge. Remember:
- Each startup has different risk-return characteristics
- Portfolio combinations can reduce or amplify risk
- Look beyond average returns to the full distribution
:::