---
title: "Multi-Objective Optimization"
subtitle: "Lecture 8 - Management Science"
author: "Dr. Tobias Vlćek"
format:
  revealjs:
    footer: " {{< meta title >}} | {{< meta author >}} | [Home](lec_08_multi_objective.qmd)"
    output-file: lec_08_presentation.html
---

# [Introduction]{.flow} {.title}

## **[Client Briefing: EcoExpress Logistics]{.invert-font}** {background-image="https://unsplash.com/photos/QqSIuvz94s8/download?ixid=M3wxMjA3fDB8MXxzZWFyY2h8MTF8fHN1c3RhaW5hYmlsaXR5fGVufDB8fHx8MTc2MzE4Nzk0MHww&force=true&w=2400" background-size="cover"}

. . .

[Operations Director's Dilemma:]{.invert-font}

["EU regulations demand 40% emission cuts, but we can't sacrifice [profitability]{.highlight}, [service quality]{.highlight}, or [reliability]{.highlight}!"]{.invert-font .fragment}

## The Fleet Challenge

[EcoExpress operates regional last-mile delivery across 3 cities]{.highlight}

::: incremental
- EU Green Deal: 40% emission reduction by 2025
- Rising fuel costs (€2.1/L diesel)
- Amazon entering our market (speed pressure)
- Driver shortage (need automation-friendly vehicles)
:::

. . .

[Question:]{.question} How do we transform our fleet while staying competitive?

## Today's Learning Objectives {.smaller}

[By the end of this lecture, you will be able to:]{.highlight}

::: {.incremental}
1. Explain why most real business decisions involve multiple competing objectives
2. Identify and visualize Pareto optimal solutions in multi-objective problems
3. Apply normalization techniques to make objectives comparable
4. Implement weighted sum and ε-constraint methods to find trade-off solutions
5. Choose the appropriate MOO method for different problem types
6. Make data-driven decisions from a Pareto frontier
7. Analyze real-world multi-objective trade-offs (Amazon, airlines, Tesla)
:::

## Quick Recap: Local Search

[Last week we optimized routes for delivery:]{.highlight}

::: {.incremental}
- Started with greedy construction (e.g. Nearest Neighbor)
- Improved with local search (e.g. 2-opt)
- Considered time windows
- **But: We only optimized distance**
:::

. . .

[Question:]{.question} What if we also care about emissions, cost, AND customer satisfaction?

# [The Problem]{.flow} {.title}

## Single vs Multi-Objective

**Single Objective**

- ["Minimize total distance"]{.highlight}
- Clear winner. Easy, right!

. . .

**Multiple Objectives**

- ["Minimize cost AND emissions AND maximize speed"]{.highlight}
- No clear answer...

. . .

[Question:]{.question} Any idea how to approach this?

## EcoExpress Vehicle Options

```{python}
#| echo: false
#| eval: true

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append('../helpers')
from plot_utils import setup_clean_style, BRAND_COLORS, PLOT_COLORS

# Apply consistent brand styling
setup_clean_style()

vehicles = pd.DataFrame({
    'Type': ['E-Truck', 'Hybrid Van', 'Diesel Van', 'E-Cargo Bike', 'Autonomous'],
    'Purchase Cost (€)': [75000, 45000, 35000, 12000, 95000],
    'Operating (€/km)': [0.18, 0.25, 0.38, 0.05, 0.12],
    'CO2 (g/km)': [0, 95, 185, 0, 0],
    'Speed (km/h)': [55, 65, 70, 30, 40],
    'Capacity (parcels)': [300, 200, 250, 50, 150],
    'Range (km)': [250, 600, 800, 60, 180]
})

# Display as nice table
from IPython.display import display, HTML
display(HTML(vehicles.to_html(index=False, classes='table table-striped')))
```
. . .

[Question:]{.question} Which vehicle is "best" for EcoExpress?

## Trade-offs Everywhere

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3)

# Cost vs Emissions
axes[0].scatter(vehicles['Purchase Cost (€)']/1000, 
                vehicles['CO2 (g/km)'], 
                s=vehicles['Capacity (parcels)'],
                alpha=0.7, color=PLOT_COLORS[0])
for i, txt in enumerate(vehicles['Type']):
    axes[0].annotate(txt, (vehicles['Purchase Cost (€)'].iloc[i]/1000, 
                           vehicles['CO2 (g/km)'].iloc[i]),
                    fontsize=9)
axes[0].set_xlabel('Purchase Cost (k€)')
axes[0].set_ylabel('CO2 Emissions (g/km)')
axes[0].set_title('Cost vs Environmental Impact')

# Speed vs Cost
axes[1].scatter(vehicles['Speed (km/h)'], 
                vehicles['Operating (€/km)'],
                s=vehicles['Capacity (parcels)'],
                alpha=0.7, color=PLOT_COLORS[1])
for i, txt in enumerate(vehicles['Type']):
    axes[1].annotate(txt, (vehicles['Speed (km/h)'].iloc[i], 
                           vehicles['Operating (€/km)'].iloc[i]),
                    fontsize=9)
axes[1].set_xlabel('Speed (km/h)')
axes[1].set_ylabel('Operating (€/km)')
axes[1].set_title('Speed vs Operating Cost')

# Capacity vs Range
axes[2].scatter(vehicles['Capacity (parcels)'], 
                vehicles['Range (km)'],
                s=vehicles['Purchase Cost (€)']/300,
                alpha=0.7, color=PLOT_COLORS[2])
for i, txt in enumerate(vehicles['Type']):
    axes[2].annotate(txt, (vehicles['Capacity (parcels)'].iloc[i], 
                           vehicles['Range (km)'].iloc[i]),
                    fontsize=9)
axes[2].set_xlabel('Capacity (parcels)')
axes[2].set_ylabel('Range (km)')
axes[2].set_title('Capacity vs Range')

plt.tight_layout()
plt.show()
```

. . .

::: callout-important
Every vehicle excels at something different!
:::

## Real Business Constraints

[Beyond the numbers, consider:]{.highlight}

::: {.incremental}
- **EU regulations:** Carbon tax of €100/ton CO₂ starting 2025
- **Competition:** Amazon promises 2-hour delivery
- **Labor market:** Autonomous vehicles reduce driver dependency
- **Urban zones:** Zero-emission zones in city centers
- **Peak times:** Black Friday = 3x normal volume
:::

. . .

::: {.callout-important}
There is no single "optimal" solution - only trade-offs
:::

# [Pareto Optimality]{.flow} {.title}

## Dominated Solutions

[A solution is dominated if another solution is:]{.highlight} 

```{python}
#| echo: false
#| eval: true

# Create example data
np.random.seed(42)
n_solutions = 30
cost = np.random.uniform(20, 100, n_solutions)
emissions = 150 - cost + np.random.normal(0, 15, n_solutions)

# Identify Pareto front
pareto_mask = np.ones(n_solutions, dtype=bool)
for i in range(n_solutions):
    for j in range(n_solutions):
        if i != j:
            if cost[j] <= cost[i] and emissions[j] <= emissions[i]:
                if cost[j] < cost[i] or emissions[j] < emissions[i]:
                    pareto_mask[i] = False
                    break

fig, ax = plt.subplots()

# Plot dominated solutions
ax.scatter(cost[~pareto_mask], emissions[~pareto_mask], 
          alpha=0.3, s=100, color=BRAND_COLORS["darker"], label='Dominated')

# Plot Pareto optimal solutions
ax.scatter(cost[pareto_mask], emissions[pareto_mask], 
          alpha=0.8, s=100, color=PLOT_COLORS[1], label='Pareto Optimal')

# Sort Pareto points and draw frontier
pareto_cost = cost[pareto_mask]
pareto_emissions = emissions[pareto_mask]
sorted_idx = np.argsort(pareto_cost)
ax.plot(pareto_cost[sorted_idx], pareto_emissions[sorted_idx], 
        '--', color=PLOT_COLORS[1], alpha=0.5, linewidth=2)

# Highlight one dominated solution
example_idx = np.where(~pareto_mask)[0][5]
ax.scatter(cost[example_idx], emissions[example_idx], 
          s=200, color='red', marker='x', linewidth=3)
ax.annotate('Dominated\n(worse in both)', 
           (cost[example_idx], emissions[example_idx]),
           xytext=(cost[example_idx]+10, emissions[example_idx]+5),
           fontsize=10, ha='center',
           arrowprops=dict(arrowstyle='->', color='red'))

ax.set_xlabel('Cost (€)', fontsize=12)
ax.set_ylabel('CO2 Emissions (g/km)', fontsize=12)
ax.set_title('Pareto Frontier: Non-Dominated Solutions', fontsize=14)
ax.legend()
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

. . .

:::callout-important
Better in at least one objective and not worse in any objective!
:::

## The Pareto Frontier

[The Pareto frontier is the set of all non-dominated solutions]{.highlight}

::: {.incremental}
- No solution is objectively "better"
- Each represents a different trade-off
- Moving along frontier: gain in one objective, loss in another
- Decision makers choose based on **preferences**
:::

. . .

[Question]{.question} Do you think you get the idea?

## Find the Non-Dominated

```{python}
#| echo: false
#| eval: true

# Simple example for interaction - designed to have clear dominance
solutions = pd.DataFrame({
    'Fleet': ['A', 'B', 'C', 'D', 'E'],
    'Cost (k€)': [100, 120, 90, 105, 95],
    'Emissions (tons/year)': [50, 30, 40, 55, 60]
})

# Determine which are dominated
dominated = []
for i in range(len(solutions)):
    for j in range(len(solutions)):
        if i != j:
            # Check if j dominates i
            if (solutions.iloc[j]['Cost (k€)'] <= solutions.iloc[i]['Cost (k€)'] and
                solutions.iloc[j]['Emissions (tons/year)'] <= solutions.iloc[i]['Emissions (tons/year)'] and
                (solutions.iloc[j]['Cost (k€)'] < solutions.iloc[i]['Cost (k€)'] or
                 solutions.iloc[j]['Emissions (tons/year)'] < solutions.iloc[i]['Emissions (tons/year)'])):
                dominated.append(i)
                break

# Color code based on dominance
fig, ax = plt.subplots()
for i, row in solutions.iterrows():
    color = BRAND_COLORS["darker"] if i in dominated else PLOT_COLORS[1]
    alpha = 0.4 if i in dominated else 0.8
    ax.scatter(row['Cost (k€)'], row['Emissions (tons/year)'], 
              s=500, alpha=alpha, color=color, linewidth=2)
    ax.annotate(row['Fleet'], 
               (row['Cost (k€)'], row['Emissions (tons/year)']),
               fontsize=14, ha='center', va='center', fontweight='bold')

ax.set_xlabel('Cost (k€)', fontsize=12)
ax.set_ylabel('Emissions (tons/year)', fontsize=12)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Which fleets are non-dominated?

## Three+ Objectives

[With 3 objectives, the Pareto frontier becomes a surface:]{.highlight}

```{python}
#| echo: false
#| eval: true

from mpl_toolkits.mplot3d import Axes3D

# Generate 3D Pareto example
np.random.seed(123)
n = 100
cost_3d = np.random.uniform(50, 150, n)
emissions_3d = 200 - cost_3d + np.random.normal(0, 20, n)
speed_3d = cost_3d/2 + np.random.normal(0, 10, n)

# Simple Pareto identification (approximate)
pareto_3d = []
for i in range(n):
    dominated = False
    for j in range(n):
        if i != j:
            if (cost_3d[j] <= cost_3d[i] and 
                emissions_3d[j] <= emissions_3d[i] and 
                speed_3d[j] >= speed_3d[i]):
                if (cost_3d[j] < cost_3d[i] or 
                    emissions_3d[j] < emissions_3d[i] or 
                    speed_3d[j] > speed_3d[i]):
                    dominated = True
                    break
    if not dominated:
        pareto_3d.append(i)

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

# Plot all solutions
ax.scatter(cost_3d, emissions_3d, speed_3d, 
          alpha=0.2, s=30, color=BRAND_COLORS["darker"])

# Highlight Pareto solutions
ax.scatter(cost_3d[pareto_3d], emissions_3d[pareto_3d], speed_3d[pareto_3d], 
          alpha=0.8, s=60, color=PLOT_COLORS[1], edgecolors=PLOT_COLORS[1])

ax.set_xlabel('Cost (€)', fontsize=10, labelpad=15)
ax.set_ylabel('Emissions (g/km)', fontsize=10, labelpad=15)
ax.set_zlabel('Speed (km/h)', fontsize=10, labelpad=15)
ax.set_title('3D Pareto Frontier (Surface)', fontsize=14, fontweight='bold', pad=20)
ax.view_init(elev=20, azim=45)

# Fix the cutoff issue
plt.subplots_adjust(left=0, right=1, bottom=0, top=1)
plt.tight_layout()
plt.show()
```

. . .

::: callout-important
Harder to visualize, but same principle applies!
:::

# [Transportation Problem]{.flow} {.title}

## Multi-Objective Transportation

```{python}
#| echo: false
#| eval: true

# Visualize transportation trade-offs
fig, ax = plt.subplots()

# Define routes with their characteristics
routes = {
    'Route A: City Center': {'distance': 50, 'time': 90, 'cost': 80, 'emissions': 120},
    'Route B: Highway': {'distance': 80, 'time': 60, 'cost': 100, 'emissions': 90},
    'Route C: Suburbs': {'distance': 65, 'time': 75, 'cost': 85, 'emissions': 100}
}

# Create parallel coordinates plot
categories = ['Distance\n(km)', 'Time\n(min)', 'Cost\n(€)', 'Emissions\n(kg CO₂)']
n_cats = len(categories)

for i, (route_name, values) in enumerate(routes.items()):
    # Normalize values for plotting
    vals = [values['distance']/80, values['time']/90, 
            values['cost']/100, values['emissions']/120]
    
    x = np.arange(n_cats)
    ax.plot(x, vals, 'o-', linewidth=2.5, markersize=10, 
            label=route_name, color=PLOT_COLORS[i], alpha=0.8)

ax.set_xticks(x)
ax.set_xticklabels(categories)
ax.set_ylabel('Normalized Value', fontsize=11)
ax.legend(loc='best')
ax.grid(True, alpha=0.2)
ax.set_ylim(0, 1.1)

# Add annotations
ax.annotate('Short but slow\n& high emissions', xy=(0, 0.6), 
            xytext=(0, 0.3), fontsize=12, color=PLOT_COLORS[0],
            arrowprops=dict(arrowstyle='->', color=PLOT_COLORS[0], alpha=0.5))
ax.annotate('Fast but long\n& expensive', xy=(1, 0.65), 
            xytext=(1, 0.3), fontsize=12, color=PLOT_COLORS[1],
            arrowprops=dict(arrowstyle='->', color=PLOT_COLORS[1], alpha=0.5))

plt.tight_layout()
plt.show()
```

. . .

::: callout-tip
[Logistics decisions involve trade-offs:]{.highlight} City traffic (slow, high emissions), Night delivery? → Highway (fast, but more distance), Customer priority? → Direct route (expensive)
:::

## Classic Transportation

[Let's understand the foundation]{.highlight}

. . .

```{python}
#| echo: false
#| eval: true

import pandas as pd
import numpy as np

# Transportation problem data
supply = [300, 250, 200]  # Parcels available
demand = [200, 180, 220, 150]  # Parcels needed

# Create comprehensive table with costs, supply, and demand
transport_table = pd.DataFrame({
    'From/To': ['DC Berlin', 'DC Hamburg', 'DC Munich', 'Demand'],
    'Zone A': [8, 12, 15, demand[0]],
    'Zone B': [10, 9, 13, demand[1]],
    'Zone C': [11, 7, 10, demand[2]],
    'Zone D': [14, 8, 9, demand[3]],
    'Supply': supply + [sum(demand)]
})

display(HTML(transport_table.to_html(index=False, classes='table table-striped')))

# Check if balanced
total_supply = sum(supply)
total_demand = sum(demand)
if total_supply != total_demand:
    print(f"\n✗ Unbalanced: Supply ({total_supply}) ≠ Demand ({total_demand})")
```

::: callout-note
Cost per 100 parcels (€) in the middle of the table!
:::

## Objective Function

[The foundation of the classical model]{.highlight}

$$\text{Minimize } Z = \sum_{i} \sum_{j} c_{ij} \cdot x_{ij}$$

Where:

- $x_{ij}$ = parcels shipped from DC $i$ to Zone $j$
- $c_{ij}$ = cost per 100 parcels from $i$ to $j$

## Second Objective: Emissions

[Now the real challenge - each route has different emissions:]{.highlight}

```{python}
#| echo: false
#| eval: true

# Emissions data (designed to conflict with cost structure)
emissions_data = pd.DataFrame({
    'From/To': ['DC Berlin', 'DC Hamburg', 'DC Munich'],
    'Zone A': [120, 45, 60],  # g CO2/parcel - Hamburg is greenest (but expensive)
    'Zone B': [95, 110, 50],   # Munich is greenest for Zone B
    'Zone C': [85, 100, 115],  # Berlin is greenest (but expensive)
    'Zone D': [70, 90, 105]    # Berlin is greenest (but most expensive)
})

display(HTML(emissions_data.to_html(index=False, classes='table table-striped')))
```

::: callout-note
Emissions per parcel (g CO₂) in the table
:::

## Objective Function II

[Now with two objectives!]{.highlight}

$$\text{Minimize } Z_1 = \sum_{i} \sum_{j} c_{ij} \cdot x_{ij} \quad \text{(Cost)}$$
$$\text{Minimize } Z_2 = \sum_{i} \sum_{j} e_{ij} \cdot x_{ij} \quad \text{(Emissions)}$$

Where $e_{ij}$ = emissions per parcel from $i$ to $j$

. . .

[Notice: Cheapest routes ≠ Greenest routes!]{.highlight}

## Data Source

[Where Do These Numbers Come From?]{.highlight}

. . .

**Cost Data:**

::: incremental
- **Historical records**: Your accounting system
- **Quotes**: Request from carriers/suppliers  
- **APIs**: Google Maps Distance Matrix (distance → cost)
:::

. . .

**Emissions Data:**

::: incremental
- **EU Standards or Carrier data**
- **Formula**: `Emissions = Distance × Weight × EmissionFactor`
:::

## The Transportation Trade-off

```{python}
#| echo: false
#| eval: true

from scipy.optimize import linprog

# Cost and emissions matrices (from our data)
costs = np.array([[8, 10, 11, 14],    # DC Berlin
                  [12, 9, 7, 8],       # DC Hamburg
                  [15, 13, 10, 9]])    # DC Munich

# Updated emissions to create actual trade-off
emissions = np.array([[120, 95, 85, 70],   # DC Berlin (g CO2/parcel)
                      [45, 110, 100, 90],  # DC Hamburg
                      [60, 50, 115, 105]]) # DC Munich

supply = np.array([300, 250, 200])
demand = np.array([200, 180, 220, 150])

# Solve for different weights (0 = cost only, 1 = emissions only)
solutions = []
weights = np.linspace(0, 1, 15)

for w in weights:
    # Combined objective: (1-w)*cost + w*emissions
    # Normalize to make them comparable
    c_combined = (1-w) * costs.flatten() / 10 + w * emissions.flatten() / 100
    
    # Constraints: supply and demand
    A_eq = []
    b_eq = []
    
    # Supply constraints (one per DC)
    for i in range(3):
        constraint = np.zeros(12)
        constraint[i*4:(i+1)*4] = 1
        A_eq.append(constraint)
        b_eq.append(supply[i])
    
    # Demand constraints (one per Zone)
    for j in range(4):
        constraint = np.zeros(12)
        for i in range(3):
            constraint[i*4 + j] = 1
        A_eq.append(constraint)
        b_eq.append(demand[j])
    
    # Solve
    result = linprog(c_combined, A_eq=A_eq, b_eq=b_eq, 
                     bounds=(0, None), method='highs')
    
    if result.success:
        x = result.x.reshape(3, 4)
        total_cost = np.sum(costs * x) * 10  # Cost per 100 parcels
        total_emissions = np.sum(emissions * x) / 1000  # Convert to kg
        solutions.append({'Cost': total_cost, 'Emissions': total_emissions, 'Weight': w})

sol_df = pd.DataFrame(solutions)

fig, ax = plt.subplots()

# Plot Pareto frontier
ax.plot(sol_df['Cost'], sol_df['Emissions'], 
        '-o', linewidth=2.5, markersize=5, color=BRAND_COLORS["darker"], 
        label='Pareto frontier', alpha=0.7)

# Highlight extremes
min_cost = sol_df.iloc[0]
min_emissions = sol_df.iloc[-1]

ax.scatter(min_cost['Cost'], min_cost['Emissions'],
          s=200, color=PLOT_COLORS[2], marker='*', 
          label=f'Min Cost: €{min_cost["Cost"]:.0f}', 
          edgecolors='black', linewidth=1.5, zorder=5)
ax.scatter(min_emissions['Cost'], min_emissions['Emissions'],
          s=200, color=PLOT_COLORS[0], marker='*', 
          label=f'Min Emissions: {min_emissions["Emissions"]:.1f} kg', 
          edgecolors='black', linewidth=1.5, zorder=5)

# Add a balanced solution
balanced_idx = len(sol_df) // 2
balanced = sol_df.iloc[balanced_idx]
ax.scatter(balanced['Cost'], balanced['Emissions'],
          s=200, color=PLOT_COLORS[1], marker='D', 
          label='Balanced solution', 
          edgecolors='black', linewidth=1.5, zorder=5)

ax.set_xlabel('Total Cost (€)', fontsize=13, fontweight='bold')
ax.set_ylabel('Total CO₂ Emissions (kg)', fontsize=13, fontweight='bold')
ax.legend(fontsize=10, loc='best')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Print key insights
print(f"Cost increase for greenest solution: +€{min_emissions['Cost'] - min_cost['Cost']:.0f} ({(min_emissions['Cost']/min_cost['Cost']-1)*100:.1f}%)")
print(f"Emissions reduction from cheapest: -{min_cost['Emissions'] - min_emissions['Emissions']:.1f} kg ({(1-min_emissions['Emissions']/min_cost['Emissions'])*100:.1f}%)")
```

. . .

::: callout-important
Each point represents a different allocation strategy!
:::

# [Solution Approaches]{.flow} {.title}

## Multi-Objective Optimization

[You can use optimization solvers or heuristics!]{.highlight}

. . .

::: columns
::: {.column width="50%"}
**With Optimization Solvers**

- Weighted Sum Method
- ε-Constraint Method  
- Goal Programming
- **Optimal solutions**
- **Need mathematical model**
:::

::: {.column width="50%"}
**With Heuristics**

- Weighted Greedy Construction
- Multi-Objective Local Search
- Metaheuristics
- **Good solutions, fast**
- **No optimality proof**
:::
:::

. . .

::: {.callout-important}
In this lecture we use heuristic approaches!
:::

## Foundation: Extreme Points

[First step for BOTH approaches - find the boundaries:]{.highlight}

```{python}
#| echo: false
#| eval: true

# Use the transportation problem Pareto frontier from earlier
fig, axes = plt.subplots(1, 2)

# Left plot: Show extreme points from transportation problem
ax1 = axes[0]

# Plot the Pareto frontier from transportation problem
ax1.plot(sol_df['Cost'], sol_df['Emissions'], 
        '-', linewidth=2.5, alpha=0.7, label='Pareto Frontier', 
        marker='o', markersize=6, color=BRAND_COLORS["darker"])

# Mark extreme points
min_cost = sol_df.iloc[0]
min_emissions = sol_df.iloc[-1]

ax1.scatter(min_cost['Cost'], min_cost['Emissions'],
           s=200, color=PLOT_COLORS[2], marker='*', label=f'Min Cost: €{min_cost["Cost"]:.0f}',
           edgecolors='black', linewidth=2, zorder=10)
ax1.scatter(min_emissions['Cost'], min_emissions['Emissions'],
           s=200, color=PLOT_COLORS[0], marker='*', label=f'Min Emissions: {min_emissions["Emissions"]:.1f} kg',
           edgecolors='black', linewidth=2, zorder=10)

# Add ideal point (infeasible - best of both)
ideal_cost = min_cost['Cost']
ideal_emissions = min_emissions['Emissions']
ax1.scatter(ideal_cost, ideal_emissions, s=150, color=PLOT_COLORS[1], marker='D', 
           label='Ideal (Infeasible)', edgecolors='black', linewidth=2, alpha=0.7)

# Draw box showing trade-off space
worst_cost = min_emissions['Cost']
worst_emissions = min_cost['Emissions']

ax1.set_xlabel('Cost (€)', fontsize=12, fontweight='bold')
ax1.set_ylabel('Emissions (kg CO₂)', fontsize=12, fontweight='bold')
ax1.set_title('Step 1: Find Extreme Points', fontsize=13, fontweight='bold')
ax1.legend(fontsize=10)
ax1.grid(True, alpha=0.3)

# Right plot: Show normalization (scaled to [0,1])
ax2 = axes[1]

# Calculate normalized values
cost_range = worst_cost - ideal_cost
emissions_range = worst_emissions - ideal_emissions

# Show normalized ranges
objectives = ['Cost\n(normalized)', 'Emissions\n(normalized)']
normalized_mins = [0, 0]
normalized_maxs = [1, 1]

x = np.arange(len(objectives))
width = 0.35

bars1 = ax2.bar(x - width/2, normalized_mins, width, label='Min (Best) = 0', 
               color=PLOT_COLORS[1], alpha=0.7, edgecolor='black', linewidth=1.5)
bars2 = ax2.bar(x + width/2, normalized_maxs, width, label='Max (Worst) = 1', 
               color=PLOT_COLORS[0], alpha=0.7, edgecolor='black', linewidth=1.5)

# Add original range annotations
ax2.text(0, 0.5, f'€{ideal_cost:.0f} → €{worst_cost:.0f}\nRange: €{cost_range:.0f}', 
        ha='center', va='center', fontsize=10, fontweight='bold',
        bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
ax2.text(1, 0.5, f'{ideal_emissions:.1f}kg → {worst_emissions:.1f}kg\nRange: {emissions_range:.1f}kg', 
        ha='center', va='center', fontsize=10, fontweight='bold',
        bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

ax2.set_ylabel('Normalized Value [0, 1]', fontsize=12, fontweight='bold')
ax2.set_title('Step 2: Normalize to [0,1] Scale', fontsize=13, fontweight='bold')
ax2.set_xticks(x)
ax2.set_xticklabels(objectives)
ax2.set_ylim(-0.1, 1.3)
ax2.legend(fontsize=10)
ax2.grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Why is normalization essential?

## Critical: Normalization

[Without it, your analysis is meaningless]{.highlight}

```{python}
#| echo: false
#| eval: true

# Demonstrate the normalization problem with trade-offs
fig, axes = plt.subplots(1, 3)

# Sample data showing real trade-offs
# Solution A: Cheap but slow and dirty
# Solution B: Balanced
# Solution C: Fast and clean but expensive
cost_vals = np.array([50000, 75000, 100000])  # In euros
emissions_vals = np.array([150, 100, 50])      # In g/km (INVERSED - cheaper = dirtier)
speed_vals = np.array([40, 55, 70])            # In km/h

objectives = ['Solution A', 'Solution B', 'Solution C']

# Plot 1: Raw values (wrong!)
ax1 = axes[0]
x = np.arange(len(objectives))
width = 0.25
ax1.bar(x - width, cost_vals, width, label='Cost (€)', color=PLOT_COLORS[0])
ax1.bar(x, emissions_vals, width, label='Emissions (g/km)', color=PLOT_COLORS[1])
ax1.bar(x + width, speed_vals, width, label='Speed (km/h)', color=PLOT_COLORS[2])
ax1.set_ylabel('Raw Values')
ax1.set_title('WRONG: Different Scales', fontweight='bold')
ax1.set_xticks(x)
ax1.set_xticklabels(objectives)
ax1.set_ylim(0, 140000)
ax1.legend()
ax1.annotate('Cost dominates everything!', xy=(1, 60000), fontsize=10, color='black')

# Plot 2: Min-Max Normalized [0,1]
ax2 = axes[1]
cost_norm = (cost_vals - cost_vals.min()) / (cost_vals.max() - cost_vals.min())
emissions_norm = (emissions_vals - emissions_vals.min()) / (emissions_vals.max() - emissions_vals.min())
speed_norm = (speed_vals - speed_vals.min()) / (speed_vals.max() - speed_vals.min())

ax2.bar(x - width, cost_norm, width, label='Cost', color=PLOT_COLORS[0])
ax2.bar(x, emissions_norm, width, label='Emissions', color=PLOT_COLORS[1])
ax2.bar(x + width, speed_norm, width, label='Speed', color=PLOT_COLORS[2])
ax2.set_ylabel('Normalized [0,1]')
ax2.set_title('Min-Max Normalization', fontweight='bold')
ax2.set_xticks(x)
ax2.set_xticklabels(objectives)
ax2.set_ylim(0, 1.4)
ax2.legend()

# Plot 3: Z-Score Standardized
ax3 = axes[2]
cost_std = (cost_vals - cost_vals.mean()) / cost_vals.std()
emissions_std = (emissions_vals - emissions_vals.mean()) / emissions_vals.std()
speed_std = (speed_vals - speed_vals.mean()) / speed_vals.std()

ax3.bar(x - width, cost_std, width, label='Cost', color=PLOT_COLORS[0])
ax3.bar(x, emissions_std, width, label='Emissions', color=PLOT_COLORS[1])
ax3.bar(x + width, speed_std, width, label='Speed', color=PLOT_COLORS[2])
ax3.set_ylabel('Standardized (μ=0, σ=1)')
ax3.set_title('Z-Score Standardization', fontweight='bold')
ax3.set_xticks(x)
ax3.set_xticklabels(objectives)
ax3.legend()
ax3.set_ylim(0, 1.6)
ax3.axhline(y=0, color='black', linestyle='-', linewidth=0.5)

plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Any intuition on how to do [0,1] normalization?

## How to Normalize

[The Normalization Formula for [0,1]]{.highlight}

$$\text{Normalized}_i = \frac{x_i - x_{min}}{x_{max} - x_{min}}$$

. . .

**In Python, this is rather simple!**

. . .

```python
def normalize_objectives(data):
    return (data - data.min()) / (data.max() - data.min())

# Now weights actually mean something
weighted_score = w1 * normalize(cost) + w2 * normalize(emissions)
```

. . .

::: callout-tip
Easy, right?
:::

## Extreme Points

[There are several reasons why extreme points matter:]{.highlight}

1. **Trade-off Space**: Min/max values bound your Pareto frontier
2. **Enable Proper Normalization**: Need ranges for scaling to [0,1]
3. **Feasibility**: If single objectives not achievable, problem infeasible
4. **Stakeholder**: "Best cost is €50k, best emissions is 40kg"

. . .

**Implementation Pattern:**
```python
def find_extreme_points(problem):
    # Solve for minimum cost (ignore emissions)
    min_cost_solution = minimize(cost_objective, constraints)
    # Solve for minimum emissions (ignore cost)
    min_emissions_solution = minimize(emissions_objective, constraints)
```

## Computational Complexity

[How hard does it get with more objectives?]{.highlight}

. . .

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots()

# Pareto front complexity growth
n_objectives = np.array([2, 3, 4, 5])
pareto_points = np.array([100, 1000, 10000, 100000])  # Exponential growth

ax.semilogy(n_objectives, pareto_points, 'o-', linewidth=3, 
            markersize=12, color=PLOT_COLORS[0])
ax.set_xlabel('Number of Objectives', fontsize=12)
ax.set_ylabel('Potential Pareto Points (log scale)', fontsize=12)
ax.set_title('Complexity Explosion', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.3)

# Add annotations
for i, (n, p) in enumerate(zip(n_objectives, pareto_points)):
    if n == 2:
        ax.annotate('Manageable\n(curve)', xy=(n, p), xytext=(n+0.15, p*3),
                   fontsize=10, ha='center', color=PLOT_COLORS[1])
    elif n == 3:
        ax.annotate('Challenging\n(surface)', xy=(n, p), xytext=(n+0.2, p*3),
                   fontsize=10, ha='center', color=PLOT_COLORS[2])
    elif n >= 4:
        ax.annotate('Very Hard!\n(hypersurface)', xy=(n, p), xytext=(n+0.3, p*0.3),
                   fontsize=10, ha='center', color='red')

plt.tight_layout()
plt.show()
```

. . .

::: callout-tip
Why? Because there are just way more potential solutions to check!
:::

## Solver-Based Methods

[Quick overview - you won't implement these in assignments]{.highlight}


::: incremental
1. **Weighted Sum:** Minimize $w_1 \times \text{cost} + w_2 \times \text{emissions}$
   - Simple, fast for convex problems
   
2. **ε-Constraint:** Minimize cost subject to emissions $\leq \varepsilon$
   - Systematically vary $\varepsilon$ to find complete frontier
   
3. **Goal Programming:** Minimize deviations from targets
   - Set target for each objective, minimize weighted deviations
:::

. . .

::: {.callout-note}
**For your fleet optimization:** You'll use **heuristic approaches** instead!
:::

# [Heuristic Approach]{.flow} {.title}

## The Heuristic Strategy

[For problems without mathematical models]{.highlight}

. . .

::: incremental
1. **Construction:** Build initial solutions with weighted greedy
2. **Improvement:** Multi-objective local search
3. **Selection:** Filter dominated solutions to find Pareto frontier
:::

. . .

::: {.callout-important}
**Key difference from solvers:**

- **Solvers:** Need mathematical model, guarantee optimality
- **Heuristics:** Work with any evaluation function, find good solutions fast
:::

## Why Heuristics?

[Depending on the problem:]{.highlight}

::: incremental
  - **Combinatorial explosion**
  - Huge solution space even for one problem
  - Evaluating one solution might thus take too long
  - Need diverse Pareto frontier, not just one "optimal" solution
  - Open Source Solvers too slow
  - Commercial solvers too expensive

:::

. . .

[Question:]{.question} How do we build good solutions without a solver?

## The Three-Stage Heuristic Process

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots()

# Visualization showing the three-stage process
stages_y = [0.8, 0.5, 0.2]
stage_names = [
    'Stage 1: Construction',
    'Stage 2: Improvement',
    'Stage 3: Selection'
]
stage_colors = [PLOT_COLORS[0], PLOT_COLORS[1], PLOT_COLORS[2]]

for i, (y, name, color) in enumerate(zip(stages_y, stage_names, stage_colors)):
    # Stage box
    rect = plt.Rectangle((0.1, y-0.08), 0.8, 0.12, 
                         facecolor=color, edgecolor='black', 
                         linewidth=2, alpha=0.6)
    ax.add_patch(rect)
    
    # Stage text
    ax.text(0.5, y, name, ha='center', va='center', 
           fontsize=13, fontweight='bold')
    
    # Arrow to next stage
    if i < len(stages_y) - 1:
        ax.arrow(0.5, y-0.08, 0, -0.06, head_width=0.05, 
                head_length=0.02, fc='black', ec='black', linewidth=2)

# Add outcome visualization on right side
# Generate example Pareto front
np.random.seed(42)
cost_range = np.linspace(60, 140, 20)
emissions_range = 180 - cost_range + np.random.normal(0, 8, 20)

# Normalize for plotting in figure coordinates
cost_norm = 0.1 + 0.35 * (cost_range - cost_range.min()) / (cost_range.max() - cost_range.min())
emissions_norm = 0.1 + 0.7 * (emissions_range - emissions_range.min()) / (emissions_range.max() - emissions_range.min())

# Transform to axis coordinates  
ax_cost = 0.55 + cost_norm
ax_emissions = emissions_norm

ax.plot(ax_cost, ax_emissions, 'o-', color='grey', 
       markersize=6, linewidth=2, label='Your Pareto Frontier')
ax.text(0.75, 0.85, 'Output:\nPareto Frontier', 
       ha='center', fontsize=11, fontweight='bold',
       bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.axis('off')
ax.set_title('Heuristic Multi-Objective Optimization Workflow', 
            fontsize=15, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()
```

. . .

[This is what you'll implement in your assignments!]{.highlight}

# [Construction & Improvement]{.flow} {.title}

## Construction Methods for MOO

[How to build initial solutions when you have multiple objectives?]{.highlight}

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3)

# Method 1: Weighted Greedy
ax1 = axes[0]
np.random.seed(42)
n_points = 15

# Simulate greedy solutions with different weight biases
cost_greedy = np.random.uniform(60, 140, n_points)
emissions_greedy = 250 - 1.5*cost_greedy + np.random.normal(0, 10, n_points)

ax1.scatter(cost_greedy[:5], emissions_greedy[:5], s=100, 
           color=PLOT_COLORS[0], alpha=0.7, label='Cost-focused greedy')
ax1.scatter(cost_greedy[5:10], emissions_greedy[5:10], s=100, 
           color=PLOT_COLORS[1], alpha=0.7, label='Emission-focused greedy')
ax1.scatter(cost_greedy[10:], emissions_greedy[10:], s=100, 
           color=PLOT_COLORS[2], alpha=0.7, label='Balanced greedy')

ax1.set_xlabel('Cost (€)', fontsize=10)
ax1.set_ylabel('Emissions (kg CO₂)', fontsize=10)
ax1.set_title('Method 1: Weighted Greedy', fontsize=11, fontweight='bold')
ax1.legend(fontsize=9)
ax1.grid(True, alpha=0.3)

# Method 2: Sequential Objectives
ax2 = axes[1]
# Show progression
stages = ['Stage 1:\nOptimize\nCost', 'Stage 2:\nFix Cost,\nOptimize\nEmissions', 'Stage 3:\nLocal\nadjustments']
y_pos = np.arange(len(stages))
colors_seq = [PLOT_COLORS[0], PLOT_COLORS[1], PLOT_COLORS[2]]

bars = ax2.barh(y_pos, [100, 70, 85], color=colors_seq, alpha=0.7)
ax2.set_yticks(y_pos)
ax2.set_yticklabels(stages)
ax2.set_xlabel('Solution Quality (%)', fontsize=10)
ax2.set_title('Method 2: Sequential Construction', fontsize=11, fontweight='bold')

# Method 3: Random + Filter
ax3 = axes[2]
# Generate random solutions
random_cost = np.random.uniform(50, 150, 50)
random_emissions = np.random.uniform(50, 250, 50)

# Mark dominated
dominated_mask = np.random.choice([True, False], 50, p=[0.7, 0.3])
ax3.scatter(random_cost[~dominated_mask], random_emissions[~dominated_mask], 
           s=80, alpha=0.7, color=PLOT_COLORS[1])

ax3.set_xlabel('Cost (€)', fontsize=10)
ax3.set_ylabel('Emissions (kg CO₂)', fontsize=10)
ax3.set_title('Method 3: Generate & Filter', fontsize=11, fontweight='bold')
ax3.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

. . .

::: callout-note
Three choices (for starters). Let's check them out!
:::

## Weighted Greedy Construction

[Making greedy choices on a weighted objective]{.highlight}

::: {.incremental}
1. **Choose weight vector** w = (w₁, w₂)
2. **At each step, pick the choice that minimizes:**
   $$w_1 \cdot \text{cost}(x) + w_2 \cdot \text{emissions}(x)$$
3. **Build complete solution greedily**
4. **Repeat** with different weights to explore frontier
:::

. . .

::: callout-tip
Different weights explore different trade-offs! Easy, right?
:::

## Sequential Greedy (Lexicographic)

[Optimize one objective at a time, in priority order]{.highlight}

::: {.incremental}
1. **Rank objectives by priority**
   - E.g. cost (most important) and then emissions (tie-breaker)
2. **At each step:**
   - Find choices that minimize **primary** objective
   - If tie → use **secondary** objective
3. **Build one working solution**
:::

. . .

::: callout-tip
We could also accept primary values within 10% of best so secondary has more influence!
:::

## Diverse Starting Pool

[Generate many random solutions, keep the non-dominated ones]{.highlight}

::: {.incremental}
1. **Generate N random solutions (e.g., N=100)**
2. **Evaluate all solutions on both objectives**
3. **Filter to keep only non-dominated solutions**
4. **Result:** A diverse set of Pareto-optimal solutions
:::

. . .

::: callout-tip
- Explores **entire** solution space
- No bias toward specific weights
- Great for **warm-starting** local search
:::

## Local Search for Multi-Objective

[Special moves that improve multiple objectives:]{.highlight}

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots()

# Current solution (normalized space)
current_cost = 0.5
current_emissions = 0.5
ax.scatter(current_cost, current_emissions, s=400, color=BRAND_COLORS['darker'], 
          marker='*', label='Current Solution', zorder=10, edgecolors='white', linewidth=2)

# Show different move types (normalized deltas)
moves = [
    {'name': 'Trade-off', 'dcost': 0.15, 'demissions': -0.12, 'color': PLOT_COLORS[0]},
    {'name': 'Win-Win', 'dcost': -0.08, 'demissions': -0.08, 'color': PLOT_COLORS[1]},
    {'name': 'Cost Focus', 'dcost': -0.12, 'demissions': 0.04, 'color': PLOT_COLORS[2]},
    {'name': 'Green Focus', 'dcost': 0.04, 'demissions': -0.15, 'color': PLOT_COLORS[3]},
    {'name': 'Bad Move', 'dcost': 0.12, 'demissions': 0.15, 'color': PLOT_COLORS[0], 'style': '--'}
]

for move in moves:
    new_cost = current_cost + move['dcost']
    new_emissions = current_emissions + move['demissions']
    style = move.get('style', '-')
    
    # Draw arrow
    ax.annotate('', xy=(new_cost, new_emissions), 
                xytext=(current_cost, current_emissions),
                arrowprops=dict(arrowstyle='->', color=move['color'], 
                              lw=2.5, linestyle=style, alpha=0.8))
    
    # Add endpoint
    ax.scatter(new_cost, new_emissions, s=200, color=move['color'], 
              alpha=0.7, edgecolors=BRAND_COLORS['darker'], linewidth=1.5)
    ax.text(new_cost, new_emissions - 0.06, move['name'], 
           fontsize=10, ha='center', fontweight='bold')

ax.set_xlabel('Normalized Cost')
ax.set_ylabel('Normalized Emissions')
ax.set_title('Multi-Objective Local Search: Not All Moves Are Equal!', fontweight='bold')
ax.legend(loc='upper right')
ax.grid(True, alpha=0.2)
ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Which moves are acceptable?

## MOO Local Search Rules

[Accept a move if:]{.highlight}

1. **Dominance**: New solution dominates current (win-win!)
2. **Trade-off**: Improves primary, acceptable loss in secondary
3. **Diversity**: Fills gap in current Pareto front
4. **Probabilistic**: Use temperature (like simulated annealing)

. . .

::: callout-important
Always keep all your objectives in mind when making decisions.
:::

# [From Pareto Front to Decision]{.flow} {.title}

## How to Choose!

::: incremental
1. [The Knee Point:]{.highlight} Find the "elbow" where improvement slows
1. [Satisficing Levels:]{.highlight} Set minimum acceptable thresholds
   - **Cost** must be < €100k (budget constraint)
   - **Emissions** must be < 100 kg (regulatory limit)
   - **Service level** must be > 90% (customer requirement)
3. [Stakeholder Preferences:]{.highlight} Let business priorities guide
   - **Sustainability:** Minimum emissions that meets constraints
   - **Operations:** Maximum service level within budget
:::
  
## Weighted Sum Along the Frontier

[The weight influences the final choice:]{.highlight}

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3, figsize=(14, 4))

# Generate smooth Pareto frontier
t = np.linspace(0, 1, 100)
pareto_cost = 50 + 100 * (1 - t**1.5)
pareto_emissions = 200 * t**1.5 + 50

# Different weight scenarios
weight_scenarios = [
    (0.9, 0.1, 'Cost Focus (90/10)'),
    (0.5, 0.5, 'Balanced (50/50)'),
    (0.1, 0.9, 'Green Focus (10/90)')
]

# Normalize for all plots
norm_cost = (pareto_cost - pareto_cost.min()) / (pareto_cost.max() - pareto_cost.min())
norm_emissions = (pareto_emissions - pareto_emissions.min()) / (pareto_emissions.max() - pareto_emissions.min())

for idx, (w_cost, w_emissions, title) in enumerate(weight_scenarios):
    ax = axes[idx]
    
    # Plot Pareto frontier in normalized space
    ax.plot(norm_cost, norm_emissions, color=PLOT_COLORS[1], 
            linewidth=2.5, alpha=0.7, label='Pareto Frontier')
    
    # Calculate weighted scores
    weighted_scores = w_cost * norm_cost + w_emissions * norm_emissions
    optimal_idx = np.argmin(weighted_scores)
    
    # Plot optimal point
    ax.scatter(norm_cost[optimal_idx], norm_emissions[optimal_idx], 
              s=250, color=PLOT_COLORS[0], marker='*', edgecolors=BRAND_COLORS['darker'], 
              linewidth=2, zorder=10, label='Selected')
    
    # Draw iso-cost lines (lines of equal weighted sum)
    for level in np.linspace(0, 1, 7):
        # Line equation: w_cost * x + w_emissions * y = level
        # Solve for y: y = (level - w_cost * x) / w_emissions
        x_line = np.linspace(-0.1, 1.1, 100)
        if w_emissions > 0:
            y_line = (level - w_cost * x_line) / w_emissions
            ax.plot(x_line, y_line, '--', alpha=0.15, color=BRAND_COLORS['darker'], linewidth=1)
    
    # Add weight vector (gradient direction)
    vector_scale = 0.25
    ax.arrow(norm_cost[optimal_idx], norm_emissions[optimal_idx],
            -w_cost * vector_scale, -w_emissions * vector_scale,
            head_width=0.03, head_length=0.02, fc=PLOT_COLORS[2], ec=PLOT_COLORS[2],
            alpha=0.7, linewidth=2)
    
    ax.set_xlabel('Normalized Cost')
    ax.set_ylabel('Normalized Emissions')
    ax.set_title(title, fontweight='bold')
    ax.set_xlim(-0.05, 1.05)
    ax.set_ylim(-0.05, 1.05)
    ax.set_aspect('equal', adjustable='box')
    ax.grid(True, alpha=0.2)
    ax.legend()

plt.tight_layout()
plt.show()
```

. . .

::: callout-note
The iso-cost lines show the trade-offs between cost and emissions.
:::

## Weighting has an Impact

[The weights thus reflect your values!]{.highlight}

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots()

# Generate diverse fleet combinations with clear trade-offs
np.random.seed(456)
n_fleets = 25
fleet_cost = np.random.uniform(60, 140, n_fleets)
# Add non-linear relationship so different weights pick different points
fleet_emissions = 50 + 150 * (1 - (fleet_cost - 60) / 80)**1.5 + np.random.normal(0, 12, n_fleets)

# Normalize for scoring
norm_cost = (fleet_cost - fleet_cost.min()) / (fleet_cost.max() - fleet_cost.min())
norm_emissions = (fleet_emissions - fleet_emissions.min()) / (fleet_emissions.max() - fleet_emissions.min())

# Show three different weight scenarios
weight_scenarios = [
    (0.9, 0.1, 'Business Focus'),
    (0.5, 0.5, 'Balanced'),
    (0.1, 0.9, 'Environmental Focus')
]

scenario_colors = [PLOT_COLORS[0], PLOT_COLORS[2], PLOT_COLORS[1]]
for (w_cost, w_emissions, label), color in zip(weight_scenarios, scenario_colors):
    # Minimize weighted sum
    scores = w_cost * norm_cost + w_emissions * norm_emissions
    best = np.argmin(scores)
    ax.scatter(fleet_cost[best], fleet_emissions[best], 
              s=300, color=color, alpha=0.7, label=label,
              edgecolors=BRAND_COLORS['darker'], linewidth=2, zorder=5)

# Plot all options
ax.scatter(fleet_cost, fleet_emissions, alpha=0.3, s=60, 
          color=BRAND_COLORS['darker'], label='Available fleets')

ax.set_xlabel('Total Fleet Cost (k€)')
ax.set_ylabel('Annual Emissions (tons CO₂)')
ax.set_title('Different Priorities → Different Optimal Fleets', fontweight='bold')
ax.legend()
ax.grid(True, alpha=0.2)
plt.tight_layout()
plt.show()
```

. . .

::: callout-tip
Depending on your weight, the choice will vary.
:::

## Common Pitfalls to Avoid

::: incremental
1. **Forgetting to Normalize**
   - Always normalize to [0,1] first!
2. **Optimizing Too Many Objectives**
   - 2-3: Manageable, 4+: Exponentially harder
   - Combine related objectives or use constraints
3. **Not Checking Solution Feasibility**
   - Pareto optimal ≠ Feasible for your constraints
   - Always verify constraints after optimization
:::

# [Advanced]{.flow} {.title}

## Speed vs Sustainability Dilemma

[The Three-Way Trade-off in E-Commerce]{.highlight}

1. **Minimize Delivery Time** (1-day/2-hour promise)
2. **Minimize Cost** (fuel, labor, fulfillment)
3. **Minimize Environmental Impact** (carbon footprint)

. . .

[Faster delivery = More vehicles less full = Higher emissions]{.highlight}

. . .

[Question:]{.question} What could retailers do?

## Moving the Frontier

[Instead of point on the frontier, move the entire frontier:]{.highlight}

. . .

[Question:]{.question} Any idea of examples?

. . .

::: callout-tip
R&D can fundamentally change what's possible!
:::

# [Real-World Application]{.flow} {.title}

## EcoExpress Requirements

For your **regional delivery network**, you need:

::: {.incremental}
- Total budget: €3.5 million
- Fleet size: 60-120 vehicles
- Service level: 95% on-time delivery
- Emission target: 40% reduction from current
- Handle Black Friday (3x normal volume)
- Cover 3 cities with different regulations
:::

## Fleet Composition Strategy

Instead of one vehicle type, consider a **mixed fleet**:

```{python}
#| echo: false
#| eval: true

# Example fleet mix
fleet_mix = pd.DataFrame({
    'Vehicle Type': ['E-Truck', 'Hybrid Van', 'Diesel Van', 'E-Cargo Bike', 'Autonomous'],
    'Quantity': [25, 30, 15, 20, 10],
    'Use Case': ['City A (strict emissions)', 'City B (balanced)', 'City C (rural)', 'Dense urban cores', 'Night shifts'],
    'Advantage': ['Zero emissions', 'Versatile', 'Long range', 'Agile in traffic', 'No driver needed']
})

display(HTML(fleet_mix.to_html(index=False, classes='table table-striped')))
```

Match vehicle strengths to specific delivery zones!

## Decision Framework

```{python}
#| echo: false
#| eval: true

# Create decision flowchart visualization
fig, ax = plt.subplots(figsize=(12, 8))

# Decision steps
steps = [
    'Define Objectives\n(Cost, Emissions, Speed, Flexibility)',
    'Generate Options\n(Fleet combinations)',
    'Find Pareto Frontier\n(Non-dominated fleets)',
    'Apply Preferences\n(Weights or constraints)',
    'Sensitivity Analysis\n(What if weights change?)',
    'Make Decision\n(Choose fleet mix)'
]

y_positions = np.linspace(0.9, 0.1, len(steps))
x_position = 0.5

for i, (step, y_pos) in enumerate(zip(steps, y_positions)):
    # Box for each step
    rect = plt.Rectangle((x_position - 0.15, y_pos - 0.06), 
                         0.3, 0.08, 
                         facecolor='lightblue' if i % 2 == 0 else 'lightgreen',
                         edgecolor='black', linewidth=2)
    ax.add_patch(rect)
    
    # Text
    ax.text(x_position, y_pos - 0.02, step, 
           ha='center', va='center', fontsize=10, fontweight='bold')
    
    # Arrow to next step
    if i < len(steps) - 1:
        ax.arrow(x_position, y_pos - 0.06, 0, -0.04, 
                head_width=0.02, head_length=0.01, fc='black', ec='black')

ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.axis('off')
ax.set_title('Multi-Objective Decision Process', fontsize=16, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()
```

# [Mission Briefing]{.flow} {.title}

## Today's Learning Path

### Hour 3: Practice Notebook 
**Your Role:** Bean Counter CEO
- Learn to evaluate multi-objective trade-offs
- Implement Pareto frontier finding
- Apply weighted sum method
- Make data-driven recommendations

### Hour 4: Transportation & Fleet Competition
**Two Challenges to Master:**

**Part A: Multi-Objective Transportation (30 min)**
- Allocate deliveries between DCs and zones
- Balance cost vs emissions
- Use ε-constraint method
- Find YOUR optimal trade-off point

**Part B: Fleet Selection (30 min)**  
- Select vehicle mix for EcoExpress
- Meet EU emission targets
- Balance 3+ objectives
- Justify your strategic choice

## The Competition Challenge

::: {.callout-important}
## Fleet Selection Competition

**Objective:** Design EcoExpress's sustainable delivery fleet

**Given:**
- Vehicle specifications (5 types with different trade-offs)
- Budget: €3.5M capital investment
- EU mandate: 40% emission reduction
- Service requirements per city

**Deliverable:**
- Fleet composition (quantity per vehicle type)
- Pareto frontier analysis
- Business case with 3-year ROI projection

**Evaluation:** Emissions (35%), Cost-efficiency (35%), Service quality (20%), Innovation (10%)
:::

## Tools You'll Master

::: columns
::: {.column width="50%"}
**Analytical Tools**
- Pareto frontier identification
- Normalization techniques
- Weighted scoring
- Constraint handling
:::

::: {.column width="50%"}
**Visualization Tools**
- Trade-off plots
- Parallel coordinates
- Spider/radar charts
- Decision matrices
:::
:::

## Key Takeaways

::: {.incremental}
1. **Real decisions have multiple objectives** - rarely just "minimize cost"
2. **Pareto frontier** shows all rational choices
3. **Weights reflect values** - make them explicit
4. **No perfect solution** - only good trade-offs
5. **Visualization crucial** for stakeholder buy-in
:::

. . .

[Ready to master the art of trade-offs?]{.highlight}

## Break!

```{python}
#| echo: false
#| eval: true

import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(figsize=(10, 6))

# Create a coffee cup
cup_x = [2, 2, 2.5, 2.5, 3, 3, 3, 2]
cup_y = [3, 5, 5, 4.5, 4.5, 5, 3, 3]
ax.fill(cup_x, cup_y, color='brown', alpha=0.7)

# Add steam with curves
t = np.linspace(0, 4*np.pi, 100)
for i in range(3):
    steam_x = 2.5 + 0.1*np.sin(t) + i*0.15
    steam_y = 5 + t/(2*np.pi) * 0.8
    ax.plot(steam_x, steam_y, color='gray', alpha=0.5, linewidth=2)

# Add trade-off arrows
ax.arrow(4, 4, 1, 0, head_width=0.1, head_length=0.1, fc='green', ec='green')
ax.text(5.5, 4, 'Speed', fontsize=12, ha='center')

ax.arrow(4, 4, 0, 1, head_width=0.1, head_length=0.1, fc='blue', ec='blue')
ax.text(4, 5.5, 'Quality', fontsize=12, ha='center')

ax.arrow(4, 4, -0.7, -0.7, head_width=0.1, head_length=0.1, fc='red', ec='red')
ax.text(3, 3, 'Cost', fontsize=12, ha='center')

ax.text(2.5, 2, "Even coffee involves\ntrade-offs!", 
        fontsize=14, ha='center', style='italic')

ax.set_xlim(1, 6)
ax.set_ylim(1, 6)
ax.axis('off')
plt.tight_layout()
plt.show()
```

[Time to practice multi-objective optimization!]{.flow}
