---
title: "Multi-Objective Optimization"
subtitle: "Lecture 8 - Management Science"
author: "Dr. Tobias Vlƒáek"
format:
  revealjs:
    footer: " {{< meta title >}} | {{< meta author >}} | [Home](lec_08_multi_objective.qmd)"
    output-file: lec_08_presentation.html
---

# [Introduction]{.flow} {.title}

## **[Client Briefing: EcoExpress Logistics]{.invert-font}** {background-image="https://unsplash.com/photos/QqSIuvz94s8/download?ixid=M3wxMjA3fDB8MXxzZWFyY2h8MTF8fHN1c3RhaW5hYmlsaXR5fGVufDB8fHx8MTc2MzE4Nzk0MHww&force=true&w=2400" background-size="cover"}

. . .

[Operations Director's Dilemma:]{.invert-font}

["EU regulations demand 40% emission cuts, but we can't sacrifice [profitability]{.highlight}, [service quality]{.highlight}, or [reliability]{.highlight}!"]{.invert-font .fragment}

## The Fleet Challenge

[EcoExpress operates regional last-mile delivery across 3 cities]{.highlight}

::: incremental
- EU Green Deal: 40% emission reduction by 2025
- Rising fuel costs (‚Ç¨2.1/L diesel)
- Amazon entering our market (speed pressure)
- Driver shortage (need automation-friendly vehicles)
:::

. . .

[Question:]{.question} How do we transform our fleet while staying competitive?

## Quick Recap: Local Search

[Last week we optimized routes for delivery:]{.highlight}

::: {.incremental}
- Started with greedy construction (e.g. Nearest Neighbor)
- Improved with local search (e.g. 2-opt)
- Considered time windows
- **But: We only optimized distance**
:::

. . .

[Question:]{.question} What if we also care about emissions, cost, AND customer satisfaction?

# [The Problem]{.flow} {.title}

## Single vs Multi-Objective

**Single Objective**

- ["Minimize total distance"]{.highlight}
- Clear winner. Easy, right!

. . .

**Multiple Objectives**

- ["Minimize cost AND emissions AND maximize speed"]{.highlight}
- No clear answer...

. . .

[Question:]{.question} Any idea how to approach this?

## EcoExpress Vehicle Options

```{python}
#| echo: false
#| eval: true

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append('../helpers')
from plot_utils import setup_clean_style, BRAND_COLORS, PLOT_COLORS

# Apply consistent brand styling
setup_clean_style()

vehicles = pd.DataFrame({
    'Type': ['E-Truck', 'Hybrid Van', 'Diesel Van', 'E-Cargo Bike', 'Autonomous'],
    'Purchase Cost (‚Ç¨)': [75000, 45000, 35000, 12000, 95000],
    'Operating (‚Ç¨/km)': [0.18, 0.25, 0.38, 0.05, 0.12],
    'CO2 (g/km)': [0, 95, 185, 0, 0],
    'Speed (km/h)': [55, 65, 70, 30, 40],
    'Capacity (parcels)': [300, 200, 250, 50, 150],
    'Range (km)': [250, 600, 800, 60, 180]
})

# Display as nice table
from IPython.display import display, HTML
display(HTML(vehicles.to_html(index=False, classes='table table-striped')))
```
. . .

[Question:]{.question} Which vehicle is "best" for EcoExpress?

## Trade-offs Everywhere

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3)

# Cost vs Emissions
axes[0].scatter(vehicles['Purchase Cost (‚Ç¨)']/1000, 
                vehicles['CO2 (g/km)'], 
                s=vehicles['Capacity (parcels)'],
                alpha=0.7, color=PLOT_COLORS[0])
for i, txt in enumerate(vehicles['Type']):
    axes[0].annotate(txt, (vehicles['Purchase Cost (‚Ç¨)'].iloc[i]/1000, 
                           vehicles['CO2 (g/km)'].iloc[i]),
                    fontsize=9)
axes[0].set_xlabel('Purchase Cost (k‚Ç¨)')
axes[0].set_ylabel('CO2 Emissions (g/km)')
axes[0].set_title('Cost vs Environmental Impact')

# Speed vs Cost
axes[1].scatter(vehicles['Speed (km/h)'], 
                vehicles['Operating (‚Ç¨/km)'],
                s=vehicles['Capacity (parcels)'],
                alpha=0.7, color=PLOT_COLORS[1])
for i, txt in enumerate(vehicles['Type']):
    axes[1].annotate(txt, (vehicles['Speed (km/h)'].iloc[i], 
                           vehicles['Operating (‚Ç¨/km)'].iloc[i]),
                    fontsize=9)
axes[1].set_xlabel('Speed (km/h)')
axes[1].set_ylabel('Operating (‚Ç¨/km)')
axes[1].set_title('Speed vs Operating Cost')

# Capacity vs Range
axes[2].scatter(vehicles['Capacity (parcels)'], 
                vehicles['Range (km)'],
                s=vehicles['Purchase Cost (‚Ç¨)']/300,
                alpha=0.7, color=PLOT_COLORS[2])
for i, txt in enumerate(vehicles['Type']):
    axes[2].annotate(txt, (vehicles['Capacity (parcels)'].iloc[i], 
                           vehicles['Range (km)'].iloc[i]),
                    fontsize=9)
axes[2].set_xlabel('Capacity (parcels)')
axes[2].set_ylabel('Range (km)')
axes[2].set_title('Capacity vs Range')

plt.tight_layout()
plt.show()
```

. . .

::: callout-important
Every vehicle excels at something different!
:::

## Real Business Constraints

[Beyond the numbers, consider:]{.highlight}

::: {.incremental}
- **EU regulations:** Carbon tax of ‚Ç¨100/ton CO‚ÇÇ starting 2025
- **Competition:** Amazon promises 2-hour delivery
- **Labor market:** Autonomous vehicles reduce driver dependency
- **Urban zones:** Zero-emission zones in city centers
- **Peak times:** Black Friday = 3x normal volume
:::

. . .

::: {.callout-important}
There is no single "optimal" solution - only trade-offs
:::

# [Pareto Optimality]{.flow} {.title}

## Dominated Solutions

[A solution is dominated if another solution is:]{.highlight} 

```{python}
#| echo: false
#| eval: true

# Create example data
np.random.seed(42)
n_solutions = 30
cost = np.random.uniform(20, 100, n_solutions)
emissions = 150 - cost + np.random.normal(0, 15, n_solutions)

# Identify Pareto front
pareto_mask = np.ones(n_solutions, dtype=bool)
for i in range(n_solutions):
    for j in range(n_solutions):
        if i != j:
            if cost[j] <= cost[i] and emissions[j] <= emissions[i]:
                if cost[j] < cost[i] or emissions[j] < emissions[i]:
                    pareto_mask[i] = False
                    break

fig, ax = plt.subplots()

# Plot dominated solutions
ax.scatter(cost[~pareto_mask], emissions[~pareto_mask], 
          alpha=0.3, s=100, color=BRAND_COLORS["darker"], label='Dominated')

# Plot Pareto optimal solutions
ax.scatter(cost[pareto_mask], emissions[pareto_mask], 
          alpha=0.8, s=100, color=PLOT_COLORS[1], label='Pareto Optimal')

# Sort Pareto points and draw frontier
pareto_cost = cost[pareto_mask]
pareto_emissions = emissions[pareto_mask]
sorted_idx = np.argsort(pareto_cost)
ax.plot(pareto_cost[sorted_idx], pareto_emissions[sorted_idx], 
        '--', color=PLOT_COLORS[1], alpha=0.5, linewidth=2)

# Highlight one dominated solution
example_idx = np.where(~pareto_mask)[0][5]
ax.scatter(cost[example_idx], emissions[example_idx], 
          s=200, color='red', marker='x', linewidth=3)
ax.annotate('Dominated\n(worse in both)', 
           (cost[example_idx], emissions[example_idx]),
           xytext=(cost[example_idx]+10, emissions[example_idx]+5),
           fontsize=10, ha='center',
           arrowprops=dict(arrowstyle='->', color='red'))

ax.set_xlabel('Cost (‚Ç¨)', fontsize=12)
ax.set_ylabel('CO2 Emissions (g/km)', fontsize=12)
ax.set_title('Pareto Frontier: Non-Dominated Solutions', fontsize=14)
ax.legend()
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

. . .

:::callout-important
Better in at least one objective and not worse in any objective!
:::

## The Pareto Frontier

[The Pareto frontier is the set of all non-dominated solutions]{.highlight}

::: {.incremental}
- No solution is objectively "better"
- Each represents a different trade-off
- Moving along frontier: gain in one objective, loss in another
- Decision makers choose based on **preferences**
:::

. . .

[Question]{.question} Do you think you get the idea?

## Find the Non-Dominated

```{python}
#| echo: false
#| eval: true

# Simple example for interaction - designed to have clear dominance
solutions = pd.DataFrame({
    'Fleet': ['A', 'B', 'C', 'D', 'E'],
    'Cost (k‚Ç¨)': [100, 120, 90, 105, 95],
    'Emissions (tons/year)': [50, 30, 40, 55, 60]
})

# Determine which are dominated
dominated = []
for i in range(len(solutions)):
    for j in range(len(solutions)):
        if i != j:
            # Check if j dominates i
            if (solutions.iloc[j]['Cost (k‚Ç¨)'] <= solutions.iloc[i]['Cost (k‚Ç¨)'] and
                solutions.iloc[j]['Emissions (tons/year)'] <= solutions.iloc[i]['Emissions (tons/year)'] and
                (solutions.iloc[j]['Cost (k‚Ç¨)'] < solutions.iloc[i]['Cost (k‚Ç¨)'] or
                 solutions.iloc[j]['Emissions (tons/year)'] < solutions.iloc[i]['Emissions (tons/year)'])):
                dominated.append(i)
                break

# Color code based on dominance
fig, ax = plt.subplots()
for i, row in solutions.iterrows():
    color = BRAND_COLORS["darker"] if i in dominated else PLOT_COLORS[1]
    alpha = 0.4 if i in dominated else 0.8
    ax.scatter(row['Cost (k‚Ç¨)'], row['Emissions (tons/year)'], 
              s=500, alpha=alpha, color=color, linewidth=2)
    ax.annotate(row['Fleet'], 
               (row['Cost (k‚Ç¨)'], row['Emissions (tons/year)']),
               fontsize=14, ha='center', va='center', fontweight='bold')

ax.set_xlabel('Cost (k‚Ç¨)', fontsize=12)
ax.set_ylabel('Emissions (tons/year)', fontsize=12)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Which fleets are non-dominated?

## Three+ Objectives

[With 3 objectives, the Pareto frontier becomes a surface:]{.highlight}

```{python}
#| echo: false
#| eval: true

from mpl_toolkits.mplot3d import Axes3D

# Generate 3D Pareto example
np.random.seed(123)
n = 100
cost_3d = np.random.uniform(50, 150, n)
emissions_3d = 200 - cost_3d + np.random.normal(0, 20, n)
speed_3d = cost_3d/2 + np.random.normal(0, 10, n)

# Simple Pareto identification (approximate)
pareto_3d = []
for i in range(n):
    dominated = False
    for j in range(n):
        if i != j:
            if (cost_3d[j] <= cost_3d[i] and 
                emissions_3d[j] <= emissions_3d[i] and 
                speed_3d[j] >= speed_3d[i]):
                if (cost_3d[j] < cost_3d[i] or 
                    emissions_3d[j] < emissions_3d[i] or 
                    speed_3d[j] > speed_3d[i]):
                    dominated = True
                    break
    if not dominated:
        pareto_3d.append(i)

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

# Plot all solutions
ax.scatter(cost_3d, emissions_3d, speed_3d, 
          alpha=0.2, s=30, color=BRAND_COLORS["darker"])

# Highlight Pareto solutions
ax.scatter(cost_3d[pareto_3d], emissions_3d[pareto_3d], speed_3d[pareto_3d], 
          alpha=0.8, s=60, color=PLOT_COLORS[1], edgecolors=PLOT_COLORS[1])

ax.set_xlabel('Cost (‚Ç¨)', fontsize=10, labelpad=15)
ax.set_ylabel('Emissions (g/km)', fontsize=10, labelpad=15)
ax.set_zlabel('Speed (km/h)', fontsize=10, labelpad=15)
ax.set_title('3D Pareto Frontier (Surface)', fontsize=14, fontweight='bold', pad=20)
ax.view_init(elev=20, azim=45)

# Fix the cutoff issue
plt.subplots_adjust(left=0, right=1, bottom=0, top=1)
plt.tight_layout()
plt.show()
```

. . .

::: callout-important
Harder to visualize, but same principle applies!
:::

# [Transportation Problem]{.flow} {.title}

## Multi-Objective Transportation

```{python}
#| echo: false
#| eval: true

# Visualize transportation trade-offs
fig, ax = plt.subplots()

# Define routes with their characteristics
routes = {
    'Route A: City Center': {'distance': 50, 'time': 90, 'cost': 80, 'emissions': 120},
    'Route B: Highway': {'distance': 80, 'time': 60, 'cost': 100, 'emissions': 90},
    'Route C: Suburbs': {'distance': 65, 'time': 75, 'cost': 85, 'emissions': 100}
}

# Create parallel coordinates plot
categories = ['Distance\n(km)', 'Time\n(min)', 'Cost\n(‚Ç¨)', 'Emissions\n(kg CO‚ÇÇ)']
n_cats = len(categories)

for i, (route_name, values) in enumerate(routes.items()):
    # Normalize values for plotting
    vals = [values['distance']/80, values['time']/90, 
            values['cost']/100, values['emissions']/120]
    
    x = np.arange(n_cats)
    ax.plot(x, vals, 'o-', linewidth=2.5, markersize=10, 
            label=route_name, color=PLOT_COLORS[i], alpha=0.8)

ax.set_xticks(x)
ax.set_xticklabels(categories)
ax.set_ylabel('Normalized Value', fontsize=11)
ax.legend(loc='best')
ax.grid(True, alpha=0.2)
ax.set_ylim(0, 1.1)

# Add annotations
ax.annotate('Short but slow\n& high emissions', xy=(0, 0.6), 
            xytext=(0, 0.3), fontsize=12, color=PLOT_COLORS[0],
            arrowprops=dict(arrowstyle='->', color=PLOT_COLORS[0], alpha=0.5))
ax.annotate('Fast but long\n& expensive', xy=(1, 0.65), 
            xytext=(1, 0.3), fontsize=12, color=PLOT_COLORS[1],
            arrowprops=dict(arrowstyle='->', color=PLOT_COLORS[1], alpha=0.5))

plt.tight_layout()
plt.show()
```

. . .

::: callout-tip
[Logistics decisions involve trade-offs:]{.highlight} City traffic (slow, high emissions), Night delivery? ‚Üí Highway (fast, but more distance), Customer priority? ‚Üí Direct route (expensive)
:::

## Classic Transportation

[Let's understand the foundation]{.highlight}

. . .

```{python}
#| echo: false
#| eval: true

import pandas as pd
import numpy as np

# Transportation problem data
supply = [300, 250, 200]  # Parcels available
demand = [200, 180, 220, 150]  # Parcels needed

# Create comprehensive table with costs, supply, and demand
transport_table = pd.DataFrame({
    'From/To': ['DC Berlin', 'DC Hamburg', 'DC Munich', 'Demand'],
    'Zone A': [8, 12, 15, demand[0]],
    'Zone B': [10, 9, 13, demand[1]],
    'Zone C': [11, 7, 10, demand[2]],
    'Zone D': [14, 8, 9, demand[3]],
    'Supply': supply + [sum(demand)]
})

display(HTML(transport_table.to_html(index=False, classes='table table-striped')))

# Check if balanced
total_supply = sum(supply)
total_demand = sum(demand)
if total_supply != total_demand:
    print(f"\n‚úó Unbalanced: Supply ({total_supply}) ‚â† Demand ({total_demand})")
```

::: callout-note
Cost per 100 parcels (‚Ç¨) in the middle of the table!
:::

## Objective Function

[The foundation of the classical model]{.highlight}

$$\text{Minimize } Z = \sum_{i} \sum_{j} c_{ij} \cdot x_{ij}$$

Where:

- $x_{ij}$ = parcels shipped from DC $i$ to Zone $j$
- $c_{ij}$ = cost per 100 parcels from $i$ to $j$

## Second Objective: Emissions

[Now the real challenge - each route has different emissions:]{.highlight}

```{python}
#| echo: false
#| eval: true

# Emissions data (designed to conflict with cost structure)
emissions_data = pd.DataFrame({
    'From/To': ['DC Berlin', 'DC Hamburg', 'DC Munich'],
    'Zone A': [120, 45, 60],  # g CO2/parcel - Hamburg is greenest (but expensive)
    'Zone B': [95, 110, 50],   # Munich is greenest for Zone B
    'Zone C': [85, 100, 115],  # Berlin is greenest (but expensive)
    'Zone D': [70, 90, 105]    # Berlin is greenest (but most expensive)
})

display(HTML(emissions_data.to_html(index=False, classes='table table-striped')))
```

::: callout-note
Emissions per parcel (g CO‚ÇÇ) in the table
:::

## Objective Function II

[Now with two objectives!]{.highlight}

$$\text{Minimize } Z_1 = \sum_{i} \sum_{j} c_{ij} \cdot x_{ij} \quad \text{(Cost)}$$
$$\text{Minimize } Z_2 = \sum_{i} \sum_{j} e_{ij} \cdot x_{ij} \quad \text{(Emissions)}$$

Where $e_{ij}$ = emissions per parcel from $i$ to $j$

. . .

[Notice: Cheapest routes ‚â† Greenest routes!]{.highlight}

## Data Source

[Where Do These Numbers Come From?]{.highlight}

. . .

**Cost Data:**

::: incremental
- **Historical records**: Your accounting system
- **Quotes**: Request from carriers/suppliers  
- **APIs**: Google Maps Distance Matrix (distance ‚Üí cost)
:::

. . .

**Emissions Data:**

::: incremental
- **EU Standards or Carrier data**
- **Formula**: `Emissions = Distance √ó Weight √ó EmissionFactor`
:::

## The Transportation Trade-off

```{python}
#| echo: false
#| eval: true

from scipy.optimize import linprog

# Cost and emissions matrices (from our data)
costs = np.array([[8, 10, 11, 14],    # DC Berlin
                  [12, 9, 7, 8],       # DC Hamburg
                  [15, 13, 10, 9]])    # DC Munich

# Updated emissions to create actual trade-off
emissions = np.array([[120, 95, 85, 70],   # DC Berlin (g CO2/parcel)
                      [45, 110, 100, 90],  # DC Hamburg
                      [60, 50, 115, 105]]) # DC Munich

supply = np.array([300, 250, 200])
demand = np.array([200, 180, 220, 150])

# Solve for different weights (0 = cost only, 1 = emissions only)
solutions = []
weights = np.linspace(0, 1, 15)

for w in weights:
    # Combined objective: (1-w)*cost + w*emissions
    # Normalize to make them comparable
    c_combined = (1-w) * costs.flatten() / 10 + w * emissions.flatten() / 100
    
    # Constraints: supply and demand
    A_eq = []
    b_eq = []
    
    # Supply constraints (one per DC)
    for i in range(3):
        constraint = np.zeros(12)
        constraint[i*4:(i+1)*4] = 1
        A_eq.append(constraint)
        b_eq.append(supply[i])
    
    # Demand constraints (one per Zone)
    for j in range(4):
        constraint = np.zeros(12)
        for i in range(3):
            constraint[i*4 + j] = 1
        A_eq.append(constraint)
        b_eq.append(demand[j])
    
    # Solve
    result = linprog(c_combined, A_eq=A_eq, b_eq=b_eq, 
                     bounds=(0, None), method='highs')
    
    if result.success:
        x = result.x.reshape(3, 4)
        total_cost = np.sum(costs * x) * 10  # Cost per 100 parcels
        total_emissions = np.sum(emissions * x) / 1000  # Convert to kg
        solutions.append({'Cost': total_cost, 'Emissions': total_emissions, 'Weight': w})

sol_df = pd.DataFrame(solutions)

fig, ax = plt.subplots()

# Plot Pareto frontier
ax.plot(sol_df['Cost'], sol_df['Emissions'], 
        '-o', linewidth=2.5, markersize=5, color=BRAND_COLORS["darker"], 
        label='Pareto frontier', alpha=0.7)

# Highlight extremes
min_cost = sol_df.iloc[0]
min_emissions = sol_df.iloc[-1]

ax.scatter(min_cost['Cost'], min_cost['Emissions'],
          s=200, color=PLOT_COLORS[2], marker='*', 
          label=f'Min Cost: ‚Ç¨{min_cost["Cost"]:.0f}', 
          edgecolors='black', linewidth=1.5, zorder=5)
ax.scatter(min_emissions['Cost'], min_emissions['Emissions'],
          s=200, color=PLOT_COLORS[0], marker='*', 
          label=f'Min Emissions: {min_emissions["Emissions"]:.1f} kg', 
          edgecolors='black', linewidth=1.5, zorder=5)

# Add a balanced solution
balanced_idx = len(sol_df) // 2
balanced = sol_df.iloc[balanced_idx]
ax.scatter(balanced['Cost'], balanced['Emissions'],
          s=200, color=PLOT_COLORS[1], marker='D', 
          label='Balanced solution', 
          edgecolors='black', linewidth=1.5, zorder=5)

ax.set_xlabel('Total Cost (‚Ç¨)', fontsize=13, fontweight='bold')
ax.set_ylabel('Total CO‚ÇÇ Emissions (kg)', fontsize=13, fontweight='bold')
ax.legend(fontsize=10, loc='best')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Print key insights
print(f"Cost increase for greenest solution: +‚Ç¨{min_emissions['Cost'] - min_cost['Cost']:.0f} ({(min_emissions['Cost']/min_cost['Cost']-1)*100:.1f}%)")
print(f"Emissions reduction from cheapest: -{min_cost['Emissions'] - min_emissions['Emissions']:.1f} kg ({(1-min_emissions['Emissions']/min_cost['Emissions'])*100:.1f}%)")
```

. . .

::: callout-important
Each point represents a different allocation strategy!
:::

# [Solution Methods]{.flow} {.title}

## Extreme Points Analysis

**Always solve single objectives FIRST!** They anchor your entire analysis:

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 2)

# Left plot: Show extreme points
ax1 = axes[0]

# Generate sample Pareto frontier
t = np.linspace(0, 1, 100)
cost_front = 50 + 100 * (1 - t**1.8)
emissions_front = 250 * t**1.8 + 40

# Plot frontier
ax1.plot(cost_front, emissions_front, 'b-', linewidth=2, alpha=0.5, label='Pareto Frontier')

# Mark extreme points
min_cost_idx = np.argmin(cost_front)
min_emissions_idx = np.argmin(emissions_front)

ax1.scatter(cost_front[min_cost_idx], emissions_front[min_emissions_idx], 
           s=300, color=PLOT_COLORS[2], marker='*', label='Min Cost Only',
           edgecolors='black', linewidth=2, zorder=10)
ax1.scatter(cost_front[min_emissions_idx], emissions_front[min_emissions_idx], 
           s=300, color=PLOT_COLORS[0], marker='*', label='Min Emissions Only',
           edgecolors='black', linewidth=2, zorder=10)

# Add ideal point (usually infeasible)
ideal_cost = cost_front.min()
ideal_emissions = emissions_front.min()
ax1.scatter(ideal_cost, ideal_emissions, s=200, color='green', marker='D', 
           label='Ideal (Infeasible)', edgecolors='black', linewidth=2, alpha=0.5)

# Draw box showing trade-off space
ax1.add_patch(plt.Rectangle((ideal_cost, ideal_emissions), 
                           cost_front.max() - ideal_cost,
                           emissions_front.max() - ideal_emissions,
                           fill=False, edgecolor='gray', linestyle='--', linewidth=1))

ax1.set_xlabel('Cost (‚Ç¨)', fontsize=12)
ax1.set_ylabel('Emissions (kg CO‚ÇÇ)', fontsize=12)
ax1.set_title('Step 1: Find Extreme Points', fontsize=13, fontweight='bold')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Right plot: Show normalization ranges
ax2 = axes[1]

# Bar chart showing ranges
objectives = ['Cost', 'Emissions']
mins = [cost_front.min(), emissions_front.min()]
maxs = [cost_front.max(), emissions_front.max()]
ranges = [maxs[i] - mins[i] for i in range(2)]

x = np.arange(len(objectives))
width = 0.35

bars1 = ax2.bar(x - width/2, mins, width, label='Min (Best)', color=PLOT_COLORS[1], alpha=0.7)
bars2 = ax2.bar(x + width/2, maxs, width, label='Max (Worst)', color=PLOT_COLORS[0], alpha=0.7)

# Add range annotations
for i, (min_val, max_val, range_val) in enumerate(zip(mins, maxs, ranges)):
    ax2.annotate(f'Range: {range_val:.0f}', xy=(i, (min_val + max_val)/2),
                xytext=(i + 0.3, (min_val + max_val)/2),
                fontsize=11, ha='left',
                arrowprops=dict(arrowstyle='<->', color='black', lw=2))

ax2.set_ylabel('Value', fontsize=12)
ax2.set_title('Step 2: Use Ranges for Normalization', fontsize=13, fontweight='bold')
ax2.set_xticks(x)
ax2.set_xticklabels(objectives)
ax2.legend()

plt.tight_layout()
plt.show()
```

::: {.callout-important}
## Why Extreme Points Matter

1. **Define the Trade-off Space**: Min/max values bound your Pareto frontier
2. **Enable Proper Normalization**: Need ranges for scaling to [0,1]
3. **Quick Feasibility Check**: If you can't achieve single objectives, problem is infeasible
4. **Stakeholder Communication**: "Best possible cost is ‚Ç¨50k, best emissions is 40kg"
:::

**Implementation Pattern:**
```python
# ALWAYS start with this!
def find_extreme_points(problem):
    """First step in any MOO analysis"""
    
    # Solve for minimum cost (ignore emissions)
    min_cost_solution = minimize(cost_objective, constraints)
    
    # Solve for minimum emissions (ignore cost)
    min_emissions_solution = minimize(emissions_objective, constraints)
    
    # These define your trade-off space!
    return {
        'cost_range': (min_cost_solution.cost, min_emissions_solution.cost),
        'emissions_range': (min_cost_solution.emissions, min_emissions_solution.emissions),
        'ideal_point': (min_cost_solution.cost, min_emissions_solution.emissions),
        'nadir_point': (max_cost, max_emissions)
    }
```

## Why Extreme Points Matter

::: {.callout-important}
## Why Extreme Points Matter

1. **Define the Trade-off Space**: Min/max values bound your Pareto frontier
2. **Enable Proper Normalization**: Need ranges for scaling to [0,1]
3. **Quick Feasibility Check**: If you can't achieve single objectives, problem is infeasible
4. **Stakeholder Communication**: "Best possible cost is ‚Ç¨50k, best emissions is 40kg"
:::

```python
# ALWAYS start with this!
def find_extreme_points(problem):
    """First step in any MOO analysis"""
    
    # Solve for minimum cost (ignore emissions)
    min_cost_solution = minimize(cost_objective, constraints)
    
    # Solve for minimum emissions (ignore cost)
    min_emissions_solution = minimize(emissions_objective, constraints)
    
    # These define your trade-off space!
    return {
        'cost_range': (min_cost_solution.cost, min_emissions_solution.cost),
        'emissions_range': (min_cost_solution.emissions, min_emissions_solution.emissions),
        'ideal_point': (min_cost_solution.cost, min_emissions_solution.emissions),
        'nadir_point': (max_cost, max_emissions)
    }
```

## Method 1: Weighted Sum

Combine all objectives into one score:

$$\text{Score} = w_1 \cdot f_1(\mathbf{x}) + w_2 \cdot f_2(\mathbf{x}) + ... + w_p \cdot f_p(\mathbf{x})$$

**Intuition:** Like mixing ingredients in a recipe - the weights are your preferences!

```python
def weighted_score(solution, w_cost=0.6, w_emissions=0.4):
    # Normalize objectives to [0,1]
    norm_cost = (solution.cost - min_cost) / (max_cost - min_cost)
    norm_emissions = (solution.emissions - min_emissions) / (max_emissions - min_emissions)
    
    # Weighted combination
    return w_cost * norm_cost + w_emissions * norm_emissions
```

::: {.callout-warning}
## Critical Limitation!
Weighted Sum **cannot find** solutions in non-convex regions (the "dips" in the frontier)
:::

## Critical: Normalization Deep Dive

**Why is normalization essential?** Without it, your analysis is meaningless!

```{python}
#| echo: false
#| eval: true

# Demonstrate the normalization problem
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Sample data
cost_vals = np.array([50000, 75000, 100000])  # In euros
emissions_vals = np.array([50, 100, 150])      # In g/km
speed_vals = np.array([40, 55, 70])            # In km/h

objectives = ['Solution A', 'Solution B', 'Solution C']

# Plot 1: Raw values (wrong!)
ax1 = axes[0]
x = np.arange(len(objectives))
width = 0.25
ax1.bar(x - width, cost_vals, width, label='Cost (‚Ç¨)', color=PLOT_COLORS[0])
ax1.bar(x, emissions_vals, width, label='Emissions (g/km)', color=PLOT_COLORS[1])
ax1.bar(x + width, speed_vals, width, label='Speed (km/h)', color=PLOT_COLORS[2])
ax1.set_ylabel('Raw Values')
ax1.set_title('‚ùå WRONG: Different Scales', fontweight='bold')
ax1.set_xticks(x)
ax1.set_xticklabels(objectives)
ax1.legend()
ax1.annotate('Cost dominates everything!', xy=(1, 60000), fontsize=10, color='red')

# Plot 2: Min-Max Normalized [0,1]
ax2 = axes[1]
cost_norm = (cost_vals - cost_vals.min()) / (cost_vals.max() - cost_vals.min())
emissions_norm = (emissions_vals - emissions_vals.min()) / (emissions_vals.max() - emissions_vals.min())
speed_norm = (speed_vals - speed_vals.min()) / (speed_vals.max() - speed_vals.min())

ax2.bar(x - width, cost_norm, width, label='Cost', color=PLOT_COLORS[0])
ax2.bar(x, emissions_norm, width, label='Emissions', color=PLOT_COLORS[1])
ax2.bar(x + width, speed_norm, width, label='Speed', color=PLOT_COLORS[2])
ax2.set_ylabel('Normalized [0,1]')
ax2.set_title('‚úì Min-Max Normalization', fontweight='bold')
ax2.set_xticks(x)
ax2.set_xticklabels(objectives)
ax2.set_ylim(0, 1.2)
ax2.legend()

# Plot 3: Z-Score Standardized
ax3 = axes[2]
cost_std = (cost_vals - cost_vals.mean()) / cost_vals.std()
emissions_std = (emissions_vals - emissions_vals.mean()) / emissions_vals.std()
speed_std = (speed_vals - speed_vals.mean()) / speed_vals.std()

ax3.bar(x - width, cost_std, width, label='Cost', color=PLOT_COLORS[0])
ax3.bar(x, emissions_std, width, label='Emissions', color=PLOT_COLORS[1])
ax3.bar(x + width, speed_std, width, label='Speed', color=PLOT_COLORS[2])
ax3.set_ylabel('Standardized (Œº=0, œÉ=1)')
ax3.set_title('‚úì Z-Score Standardization', fontweight='bold')
ax3.set_xticks(x)
ax3.set_xticklabels(objectives)
ax3.legend()
ax3.axhline(y=0, color='black', linestyle='-', linewidth=0.5)

plt.tight_layout()
plt.show()
```

**The Normalization Formula You Need:**

$$\text{Normalized}_i = \frac{x_i - x_{min}}{x_{max} - x_{min}} \quad \text{(scales to [0,1])}$$

```python
# Always normalize before combining objectives!
def normalize_objectives(data):
    """Transform all objectives to same scale [0,1]"""
    return (data - data.min()) / (data.max() - data.min())

# Now weights actually mean something
weighted_score = w1 * normalize(cost) + w2 * normalize(emissions)
```

## Weighted Sum Visualization

```{python}
#| echo: false
#| eval: true

# Show how different weights lead to different optimal solutions
fig, axes = plt.subplots(1, 3, figsize=(15, 4))

# Regenerate data for this visualization
np.random.seed(42)
n_solutions = 30
cost = np.random.uniform(20, 100, n_solutions)
emissions = 150 - cost + np.random.normal(0, 15, n_solutions)

# Identify Pareto front
pareto_mask = np.ones(n_solutions, dtype=bool)
for i in range(n_solutions):
    for j in range(n_solutions):
        if i != j:
            if cost[j] <= cost[i] and emissions[j] <= emissions[i]:
                if cost[j] < cost[i] or emissions[j] < emissions[i]:
                    pareto_mask[i] = False
                    break

weights_sets = [
    {'cost': 0.9, 'emissions': 0.1},
    {'cost': 0.5, 'emissions': 0.5},
    {'cost': 0.1, 'emissions': 0.9}
]

titles = ['Cost-Focused (90/10)', 'Balanced (50/50)', 'Green-Focused (10/90)']

for idx, (weights, title) in enumerate(zip(weights_sets, titles)):
    ax = axes[idx]
    
    # Normalize and calculate scores
    norm_cost = (cost - cost.min()) / (cost.max() - cost.min())
    norm_emissions = (emissions - emissions.min()) / (emissions.max() - emissions.min())
    scores = weights['cost'] * norm_cost + weights['emissions'] * norm_emissions
    best_idx = np.argmin(scores)  # We want to minimize
    
    # Plot
    ax.scatter(cost, emissions, alpha=0.3, s=50, color=BRAND_COLORS["darker"])
    ax.scatter(cost[pareto_mask], emissions[pareto_mask], 
              alpha=0.6, s=50, color=PLOT_COLORS[1])
    ax.scatter(cost[best_idx], emissions[best_idx], 
              s=200, color=PLOT_COLORS[0], marker='*', edgecolors=PLOT_COLORS[0], linewidth=2)
    
    ax.set_xlabel('Cost (‚Ç¨)')
    ax.set_ylabel('Emissions (g/km)')
    ax.set_title(title)
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

Different weights ‚Üí Different "optimal" solutions!

## Method 2: Œµ-Constraint Method (Epsilon-Constraint)

**The Superior Approach:** Convert all objectives except one into constraints

**Mathematical Formulation:**
$$\text{Minimize } f_1(\mathbf{x})$$
$$\text{Subject to: } f_2(\mathbf{x}) \leq \epsilon_2$$
$$\quad\quad\quad\quad\quad f_3(\mathbf{x}) \leq \epsilon_3$$

**Intuition:** "Give me the cheapest option that emits less than 100 tons CO‚ÇÇ"

```python
def epsilon_constraint(max_emissions):
    """Find minimum cost solution with emission constraint"""
    feasible = [s for s in all_solutions 
                if s.emissions <= max_emissions]
    
    if feasible:
        return min(feasible, key=lambda s: s.cost)
    return None

# Generate Pareto frontier by varying epsilon
pareto_solutions = []
for epsilon in range(50, 200, 5):  # Vary emission limit
    solution = epsilon_constraint(epsilon)
    if solution:
        pareto_solutions.append(solution)
```

::: {.callout-tip}
## Why Œµ-Constraint Wins
‚úÖ Finds ALL Pareto solutions (including non-convex)  
‚úÖ Works with integer problems  
‚úÖ Easy to understand: "best X given limit on Y"
:::

## Step-by-Step: Œµ-Constraint Algorithm

**Follow this recipe to implement Œµ-constraint:**

```{python}
#| echo: false
#| eval: true

# Visual algorithm flowchart
fig, ax = plt.subplots(figsize=(12, 8))
ax.axis('off')

# Define the steps with positions
steps = [
    {'text': 'Step 1: Choose Primary\nObjective to Minimize\n(e.g., Cost)', 
     'pos': (0.2, 0.85), 'color': PLOT_COLORS[0]},
    {'text': 'Step 2: Find Range for\nSecondary Objectives\nMin(Emissions) to Max(Emissions)', 
     'pos': (0.5, 0.85), 'color': PLOT_COLORS[1]},
    {'text': 'Step 3: Create Œµ Grid\nŒµ = [50, 60, 70, ..., 200]', 
     'pos': (0.8, 0.85), 'color': PLOT_COLORS[2]},
    {'text': 'Step 4: For Each Œµ:\nMin Cost\ns.t. Emissions ‚â§ Œµ', 
     'pos': (0.2, 0.5), 'color': PLOT_COLORS[0]},
    {'text': 'Step 5: Solve & Store\nEach Solution', 
     'pos': (0.5, 0.5), 'color': PLOT_COLORS[1]},
    {'text': 'Step 6: Filter for\nNon-Dominated\n(Remove redundant)', 
     'pos': (0.8, 0.5), 'color': PLOT_COLORS[2]},
    {'text': 'Result: Complete\nPareto Frontier!', 
     'pos': (0.5, 0.15), 'color': BRAND_COLORS["darker"]},
]

# Draw step boxes
for i, step in enumerate(steps):
    if i == len(steps) - 1:  # Final result
        bbox = dict(boxstyle="round,pad=0.5", facecolor='lightgreen', alpha=0.3, 
                   edgecolor='black', linewidth=3)
    else:
        bbox = dict(boxstyle="round,pad=0.3", facecolor=step['color'], alpha=0.2,
                   edgecolor='black', linewidth=2)
    
    ax.text(step['pos'][0], step['pos'][1], step['text'],
           ha='center', va='center', fontsize=10, fontweight='bold', bbox=bbox)

# Draw arrows between steps
arrow_pairs = [(0,1), (1,2), (2,3), (3,4), (4,5), (5,6)]
for start, end in arrow_pairs:
    if end < 6:
        ax.annotate('', xy=steps[end]['pos'], xytext=steps[start]['pos'],
                   arrowprops=dict(arrowstyle='->', lw=2, color=BRAND_COLORS["darker"]))

ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.set_title('Œµ-Constraint Method: Step-by-Step Implementation', 
            fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()
```

**Python Implementation You Can Use:**

```python
def epsilon_constraint_method(cost_func, emissions_func, constraints, epsilon_grid):
    """
    Complete Œµ-constraint implementation
    
    Args:
        cost_func: Function to calculate cost
        emissions_func: Function to calculate emissions
        constraints: Problem constraints
        epsilon_grid: List of epsilon values to test
    
    Returns:
        List of Pareto optimal solutions
    """
    pareto_solutions = []
    
    for epsilon in epsilon_grid:
        # Add emission constraint to existing constraints
        current_constraints = constraints + [emissions_func <= epsilon]
        
        # Solve single-objective problem
        solution = minimize(cost_func, constraints=current_constraints)
        
        if solution.is_feasible():
            pareto_solutions.append({
                'solution': solution,
                'cost': cost_func(solution),
                'emissions': emissions_func(solution),
                'epsilon_used': epsilon
            })
    
    # Filter for non-dominated
    return filter_dominated(pareto_solutions)

# Example usage:
epsilon_values = np.linspace(50, 200, 20)  # 20 epsilon values
pareto_front = epsilon_constraint_method(
    cost_func=calculate_total_cost,
    emissions_func=calculate_total_emissions,
    constraints=supply_demand_constraints,
    epsilon_grid=epsilon_values
)
```

## Visualizing the Difference: WSM vs Œµ-Constraint

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Create a non-convex frontier for demonstration
np.random.seed(123)
x = np.linspace(50, 150, 100)

# Create non-convex shape (with a dip)
y1 = 200 - 1.5*x + 20*np.sin(x/10)
y2 = 180 - 1.2*x + 15*np.sin(x/8)
y_frontier = np.minimum(y1, y2)

# Add some noise for realism
y_frontier += np.random.normal(0, 2, len(x))

# Left plot: Weighted Sum Method
ax1 = axes[0]
ax1.scatter(x, y_frontier, s=20, alpha=0.5, color='gray')

# Show what WSM can find (only convex hull)
from scipy.spatial import ConvexHull
points = np.column_stack([x, y_frontier])
hull = ConvexHull(points)
hull_points = points[hull.vertices]
hull_points = hull_points[np.argsort(hull_points[:, 0])]

ax1.plot(hull_points[:, 0], hull_points[:, 1], 'b-', linewidth=3, 
         label='WSM can find these', alpha=0.7)
ax1.fill_between(x, y_frontier, 250, where=(y_frontier < np.interp(x, hull_points[:, 0], hull_points[:, 1])),
                  color='red', alpha=0.3, label='WSM misses these!')

ax1.set_xlabel('Cost (‚Ç¨)', fontsize=11)
ax1.set_ylabel('Emissions (kg CO‚ÇÇ)', fontsize=11)
ax1.set_title('Weighted Sum Method Limitation', fontsize=12, fontweight='bold')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Right plot: Epsilon-Constraint Method
ax2 = axes[1]
ax2.scatter(x, y_frontier, s=20, alpha=0.5, color='gray')

# Show epsilon constraint lines
epsilon_values = [60, 80, 100, 120, 140]
colors = plt.cm.viridis(np.linspace(0.2, 0.8, len(epsilon_values)))

for eps, color in zip(epsilon_values, colors):
    ax2.axhline(y=eps, color=color, linestyle='--', alpha=0.5)
    # Find optimal point for this epsilon
    valid_idx = y_frontier <= eps
    if np.any(valid_idx):
        min_cost_idx = np.argmin(x[valid_idx])
        optimal_x = x[valid_idx][min_cost_idx]
        optimal_y = y_frontier[valid_idx][min_cost_idx]
        ax2.scatter(optimal_x, optimal_y, s=100, color=color, 
                   edgecolors='black', linewidth=2, zorder=10)

ax2.plot(x, y_frontier, 'g-', linewidth=3, 
         label='Œµ-Constraint finds ALL', alpha=0.7)

ax2.set_xlabel('Cost (‚Ç¨)', fontsize=11)
ax2.set_ylabel('Emissions (kg CO‚ÇÇ)', fontsize=11)
ax2.set_title('Œµ-Constraint Method Success', fontsize=12, fontweight='bold')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.suptitle('Why Œµ-Constraint > Weighted Sum for Non-Convex Problems', 
             fontsize=14, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()
```

[The red "dip" contains valid solutions that weighted sum will never find!]{.highlight}

## Method 3: Goal Programming

Set targets for each objective, minimize deviations:

$$\text{Minimize: } \sum_{i} w_i \cdot |value_i - target_i|$$

Example targets:
- Cost: 80k‚Ç¨ target
- Emissions: 50 g/km target
- Speed: 50 km/h target

Find solution closest to **all** targets

## Computational Complexity Reality Check

**How hard does it get with more objectives?**

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Left: Pareto front complexity growth
ax1 = axes[0]
n_objectives = np.array([2, 3, 4, 5])
pareto_points = np.array([100, 1000, 10000, 100000])  # Exponential growth

ax1.semilogy(n_objectives, pareto_points, 'o-', linewidth=3, 
             markersize=12, color=PLOT_COLORS[0])
ax1.set_xlabel('Number of Objectives', fontsize=12)
ax1.set_ylabel('Typical Pareto Points (log scale)', fontsize=12)
ax1.set_title('Complexity Explosion', fontsize=14, fontweight='bold')
ax1.grid(True, alpha=0.3)

# Add annotations
for i, (n, p) in enumerate(zip(n_objectives, pareto_points)):
    if n == 2:
        ax1.annotate('Manageable\n(curve)', xy=(n, p), xytext=(n-0.3, p*3),
                    fontsize=10, ha='center', color=PLOT_COLORS[1])
    elif n == 3:
        ax1.annotate('Challenging\n(surface)', xy=(n, p), xytext=(n, p*3),
                    fontsize=10, ha='center', color=PLOT_COLORS[2])
    elif n >= 4:
        ax1.annotate('Very Hard!\n(hypersurface)', xy=(n, p), xytext=(n+0.3, p*0.3),
                    fontsize=10, ha='center', color='red')

# Right: Visualization difficulty
ax2 = axes[1]
categories = ['2 Objectives', '3 Objectives', '4+ Objectives']
difficulty = [20, 60, 95]
colors = [PLOT_COLORS[1], PLOT_COLORS[2], 'red']

bars = ax2.bar(categories, difficulty, color=colors, alpha=0.7)
ax2.set_ylabel('Difficulty Level (%)', fontsize=12)
ax2.set_title('Why Industry Uses 2-3 Objectives Max', fontsize=14, fontweight='bold')
ax2.set_ylim(0, 100)

# Add text on bars
for bar, diff in zip(bars, difficulty):
    height = bar.get_height()
    label = 'Easy' if diff < 30 else 'Hard' if diff < 70 else 'Expert Only!'
    ax2.text(bar.get_x() + bar.get_width()/2., height + 2,
            label, ha='center', fontsize=11, fontweight='bold')

plt.tight_layout()
plt.show()
```

::: {.callout-tip}
## Industry Best Practice
- **2 objectives:** Standard (cost vs quality)
- **3 objectives:** Advanced (add sustainability)
- **4+ objectives:** Research territory ("many-objective optimization")

**Pro tip:** Combine related objectives (e.g., combine different costs into "total cost")
:::

## Which Method Should You Use? Decision Tree

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots(figsize=(14, 8))
ax.axis('off')

# Define decision tree structure
decisions = {
    'root': {'text': 'START:\nMulti-Objective\nProblem', 'pos': (0.5, 0.9), 'color': BRAND_COLORS["darker"]},
    'q1': {'text': 'Integer/Discrete\nVariables?', 'pos': (0.5, 0.75), 'color': PLOT_COLORS[2]},
    'q2_yes': {'text': 'Non-convex\nSuspected?', 'pos': (0.3, 0.55), 'color': PLOT_COLORS[2]},
    'q2_no': {'text': 'Have Specific\nTargets?', 'pos': (0.7, 0.55), 'color': PLOT_COLORS[2]},
    'a1': {'text': 'Use Œµ-Constraint\n‚úì Handles non-convex\n‚úì Works with integers', 'pos': (0.15, 0.3), 'color': PLOT_COLORS[1]},
    'a2': {'text': 'Try Weighted Sum\nThen Œµ-Constraint\nif gaps found', 'pos': (0.45, 0.3), 'color': PLOT_COLORS[1]},
    'a3': {'text': 'Use Goal Programming\n‚úì Satisficing approach\n‚úì Handles targets', 'pos': (0.7, 0.3), 'color': PLOT_COLORS[0]},
    'a4': {'text': 'Use Weighted Sum\n‚úì Simple & fast\n‚úì Good for continuous', 'pos': (0.9, 0.3), 'color': PLOT_COLORS[1]},
}

# Draw nodes
for key, node in decisions.items():
    if key.startswith('a'):  # Answer nodes
        bbox = dict(boxstyle="round,pad=0.3", facecolor=node['color'], alpha=0.3, edgecolor='black', linewidth=2)
    elif key == 'root':
        bbox = dict(boxstyle="round,pad=0.3", facecolor='lightgray', alpha=0.5, edgecolor='black', linewidth=3)
    else:  # Question nodes
        bbox = dict(boxstyle="round,pad=0.3", facecolor=node['color'], alpha=0.2, edgecolor='black', linewidth=1)
    
    ax.text(node['pos'][0], node['pos'][1], node['text'], 
           ha='center', va='center', fontsize=10, fontweight='bold', bbox=bbox)

# Draw arrows
arrows = [
    ('root', 'q1', ''),
    ('q1', 'q2_yes', 'YES'),
    ('q1', 'q2_no', 'NO'),
    ('q2_yes', 'a1', 'YES'),
    ('q2_yes', 'a2', 'NO'),
    ('q2_no', 'a3', 'YES'),
    ('q2_no', 'a4', 'NO'),
]

for start, end, label in arrows:
    start_pos = decisions[start]['pos']
    end_pos = decisions[end]['pos']
    
    ax.annotate('', xy=end_pos, xytext=start_pos,
                arrowprops=dict(arrowstyle='->', lw=2, color=BRAND_COLORS["darker"]))
    
    if label:
        mid_x = (start_pos[0] + end_pos[0]) / 2
        mid_y = (start_pos[1] + end_pos[1]) / 2
        ax.text(mid_x, mid_y, label, fontsize=9, fontweight='bold', 
               bbox=dict(boxstyle="round,pad=0.2", facecolor='white', alpha=0.8))

ax.set_xlim(-0.05, 1.05)
ax.set_ylim(0, 1)
ax.set_title('Method Selection Decision Tree', fontsize=16, fontweight='bold', pad=20)

# Add quick reference at bottom
reference_text = "Quick Rules: Integer problems ‚Üí Œµ-constraint | Specific targets ‚Üí Goal Programming | Simple continuous ‚Üí Try Weighted Sum first"
ax.text(0.5, 0.05, reference_text, ha='center', fontsize=10, 
       style='italic', bbox=dict(boxstyle="round,pad=0.3", facecolor='lightyellow', alpha=0.5))

plt.tight_layout()
plt.show()
```

## Quick Check 2: Which Method to Use? ü§î

::: {.callout-note}
## Poll Question 2: Method Selection

Your transportation problem has:
- 12 distribution centers (integer assignment)
- Cost and emissions objectives
- Suspected non-convex frontier

Which method should you use?

A) Weighted Sum (simple and fast)  
B) Œµ-Constraint (handles complexity)  
C) Goal Programming (have targets)

[Think before revealing...]{.fragment}

[**Answer: B) Œµ-Constraint!**]{.fragment .highlight}
- [Integer variables ‚Üí Non-convex likely]{.fragment}
- [Œµ-Constraint finds ALL solutions]{.fragment}
- [Weighted sum would miss solutions!]{.fragment}
:::

# [Construction & Improvement]{.flow} {.title}

## Construction Methods for MOO

**How to build initial solutions when you have multiple objectives?**

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Method 1: Weighted Greedy
ax1 = axes[0]
np.random.seed(42)
n_points = 15

# Simulate greedy solutions with different weight biases
cost_greedy = np.random.uniform(60, 140, n_points)
emissions_greedy = 250 - 1.5*cost_greedy + np.random.normal(0, 10, n_points)

ax1.scatter(cost_greedy[:5], emissions_greedy[:5], s=100, 
           color=PLOT_COLORS[0], alpha=0.7, label='Cost-focused greedy')
ax1.scatter(cost_greedy[5:10], emissions_greedy[5:10], s=100, 
           color=PLOT_COLORS[1], alpha=0.7, label='Emission-focused greedy')
ax1.scatter(cost_greedy[10:], emissions_greedy[10:], s=100, 
           color=PLOT_COLORS[2], alpha=0.7, label='Balanced greedy')

ax1.set_xlabel('Cost (‚Ç¨)', fontsize=10)
ax1.set_ylabel('Emissions (kg CO‚ÇÇ)', fontsize=10)
ax1.set_title('Method 1: Weighted Greedy', fontsize=11, fontweight='bold')
ax1.legend(fontsize=9)
ax1.grid(True, alpha=0.3)

# Method 2: Sequential Objectives
ax2 = axes[1]
# Show progression
stages = ['Stage 1:\nOptimize Cost', 'Stage 2:\nFix Cost,\nOptimize Emissions', 'Stage 3:\nLocal adjustments']
y_pos = np.arange(len(stages))
colors_seq = [PLOT_COLORS[0], PLOT_COLORS[1], PLOT_COLORS[2]]

bars = ax2.barh(y_pos, [100, 70, 85], color=colors_seq, alpha=0.7)
ax2.set_yticks(y_pos)
ax2.set_yticklabels(stages)
ax2.set_xlabel('Solution Quality (%)', fontsize=10)
ax2.set_title('Method 2: Sequential Construction', fontsize=11, fontweight='bold')

# Method 3: Random + Filter
ax3 = axes[2]
# Generate random solutions
random_cost = np.random.uniform(50, 150, 50)
random_emissions = np.random.uniform(50, 250, 50)

# Mark dominated
dominated_mask = np.random.choice([True, False], 50, p=[0.7, 0.3])
ax3.scatter(random_cost[dominated_mask], random_emissions[dominated_mask], 
           s=30, alpha=0.3, color='gray', label='Dominated')
ax3.scatter(random_cost[~dominated_mask], random_emissions[~dominated_mask], 
           s=80, alpha=0.7, color=PLOT_COLORS[1], label='Non-dominated')

ax3.set_xlabel('Cost (‚Ç¨)', fontsize=10)
ax3.set_ylabel('Emissions (kg CO‚ÇÇ)', fontsize=10)
ax3.set_title('Method 3: Generate & Filter', fontsize=11, fontweight='bold')
ax3.legend(fontsize=9)
ax3.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

**Implementation Strategies:**

```python
# Strategy 1: Weighted Greedy Construction
def construct_weighted_greedy(weights):
    """Build solution using weighted objective"""
    solution = []
    while not complete:
        next_choice = min(options, 
            key=lambda x: weights[0]*cost(x) + weights[1]*emissions(x))
        solution.append(next_choice)
    return solution

# Strategy 2: Lexicographic Construction  
def construct_sequential():
    """Optimize objectives one at a time"""
    # First: minimize primary objective
    solution = optimize_single(primary_obj)
    # Then: improve secondary without hurting primary much
    solution = refine_secondary(solution, tolerance=0.1)
    return solution

# Strategy 3: Multiple Random Starts
def construct_diverse_pool(n_solutions=100):
    """Generate many, keep non-dominated"""
    pool = [random_solution() for _ in range(n_solutions)]
    return filter_dominated(pool)
```

## Local Search for Multi-Objective

**Special moves that improve multiple objectives:**

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots(figsize=(12, 7))

# Current solution
current_cost = 100
current_emissions = 150
ax.scatter(current_cost, current_emissions, s=300, color='black', 
          marker='*', label='Current Solution', zorder=10)

# Show different move types
moves = [
    {'name': 'Trade-off Move', 'dcost': 20, 'demissions': -30, 'color': PLOT_COLORS[0]},
    {'name': 'Win-Win Move', 'dcost': -10, 'demissions': -20, 'color': 'green'},
    {'name': 'Cost Move', 'dcost': -15, 'demissions': 5, 'color': PLOT_COLORS[1]},
    {'name': 'Green Move', 'dcost': 5, 'demissions': -25, 'color': PLOT_COLORS[2]},
    {'name': 'Bad Move', 'dcost': 15, 'demissions': 20, 'color': 'red', 'style': '--'}
]

for move in moves:
    new_cost = current_cost + move['dcost']
    new_emissions = current_emissions + move['demissions']
    style = move.get('style', '-')
    
    # Draw arrow
    ax.annotate('', xy=(new_cost, new_emissions), 
                xytext=(current_cost, current_emissions),
                arrowprops=dict(arrowstyle='->', color=move['color'], 
                              lw=2, linestyle=style, alpha=0.7))
    
    # Add label
    ax.scatter(new_cost, new_emissions, s=150, color=move['color'], 
              alpha=0.6, edgecolors='black')
    ax.text(new_cost, new_emissions-8, move['name'], 
           fontsize=9, ha='center', fontweight='bold')

# Add acceptance regions
circle_accept = plt.Circle((current_cost, current_emissions), 35, 
                           color='green', fill=False, linestyle=':', 
                           linewidth=2, alpha=0.3, label='Acceptable region')
ax.add_patch(circle_accept)

ax.set_xlabel('Cost (‚Ç¨)', fontsize=12)
ax.set_ylabel('Emissions (kg CO‚ÇÇ)', fontsize=12)
ax.set_title('Multi-Objective Local Search: Not All Moves Are Equal!', 
            fontsize=14, fontweight='bold')
ax.legend()
ax.grid(True, alpha=0.3)
ax.set_xlim(70, 130)
ax.set_ylim(110, 190)

plt.tight_layout()
plt.show()
```

::: {.callout-tip}
## MOO Local Search Rules

**Accept a move if:**
1. **Dominance**: New solution dominates current (win-win!)
2. **Trade-off**: Improves primary objective, acceptable loss in secondary
3. **Diversity**: Fills gap in current Pareto front
4. **Probabilistic**: Use temperature (like simulated annealing)

**Special MOO Moves:**
- **2-opt for routes**: Consider both distance AND time windows
- **Swap for assignments**: Evaluate cost AND workload balance  
- **Relocate**: Move considering capacity AND emissions
:::

```python
def multi_objective_local_search(solution, objectives):
    """Local search considering multiple objectives"""
    
    current_values = evaluate_all(solution, objectives)
    improved = True
    
    while improved:
        improved = False
        neighbors = generate_neighbors(solution)
        
        for neighbor in neighbors:
            neighbor_values = evaluate_all(neighbor, objectives)
            
            # Accept if dominates or good trade-off
            if dominates(neighbor_values, current_values):
                solution = neighbor
                current_values = neighbor_values
                improved = True
                break
            elif acceptable_tradeoff(neighbor_values, current_values):
                # Probabilistic acceptance for diversity
                if random.random() < acceptance_probability():
                    solution = neighbor
                    current_values = neighbor_values
                    improved = True
                    break
    
    return solution
```

## How Weighted Sum "Slides" Along the Frontier

```{python}
#| echo: false
#| eval: true

# Animated-style visualization showing weighted sum movement
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Generate smooth Pareto frontier
t = np.linspace(0, 1, 100)
pareto_cost = 50 + 100 * (1 - t**1.5)
pareto_emissions = 200 * t**1.5 + 50

# Different weight scenarios
weight_scenarios = [
    (0.9, 0.1, 'Cost Focus (90/10)'),
    (0.5, 0.5, 'Balanced (50/50)'),
    (0.1, 0.9, 'Green Focus (10/90)')
]

for idx, (w_cost, w_emissions, title) in enumerate(weight_scenarios):
    ax = axes[idx]
    
    # Plot Pareto frontier
    ax.plot(pareto_cost, pareto_emissions, 'b-', linewidth=2, alpha=0.5, label='Pareto Frontier')
    
    # Normalize for weighted sum
    norm_cost = (pareto_cost - pareto_cost.min()) / (pareto_cost.max() - pareto_cost.min())
    norm_emissions = (pareto_emissions - pareto_emissions.min()) / (pareto_emissions.max() - pareto_emissions.min())
    
    # Calculate weighted scores
    weighted_scores = w_cost * norm_cost + w_emissions * norm_emissions
    
    # Find optimal point
    optimal_idx = np.argmin(weighted_scores)
    
    # Plot optimal point
    ax.scatter(pareto_cost[optimal_idx], pareto_emissions[optimal_idx], 
              s=200, color=PLOT_COLORS[0], marker='*', edgecolors='black', 
              linewidth=2, zorder=10, label='Selected')
    
    # Draw contour lines (iso-score lines)
    for score_level in np.linspace(weighted_scores.min(), weighted_scores.max(), 5):
        # For visualization: show lines of equal weighted score
        # These are perpendicular to the weight vector
        x_range = np.array([pareto_cost.min(), pareto_cost.max()])
        # This is simplified for visualization
        y_from_score = pareto_emissions.min() + (pareto_emissions.max() - pareto_emissions.min()) * \
                      (score_level - w_cost * np.linspace(0, 1, 2)) / w_emissions
        ax.plot(x_range, y_from_score, '--', alpha=0.2, color='gray')
    
    # Annotations
    ax.set_xlabel('Cost (‚Ç¨)', fontsize=10)
    ax.set_ylabel('Emissions (kg CO‚ÇÇ)', fontsize=10)
    ax.set_title(title, fontsize=11, fontweight='bold')
    ax.grid(True, alpha=0.2)
    ax.legend(fontsize=9)
    
    # Add weight vector visualization
    vector_scale = 30
    ax.arrow(pareto_cost[optimal_idx], pareto_emissions[optimal_idx],
            -w_cost * vector_scale, -w_emissions * vector_scale,
            head_width=3, head_length=2, fc=PLOT_COLORS[2], ec=PLOT_COLORS[2],
            alpha=0.7, linewidth=2)
    ax.text(pareto_cost[optimal_idx] - w_cost * vector_scale/2, 
           pareto_emissions[optimal_idx] - w_emissions * vector_scale/2,
           'Weight\nDirection', fontsize=8, ha='center', 
           bbox=dict(boxstyle="round,pad=0.3", facecolor='white', alpha=0.7))

plt.suptitle('Weighted Sum Method: Different Weights = Different Solutions', 
            fontsize=14, fontweight='bold', y=1.02)
plt.tight_layout()
plt.show()
```

[The weight vector determines which point on the frontier is selected!]{.highlight}

## Interactive Weighting

```{python}
#| echo: false
#| eval: true

# Create interactive-style visualization showing weight impact
fig, ax = plt.subplots(figsize=(10, 6))

# Generate fleet combinations
np.random.seed(456)
n_fleets = 20
fleet_cost = np.random.uniform(60, 140, n_fleets)
fleet_emissions = 180 - fleet_cost + np.random.normal(0, 15, n_fleets)

# Normalize for scoring
norm_cost = (fleet_cost - fleet_cost.min()) / (fleet_cost.max() - fleet_cost.min())
norm_emissions = (fleet_emissions - fleet_emissions.min()) / (fleet_emissions.max() - fleet_emissions.min())

# Show three different weight scenarios
weight_scenarios = [
    (0.9, 0.1, 'Business Focus'),
    (0.5, 0.5, 'Balanced'),
    (0.1, 0.9, 'Environmental Focus')
]

colors = ['red', 'orange', 'green']
for (w_cost, w_emissions, label), color in zip(weight_scenarios, colors):
    scores = (1-w_cost) * norm_cost + (1-w_emissions) * norm_emissions
    best = np.argmax(scores)
    ax.scatter(fleet_cost[best], fleet_emissions[best], 
              s=300, color=color, alpha=0.6, label=label,
              edgecolors='black', linewidth=2)

# Plot all options
ax.scatter(fleet_cost, fleet_emissions, alpha=0.2, s=50, color='gray')

ax.set_xlabel('Total Fleet Cost (k‚Ç¨)', fontsize=12)
ax.set_ylabel('Annual Emissions (tons CO2)', fontsize=12)
ax.set_title('Different Priorities ‚Üí Different Optimal Fleets', fontsize=14)
ax.legend()
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

[Your weights reflect your values!]{.highlight}

## From Pareto Front to Decision

**You have the Pareto front - now what?** How do you choose ONE solution?

### Method 1: The Knee Point
Find the "elbow" where improvement slows dramatically:

```{python}
#| echo: false
#| eval: true

# Demonstrate knee point finding
fig, ax = plt.subplots(figsize=(10, 6))

# Create a Pareto frontier with clear knee
t = np.linspace(0, 1, 50)
cost = 50 + 100 * (1 - t**2)
emissions = 200 * t**2 + 50

# Plot frontier
ax.plot(cost, emissions, 'b-', linewidth=2, label='Pareto Frontier')
ax.scatter(cost, emissions, s=20, alpha=0.5, color=BRAND_COLORS["darker"])

# Identify knee point (roughly where curvature is maximum)
knee_idx = 20  # Approximate knee location
ax.scatter(cost[knee_idx], emissions[knee_idx], s=300, color=PLOT_COLORS[0], 
          marker='*', label='Knee Point', edgecolors='black', linewidth=2, zorder=10)

# Add annotations
ax.annotate('Small cost increase ‚Üí\nLarge emission reduction', 
           xy=(cost[knee_idx-5], emissions[knee_idx-5]),
           xytext=(cost[knee_idx-5]+20, emissions[knee_idx-5]+20),
           arrowprops=dict(arrowstyle='->', color=PLOT_COLORS[1]),
           fontsize=10, ha='center')

ax.annotate('Large cost increase ‚Üí\nSmall emission reduction', 
           xy=(cost[knee_idx+10], emissions[knee_idx+10]),
           xytext=(cost[knee_idx+10]+15, emissions[knee_idx+10]-30),
           arrowprops=dict(arrowstyle='->', color=PLOT_COLORS[2]),
           fontsize=10, ha='center')

ax.set_xlabel('Cost (‚Ç¨)', fontsize=12)
ax.set_ylabel('Emissions (kg CO‚ÇÇ)', fontsize=12)
ax.set_title('The Knee Point: Best "Bang for Buck"', fontsize=14, fontweight='bold')
ax.legend()
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

### Method 2: Satisficing Levels
Set minimum acceptable thresholds:

- Cost must be < ‚Ç¨100k (budget constraint)
- Emissions must be < 100 kg (regulatory limit)
- Service level must be > 90% (customer requirement)

### Method 3: Stakeholder Preferences
Let business priorities guide the choice:

- **CFO Priority:** Minimum cost from acceptable solutions
- **Sustainability Officer:** Minimum emissions that meets other constraints
- **Operations Manager:** Maximum service level within budget

## Common Pitfalls to Avoid

::: {.callout-warning}
## The Top 5 Mistakes Students Make

**‚ùå Mistake 1: Forgetting to Normalize**
```python
# WRONG - Cost dominates due to scale
score = 0.5 * cost_in_euros + 0.5 * emissions_in_grams
```
**‚úì Fix:** Always normalize to [0,1] first!

**‚ùå Mistake 2: Using Weighted Sum for Integer Problems**
- Weighted sum misses solutions in non-convex regions
- Integer problems often create non-convex frontiers

**‚úì Fix:** Use Œµ-constraint for discrete variables

**‚ùå Mistake 3: Assuming Equal Weights = Equal Importance**
```python
# WRONG - Ignores scale differences
w1 = 0.5  # for cost ranging 0-1000
w2 = 0.5  # for emissions ranging 0-10
```
**‚úì Fix:** Normalize first, THEN apply weights

**‚ùå Mistake 4: Optimizing Too Many Objectives**
- 2-3 objectives: Manageable
- 4+ objectives: Exponentially harder

**‚úì Fix:** Combine related objectives or use constraints

**‚ùå Mistake 5: Not Checking Solution Feasibility**
- Pareto optimal ‚â† Feasible for your constraints

**‚úì Fix:** Always verify constraints after optimization
:::

# [Case Studies]{.flow} {.title}

## Amazon's Speed vs Sustainability Dilemma

**The Three-Way Trade-off:**
1. **Minimize Delivery Time** (1-day/2-hour promise)
2. **Minimize Cost** (fuel, labor, fulfillment)
3. **Minimize Environmental Impact** (carbon footprint)

```{python}
#| echo: false
#| eval: true

# Amazon's trade-off visualization
fig, ax = plt.subplots(figsize=(10, 6))

# Create data points representing different strategies
strategies = {
    'Standard (3-5 days)': {'speed': 20, 'cost': 30, 'emissions': 25},
    '2-Day Prime': {'speed': 50, 'cost': 45, 'emissions': 40},
    '1-Day Prime': {'speed': 80, 'cost': 70, 'emissions': 75},
    'Same Day': {'speed': 95, 'cost': 90, 'emissions': 95}
}

for name, values in strategies.items():
    size = 500 - values['emissions']*3  # Bigger = greener
    ax.scatter(values['cost'], values['speed'], s=size, alpha=0.6, label=name)
    ax.annotate(f"{values['emissions']}g CO‚ÇÇ", 
                (values['cost'], values['speed']),
                fontsize=9, ha='center')

ax.set_xlabel('Cost Index', fontsize=12)
ax.set_ylabel('Speed Index', fontsize=12)
ax.set_title("Amazon's Delivery Options: The Hidden Trade-off", fontsize=14)
ax.legend(title='Delivery Option')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

[Faster delivery = More vehicles dispatched less full = Higher emissions]{.highlight}

## Airlines: The Cost Index Solution

Airlines solve this **in real-time** using the **Cost Index**:

$$\text{Cost Index} = \frac{\text{Cost of Time (‚Ç¨/min)}}{\text{Cost of Fuel (‚Ç¨/kg)}}$$

```{python}
#| echo: false
#| eval: true

# Airline cost index visualization
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Flight speed vs fuel consumption
speeds = np.linspace(400, 600, 50)  # km/h
fuel_consumption = 3000 + (speeds - 500)**2 / 20  # kg

ax1 = axes[0]
ax1.plot(speeds, fuel_consumption, 'b-', linewidth=2)
ax1.scatter([450, 500, 550], [3112.5, 3000, 3112.5], 
            s=150, color=['green', 'gold', 'red'],
            label=['CI=0 (Min fuel)', 'CI=50 (Balanced)', 'CI=100 (Min time)'])
ax1.set_xlabel('Cruise Speed (km/h)', fontsize=11)
ax1.set_ylabel('Fuel Consumption (kg)', fontsize=11)
ax1.set_title('Flight Speed Decision', fontsize=12)
ax1.grid(True, alpha=0.3)

# Different scenarios
scenarios = ['On-time\nCheap fuel', 'Normal\nOperations', 'Running late\nExpensive fuel']
ci_values = [20, 50, 80]
colors = ['green', 'gold', 'red']

ax2 = axes[1]
bars = ax2.bar(scenarios, ci_values, color=colors, alpha=0.7)
ax2.set_ylabel('Cost Index Setting', fontsize=11)
ax2.set_title('Adaptive Strategy Based on Conditions', fontsize=12)
ax2.set_ylim(0, 100)

for bar, ci in zip(bars, ci_values):
    height = bar.get_height()
    ax2.text(bar.get_x() + bar.get_width()/2., height + 2,
            f'CI={ci}', ha='center', fontsize=10, fontweight='bold')

plt.tight_layout()
plt.show()
```

**Real Example:** If flight delayed ‚Üí High time cost ‚Üí High CI ‚Üí Fly faster!

## Tesla's Strategy: Moving the Frontier

Instead of choosing a point on the Pareto frontier, Tesla **moved the entire frontier**:

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots(figsize=(10, 6))

# Original frontier (2010)
cost_2010 = np.linspace(30, 120, 50)
range_2010 = 600 - 4*cost_2010

# New frontier (2024)
cost_2024 = np.linspace(25, 100, 50)
range_2024 = 700 - 3*cost_2024

# Plot frontiers
ax.plot(cost_2010, range_2010, 'r--', linewidth=2, label='2010 Technology', alpha=0.7)
ax.plot(cost_2024, range_2024, 'g-', linewidth=2, label='2024 Technology', alpha=0.7)

# Show specific models
models = {
    '2010 Roadster': (100, 400, 'red'),
    '2024 Model 3': (40, 580, 'green'),
    '2024 Model S': (90, 650, 'green')
}

for name, (cost, range_val, color) in models.items():
    ax.scatter(cost, range_val, s=200, color=color, edgecolors='black', linewidth=2)
    ax.annotate(name, (cost, range_val), xytext=(5, 5), textcoords='offset points')

# Add arrow showing frontier shift
ax.annotate('', xy=(50, 550), xytext=(65, 400),
            arrowprops=dict(arrowstyle='->', lw=3, color='blue'))
ax.text(57, 475, 'R&D Innovation\nShifts Frontier', fontsize=11, 
        ha='center', color='blue', fontweight='bold')

ax.set_xlabel('Vehicle Cost (‚Ç¨1000s)', fontsize=12)
ax.set_ylabel('Range (km)', fontsize=12)
ax.set_title('Tesla Strategy: Don\'t Accept Trade-offs, Change Them!', fontsize=14)
ax.legend()
ax.grid(True, alpha=0.3)
ax.set_xlim(20, 125)
ax.set_ylim(100, 700)

plt.tight_layout()
plt.show()
```

[Key Insight: R&D can fundamentally change what's possible]{.highlight}

# [Real-World Application]{.flow} {.title}

## EcoExpress Requirements

For your **regional delivery network**, you need:

::: {.incremental}
- Total budget: ‚Ç¨3.5 million
- Fleet size: 60-120 vehicles
- Service level: 95% on-time delivery
- Emission target: 40% reduction from current
- Handle Black Friday (3x normal volume)
- Cover 3 cities with different regulations
:::

## Fleet Composition Strategy

Instead of one vehicle type, consider a **mixed fleet**:

```{python}
#| echo: false
#| eval: true

# Example fleet mix
fleet_mix = pd.DataFrame({
    'Vehicle Type': ['E-Truck', 'Hybrid Van', 'Diesel Van', 'E-Cargo Bike', 'Autonomous'],
    'Quantity': [25, 30, 15, 20, 10],
    'Use Case': ['City A (strict emissions)', 'City B (balanced)', 'City C (rural)', 'Dense urban cores', 'Night shifts'],
    'Advantage': ['Zero emissions', 'Versatile', 'Long range', 'Agile in traffic', 'No driver needed']
})

display(HTML(fleet_mix.to_html(index=False, classes='table table-striped')))
```

Match vehicle strengths to specific delivery zones!

## Decision Framework

```{python}
#| echo: false
#| eval: true

# Create decision flowchart visualization
fig, ax = plt.subplots(figsize=(12, 8))

# Decision steps
steps = [
    'Define Objectives\n(Cost, Emissions, Speed, Flexibility)',
    'Generate Options\n(Fleet combinations)',
    'Find Pareto Frontier\n(Non-dominated fleets)',
    'Apply Preferences\n(Weights or constraints)',
    'Sensitivity Analysis\n(What if weights change?)',
    'Make Decision\n(Choose fleet mix)'
]

y_positions = np.linspace(0.9, 0.1, len(steps))
x_position = 0.5

for i, (step, y_pos) in enumerate(zip(steps, y_positions)):
    # Box for each step
    rect = plt.Rectangle((x_position - 0.15, y_pos - 0.06), 
                         0.3, 0.08, 
                         facecolor='lightblue' if i % 2 == 0 else 'lightgreen',
                         edgecolor='black', linewidth=2)
    ax.add_patch(rect)
    
    # Text
    ax.text(x_position, y_pos - 0.02, step, 
           ha='center', va='center', fontsize=10, fontweight='bold')
    
    # Arrow to next step
    if i < len(steps) - 1:
        ax.arrow(x_position, y_pos - 0.06, 0, -0.04, 
                head_width=0.02, head_length=0.01, fc='black', ec='black')

ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.axis('off')
ax.set_title('Multi-Objective Decision Process', fontsize=16, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()
```

## Common Pitfalls

::: {.callout-warning}
## Watch Out For These Mistakes

1. **Forgetting to normalize** - Can't compare ‚Ç¨ to g/km directly
2. **Ignoring feasibility** - Check constraints first
3. **Over-optimizing** - Perfect is enemy of good
4. **Analysis paralysis** - Set deadline for decision
5. **Stakeholder alignment** - Get weight agreement upfront
:::

# [Mission Briefing]{.flow} {.title}

## Today's Learning Path

### Hour 3: Practice Notebook 
**Your Role:** Bean Counter CEO
- Learn to evaluate multi-objective trade-offs
- Implement Pareto frontier finding
- Apply weighted sum method
- Make data-driven recommendations

### Hour 4: Transportation & Fleet Competition
**Two Challenges to Master:**

**Part A: Multi-Objective Transportation (30 min)**
- Allocate deliveries between DCs and zones
- Balance cost vs emissions
- Use Œµ-constraint method
- Find YOUR optimal trade-off point

**Part B: Fleet Selection (30 min)**  
- Select vehicle mix for EcoExpress
- Meet EU emission targets
- Balance 3+ objectives
- Justify your strategic choice

## The Competition Challenge

::: {.callout-important}
## Fleet Selection Competition

**Objective:** Design EcoExpress's sustainable delivery fleet

**Given:**
- Vehicle specifications (5 types with different trade-offs)
- Budget: ‚Ç¨3.5M capital investment
- EU mandate: 40% emission reduction
- Service requirements per city

**Deliverable:**
- Fleet composition (quantity per vehicle type)
- Pareto frontier analysis
- Business case with 3-year ROI projection

**Evaluation:** Emissions (35%), Cost-efficiency (35%), Service quality (20%), Innovation (10%)
:::

## Tools You'll Master

::: columns
::: {.column width="50%"}
**Analytical Tools**
- Pareto frontier identification
- Normalization techniques
- Weighted scoring
- Constraint handling
:::

::: {.column width="50%"}
**Visualization Tools**
- Trade-off plots
- Parallel coordinates
- Spider/radar charts
- Decision matrices
:::
:::

## Key Takeaways

::: {.incremental}
1. **Real decisions have multiple objectives** - rarely just "minimize cost"
2. **Pareto frontier** shows all rational choices
3. **Weights reflect values** - make them explicit
4. **No perfect solution** - only good trade-offs
5. **Visualization crucial** for stakeholder buy-in
:::

. . .

[Ready to master the art of trade-offs?]{.highlight}

## Break!

```{python}
#| echo: false
#| eval: true

import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(figsize=(10, 6))

# Create a coffee cup
cup_x = [2, 2, 2.5, 2.5, 3, 3, 3, 2]
cup_y = [3, 5, 5, 4.5, 4.5, 5, 3, 3]
ax.fill(cup_x, cup_y, color='brown', alpha=0.7)

# Add steam with curves
t = np.linspace(0, 4*np.pi, 100)
for i in range(3):
    steam_x = 2.5 + 0.1*np.sin(t) + i*0.15
    steam_y = 5 + t/(2*np.pi) * 0.8
    ax.plot(steam_x, steam_y, color='gray', alpha=0.5, linewidth=2)

# Add trade-off arrows
ax.arrow(4, 4, 1, 0, head_width=0.1, head_length=0.1, fc='green', ec='green')
ax.text(5.5, 4, 'Speed', fontsize=12, ha='center')

ax.arrow(4, 4, 0, 1, head_width=0.1, head_length=0.1, fc='blue', ec='blue')
ax.text(4, 5.5, 'Quality', fontsize=12, ha='center')

ax.arrow(4, 4, -0.7, -0.7, head_width=0.1, head_length=0.1, fc='red', ec='red')
ax.text(3, 3, 'Cost', fontsize=12, ha='center')

ax.text(2.5, 2, "Even coffee involves\ntrade-offs!", 
        fontsize=14, ha='center', style='italic')

ax.set_xlim(1, 6)
ax.set_ylim(1, 6)
ax.axis('off')
plt.tight_layout()
plt.show()
```

[Time to practice multi-objective optimization!]{.flow}
