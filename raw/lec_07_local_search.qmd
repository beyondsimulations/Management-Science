---
title: "Better Routing"
subtitle: "Lecture 7 - Management Science"
author: "Dr. Tobias Vlćek"
format:
  revealjs:
    footer: " {{< meta title >}} | {{< meta author >}} | [Home](lec_07_local_search.qmd)"
    output-file: lec_07_presentation.html
---

# [Introduction]{.flow} {.title}

## **[Client Briefing: Artisan Bakery]{.invert-font}** {background-image="https://unsplash.com/photos/RndRFJ1v1kk/download?ixid=M3wxMjA3fDB8MXxhbGx8fHx8fHx8fHwxNzYyODcwNzAzfA&force=true&w=2400" background-size="cover"}

. . .

[Master Baker's Morning Dilemma:]{.invert-font}

["Every morning at 5 AM, our delivery van leaves with fresh bread for [16 cafés]{.highlight} across the city. Our driver currently takes much too long using his 'intuition' for the route. The fuel costs are killing us, and worse, some cafés get their bread late."]{.invert-font .fragment}

## The Delivery Challenge

[Artisan Bakery's daily logistics puzzle:]{.highlight}

::: incremental
- **16 Cafés:** Each expecting fresh bread by 8 AM
- **One Van:** Limited capacity, must visit all locations
- **Time Windows:** 3 cafés open early (6:30 AM) and need priority
- **Current Problem:** Driver uses "gut feeling" for routing
:::

. . .

:::{.callout-important}
**The Stakes:** Poor routing costs plus reputation damage from late deliveries!
:::

## Quick Recap: Greedy Decisions

[Last week we learned greedy algorithms for scheduling:]{.highlight}

::: incremental
- **SPT:** Process shortest jobs first
- **EDD:** Process by earliest due date
- **Fast & Simple:** Made quick decisions, no looking back
:::

. . .

[Question]{.question}: Can we use the same greedy approach for routing?

. . .

:::{.callout-note}
[Today:]{.highlight} We'll start greedy, then learn how to [improve]{.highlight} solutions with local search!
:::

# [The Routing Problem]{.flow} {.title}

## The Traveling Salesman Problem

[Visit all locations exactly once, minimize total distance.]{.highlight}

. . .

```{python}
#| eval: true
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append('../helpers')
from plot_utils import BRAND_COLORS, setup_clean_style

setup_clean_style()
np.random.seed(123)

# Generate 16 cafe locations
n_cafes = 16
x_coords = np.random.uniform(0, 30, n_cafes)
y_coords = np.random.uniform(0, 10, n_cafes)

# Bakery at center
bakery_x, bakery_y = 15, 5

fig, ax = plt.subplots()
ax.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], zorder=3, label='Cafés')
ax.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], marker='s', zorder=3, label='Bakery')

ax.set_xlabel('Distance (km)', fontsize=9)
ax.set_ylabel('Distance (km)', fontsize=9)
ax.grid(True, alpha=0.2)
ax.legend()
plt.tight_layout()
plt.show()
```

## Compute Everything?

[Already 16 cafés = 16! = 20,922,789,888,000 routes]{.highlight}

. . .

**If your computer checks 1 million routes per second:**

::: incremental
- 5 cafés: 0.0001 seconds ✓
- 10 cafés: 0.18 seconds ✓
- 12 cafés: 8 minutes ~
- 16 cafés: 8 months! x
- 20 cafés: 77,000 years x
:::

. . .

:::{.callout-important}
**The Reality:** Exact approach would take longer than the universe has existed!
:::

## The Complexity Explosion

[The factorial growth makes exhaustive search impossible.]{.highlight}

```{python}
#| eval: true
#| echo: false
import math

stops = list(range(4, 25))
possibilities = [math.factorial(n) for n in stops]

fig, ax = plt.subplots()
ax.semilogy(stops, possibilities, 'o-', color=BRAND_COLORS["threeDark"], linewidth=2.5, markersize=8)
ax.set_xlabel('Number of Stops', fontsize=11)
ax.set_ylabel('Possible Routes (log scale)', fontsize=11)
ax.set_title('The Combinatorial Explosion', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.2, which='both')

# Annotations
ax.annotate('16 stops:\n20 trillion', xy=(16, math.factorial(16)),
            xytext=(14.5, math.factorial(16)*10),
            arrowprops=dict(arrowstyle='->', color=BRAND_COLORS["oneDark"]),
            fontsize=10, ha='center')

plt.tight_layout()
plt.show()
```

## The "Cost" of Complexity

[Why buying a faster computer won't help:]{.highlight}

::: incremental

- **P:** Tasks that can be solved in polynomial time
  - Like sorting a spreadsheet or calculating payroll
  - These are safe, predictable, and easy to automate

- **NP:** Easy to check, hard to solve
  - Analogy: easy to check if a specific password works
  - Very hard to guess a password by trying every combination!

:::

. . .

::: callout-important
TSP optimization where we find minimum cost tour → NP-Hard. This means no known algorithm can find the perfect solution quickly for large problems.
:::

# [Graph Theory Foundations]{.flow} {.title}

## What is a Graph?

[A graph $G = (V, E)$ consists of:]{.highlight}

::: incremental
- **Vertices (V):** The nodes or points (bakery + cafés)
- **Edges (E):** The connections between vertices (roads)
- **Weight Function:** $w$ assigns costs to edges (distances)
:::

. . .

**For our bakery problem:**

::: incremental
- $|V| = 17$ (1 bakery + 17 cafés)
- $|E| = \binom{17}{2} = 136$ possible connections
- Each edge $(i,j)$ has weight $w_{ij}$ = distance between $i$ and $j$
:::

## Complete vs. Sparse Graphs

[Different graph structures lead to different complexities:]{.highlight}

::: incremental
- **Complete Graph:** All vertices connected to each other
  - TSP: $(n-1)!/2$ unique tours
  - Real roads: Usually complete (drive between any two points)
- **Sparse Graph:** Limited connections between vertices
  - Fewer edges = fewer possible routes
  - Examples: Public transit networks, restricted road access
:::

. . .

:::{.callout-important}
Density dramatically affects both problem difficulty and solution approaches!
:::

# [Greedy Construction]{.flow} {.title}

## Nearest Neighbor Algorithm

[Build a route by always visiting the closest unvisited location.]{.highlight}

. . .

1. Start at the bakery
2. Find the nearest unvisited café
3. Go there
4. Repeat until all visited
5. Return to bakery

. . .

:::{.callout-tip}
**Intuition:** Take what's easiest (nearest)!
:::

## Nearest Neighbor in Action

```{python}
#| eval: true
#| echo: false
# Build the route

np.random.seed(123)

# Generate 16 cafe locations
n_cafes = 8
x_coords = np.random.uniform(0, 30, n_cafes)
y_coords = np.random.uniform(0, 10, n_cafes)

# Bakery at center
bakery_x, bakery_y = 8, 4

def nearest_neighbor_route(x_coords, y_coords, start_x, start_y):
    n = len(x_coords)
    unvisited = list(range(n))
    route = []
    current_x, current_y = start_x, start_y

    while unvisited:
        nearest_idx = min(unvisited,
                         key=lambda i: calculate_distance(current_x, current_y,
                                                        x_coords[i], y_coords[i]))
        route.append(nearest_idx)
        unvisited.remove(nearest_idx)
        current_x, current_y = x_coords[nearest_idx], y_coords[nearest_idx]

    return route

def calculate_route_distance(route, x_coords, y_coords, start_x, start_y):
    distance = calculate_distance(start_x, start_y, x_coords[route[0]], y_coords[route[0]])
    for i in range(len(route) - 1):
        distance += calculate_distance(x_coords[route[i]], y_coords[route[i]],
                                      x_coords[route[i+1]], y_coords[route[i+1]])
    distance += calculate_distance(x_coords[route[-1]], y_coords[route[-1]], start_x, start_y)
    return distance

def calculate_distance(x1, y1, x2, y2):
    return np.sqrt((x2 - x1)**2 + (y2 - y1)**2)

route = nearest_neighbor_route(x_coords, y_coords, bakery_x, bakery_y)
initial_distance = calculate_route_distance(route, x_coords, y_coords, bakery_x, bakery_y)

# Visualize the route
fig, ax = plt.subplots()

# Draw route
route_x = [bakery_x] + [x_coords[i] for i in route] + [bakery_x]
route_y = [bakery_y] + [y_coords[i] for i in route] + [bakery_y]
ax.plot(route_x, route_y, 'o-', color=BRAND_COLORS["twoLight"], linewidth=2, markersize=0, alpha=0.7)

# Draw locations
ax.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], s=250, zorder=3, label='Cafés')
ax.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=250, marker='s', zorder=3, label='Bakery')

# Add labels
for i, (x, y) in enumerate(zip(x_coords, y_coords)):
    ax.annotate(f'C{i+1}', (x, y), ha='center', va='center', color='white', fontweight='bold')
ax.annotate('B', (bakery_x, bakery_y), ha='center', va='center', color='white', fontweight='bold', fontsize=14)

ax.set_xlabel('Distance (km)', fontsize=11)
ax.set_ylabel('Distance (km)', fontsize=11)
ax.set_title(f'Nearest Neighbor Route: {initial_distance:.1f} km', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.2)
ax.legend()
plt.tight_layout()
plt.show()
```

## Construction Methods Comparison

[Different ways to build initial routes:]{.highlight}

```{python}
#| eval: true
#| echo: false
# Show comparison of construction methods
# Generate random route
def random_route(n):
    route = list(range(n))
    np.random.shuffle(route)
    return route

# Simple furthest insertion simulation
def furthest_insertion_route(x_coords, y_coords, start_x, start_y):
    n = len(x_coords)
    if n <= 2:
        return list(range(n))

    # Start with furthest point
    distances_from_start = [np.sqrt((x - start_x)**2 + (y - start_y)**2) for x, y in zip(x_coords, y_coords)]
    route = [np.argmax(distances_from_start)]
    unvisited = set(range(n)) - set(route)

    # Add closest unvisited to any in route (simplified)
    while unvisited:
        best_dist = float('inf')
        best_node = None
        for u in unvisited:
            for r in route:
                dist = np.sqrt((x_coords[u] - x_coords[r])**2 + (y_coords[u] - y_coords[r])**2)
                if dist < best_dist:
                    best_dist = dist
                    best_node = u
        route.append(best_node)
        unvisited.remove(best_node)

    return route

# Calculate distances for different methods
nn_route = nearest_neighbor_route(x_coords, y_coords, bakery_x, bakery_y)
random_r = random_route(n_cafes)
furthest_r = furthest_insertion_route(x_coords, y_coords, bakery_x, bakery_y)

nn_dist = calculate_route_distance(nn_route, x_coords, y_coords, bakery_x, bakery_y)
random_dist = calculate_route_distance(random_r, x_coords, y_coords, bakery_x, bakery_y)
furthest_dist = calculate_route_distance(furthest_r, x_coords, y_coords, bakery_x, bakery_y)

# Create bar chart
methods = ['Nearest\nNeighbor', 'Random\nRoute', 'Furthest\nInsertion']
distances = [nn_dist, random_dist, furthest_dist]
colors = [BRAND_COLORS["twoDark"], BRAND_COLORS["threeDark"], BRAND_COLORS["oneDark"]]

fig, ax = plt.subplots()
bars = ax.bar(methods, distances, color=colors, alpha=0.8)
ax.set_ylabel('Total Distance (km)', fontsize=12)
ax.set_title('Starting Point Matters: Construction Method Comparison', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.2, axis='y')

# Add value labels on bars
for bar, dist in zip(bars, distances):
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2., height,
            f'{dist:.1f} km', ha='center', va='bottom', fontsize=11)

plt.tight_layout()
plt.show()
```

. . .

:::{.callout-note}
Different construction methods give different starting points!
:::



## The Problem with Greedy

[Question]{.question}: Can you spot any obvious inefficiencies in this route?

. . .

**Common Issues:**
::: incremental
- **Crossing paths:** Route crosses over itself
- **Long return:** Far from bakery at the end
- **Myopic decisions:** Can't see the "big picture"
:::

. . .

:::{.callout-warning}
Nearest neighbor typically gives solutions [15-25% worse]{.highlight} than optimal. Can we improve it?
:::

# [Local Search Framework]{.flow} {.title}

## The Four Pillars of Local Search

[Any problem can be solved with local search by defining:]{.highlight}

::: incremental
1. **Search Space:** All possible solutions (here 20 trillion routes!)
2. **Initial Solution:** Starting point (our greedy route)
3. **Objective Function:** How we measure quality (total distance)
4. **Neighborhood:** How to create "nearby" solutions (2-opt swaps)
:::

. . .

:::{.callout-important}
The power of local search: The same "engine" works for routing, scheduling, or any combinatorial problem - just plug in different components!
:::

## Solution Space: An Intuitive View

[Think of the solution space as a landscape:]{.highlight}

::: incremental
- **Each point:** A different route through the cafés
- **Height:** The total distance of that route (lower is better)
- **Neighbors:** Routes that differ by one small change
- **Local optimum:** Best route among nearby alternatives
- **Global optimum:** The absolute best route overall
:::

. . .

**Our Strategy:**
1. Start somewhere (greedy construction)
2. Look around at neighboring solutions
3. Move to better neighbors
4. Stop when no neighbor is better

. . .

:::{.callout-tip}
Local search transforms "quick and dirty" solutions into "pretty good" ones!
:::

# [Local Search Improvements]{.flow} {.title}

## The 2-Opt Algorithm

[Systematically improve routes by removing crossing paths.]{.highlight}

. . .

**The Idea:** Take two edges and swap them to uncross the route

```{python}
#| eval: true
#| echo: false
# Show a simple 2-opt swap illustration
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Before swap - create a crossing
points_x = [2, 6, 8, 4]
points_y = [2, 6, 2, 6]

ax1.plot([points_x[0], points_x[1]], [points_y[0], points_y[1]], 'o-',
         color=BRAND_COLORS["threeDark"], linewidth=3, markersize=10, label='Edge A-B')
ax1.plot([points_x[2], points_x[3]], [points_y[2], points_y[3]], 'o-',
         color=BRAND_COLORS["oneDark"], linewidth=3, markersize=10, label='Edge C-D')

ax1.annotate('A', (points_x[0], points_y[0]), xytext=(-10, -10), textcoords='offset points', fontsize=12)
ax1.annotate('B', (points_x[1], points_y[1]), xytext=(10, 10), textcoords='offset points', fontsize=12)
ax1.annotate('C', (points_x[2], points_y[2]), xytext=(10, -10), textcoords='offset points', fontsize=12)
ax1.annotate('D', (points_x[3], points_y[3]), xytext=(-10, 10), textcoords='offset points', fontsize=12)

ax1.set_title('Before: Crossing Paths', fontweight='bold')
ax1.set_xlim(0, 10)
ax1.set_ylim(0, 8)
ax1.grid(True, alpha=0.2)
ax1.legend()

# After swap
ax2.plot([points_x[0], points_x[2]], [points_y[0], points_y[2]], 'o-',
         color=BRAND_COLORS["twoDark"], linewidth=3, markersize=10, label='Edge A-C')
ax2.plot([points_x[1], points_x[3]], [points_y[1], points_y[3]], 'o-',
         color=BRAND_COLORS["twoLight"], linewidth=3, markersize=10, label='Edge B-D')

ax2.annotate('A', (points_x[0], points_y[0]), xytext=(-10, -10), textcoords='offset points', fontsize=12)
ax2.annotate('B', (points_x[1], points_y[1]), xytext=(10, 10), textcoords='offset points', fontsize=12)
ax2.annotate('C', (points_x[2], points_y[2]), xytext=(10, -10), textcoords='offset points', fontsize=12)
ax2.annotate('D', (points_x[3], points_y[3]), xytext=(-10, 10), textcoords='offset points', fontsize=12)

ax2.set_title('After: Uncrossed = Shorter!', fontweight='bold')
ax2.set_xlim(0, 10)
ax2.set_ylim(0, 8)
ax2.grid(True, alpha=0.2)
ax2.legend()

plt.tight_layout()
plt.show()
```

## Manual 2-Opt Example: Step-by-Step

[Let's trace through one 2-opt swap by hand:]{.highlight}

**Starting Route:** B → C1 → C3 → C5 → C2 → C4 → B

```
B → C1: 5 km    C3 → C5: 8 km    C4 → B: 6 km
C1 → C3: 7 km   C5 → C2: 9 km
C2 → C4: 4 km
Total: 5 + 7 + 8 + 9 + 4 + 6 = 39 km
```

. . .

[Notice:]{.question} Route crosses itself between C3→C5 and C2→C4!

. . .

**The Swap:**
1. Remove edges: C1→C3 and C2→C4
2. Reverse middle segment: [C3, C5, C2] becomes [C2, C5, C3]
3. New route: B → C1 → C2 → C5 → C3 → C4 → B

. . .

**New distance:** 5 + 6 + 9 + 8 + 3 + 6 = 37 km = [2 km saved!]{.highlight}

## How 2-Opt Works

```python
def two_opt_improvement(route, distances):
    """Apply 2-opt until no improvements found"""
    improved = True

    while improved:
        improved = False
        best_distance = calculate_route_distance(route, distances)

        # Try all possible edge swaps
        for i in range(len(route) - 1):
            for j in range(i + 2, len(route)):
                # Reverse segment between i and j
                new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]
                new_distance = calculate_route_distance(new_route, distances)

                # Accept if better
                if new_distance < best_distance:
                    route = new_route
                    best_distance = new_distance
                    improved = True
                    break

            if improved:
                break

    return route
```

. . .

:::{.callout-note}
**Key Operation:** `route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]`

The `[::-1]` reverses the segment, eliminating crossings!
:::

## 2-Opt Applied to Our 16-Café Problem

```{python}
#| eval: true
#| echo: false
# Implement basic 2-opt for demonstration
def two_opt_improvement(route, x_coords, y_coords, start_x, start_y):
    improved = True
    best_route = route.copy()

    while improved:
        improved = False
        for i in range(len(best_route) - 1):
            for j in range(i + 2, len(best_route)):
                # Create new route with swap
                new_route = best_route[:i+1] + best_route[i+1:j+1][::-1] + best_route[j+1:]

                # Calculate distances
                old_dist = calculate_route_distance(best_route, x_coords, y_coords, start_x, start_y)
                new_dist = calculate_route_distance(new_route, x_coords, y_coords, start_x, start_y)

                if new_dist < old_dist:
                    best_route = new_route
                    improved = True
                    break
            if improved:
                break

    return best_route

# Apply 2-opt
improved_route = two_opt_improvement(route, x_coords, y_coords, bakery_x, bakery_y)
improved_distance = calculate_route_distance(improved_route, x_coords, y_coords, bakery_x, bakery_y)

# Visualize improved route
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

# Original route
route_x = [bakery_x] + [x_coords[i] for i in route] + [bakery_x]
route_y = [bakery_y] + [y_coords[i] for i in route] + [bakery_y]
ax1.plot(route_x, route_y, 'o-', color=BRAND_COLORS["twoLight"], linewidth=2, markersize=0, alpha=0.7)
ax1.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], s=150, zorder=3)
ax1.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=300, marker='s', zorder=3)
ax1.set_title(f'Greedy: {initial_distance:.1f} km', fontweight='bold')
ax1.grid(True, alpha=0.2)

# Improved route
improved_x = [bakery_x] + [x_coords[i] for i in improved_route] + [bakery_x]
improved_y = [bakery_y] + [y_coords[i] for i in improved_route] + [bakery_y]
ax2.plot(improved_x, improved_y, 'o-', color=BRAND_COLORS["twoDark"], linewidth=2, markersize=0, alpha=0.7)
ax2.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], s=150, zorder=3)
ax2.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=300, marker='s', zorder=3)
ax2.set_title(f'After 2-Opt: {improved_distance:.1f} km', fontweight='bold')
ax2.grid(True, alpha=0.2)

# Calculate improvement
improvement = (initial_distance - improved_distance) / initial_distance * 100

plt.suptitle(f'Route Improvement: {improvement:.1f}% shorter!', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()
```

## Common 2-Opt Bugs (And How to Fix Them)

[Debug these scenarios you'll encounter:]{.highlight}

. . .

**Bug 1: Infinite Loop**
```python
# WRONG: Forgot to update route
if new_distance < current_distance:
    improved = True  # But route never changes!
```
**Fix:** `route = new_route` before continuing

. . .

**Bug 2: Missing Return to Start**
```python
# WRONG: Only measures cafe-to-cafe
total = sum(distances between stops)
```
**Fix:** `total += distance(last_stop, depot)`

. . .

**Bug 3: Invalid Segment Reversal**
```python
# WRONG: Off-by-one error
new_route = route[:i] + route[i:j][::-1] + route[j:]
```
**Fix:** `route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]`

## Beyond 2-Opt: k-Opt Neighborhoods

[The k-opt family of improvements:]{.highlight}

::: columns
::: {.column width="33%"}
**2-opt**
- Removes 2 edges
- 1 way to reconnect
- n² combinations
- Fast, good results
:::

::: {.column width="33%"}
**3-opt**
- Removes 3 edges
- 7 ways to reconnect
- n³ combinations
- Better but slower
:::

::: {.column width="33%"}
**Or-opt**
- Moves 1-3 nodes
- Different philosophy
- Good for time windows
- Preserves orientation
:::
:::

. . .

:::{.callout-tip}
Industry practice: Start with 2-opt (fast), use 3-opt if you have time!

As k increases, solutions improve but computation time grows exponentially.
:::

## Convergence and Local Optima

[When does local search stop? Why might it get stuck?]{.highlight}

**Convergence Analysis:**
- Algorithm stops when no neighboring solution is better
- Usually converges in n to n² iterations for n stops
- Each iteration checks all n² possible swaps

. . .

**The Local Optimum Problem:**
- Algorithm can only "see" neighboring solutions
- Might miss better solutions that require multiple changes
- Like being stuck on a small hill when there's a mountain nearby

. . .

:::{.callout-important}
**Key Insight:** Local search guarantees improvement but not global optimality.
That's why we need escape strategies!
:::

## The Local Optimum Trap: A Hiker's Dilemma

[Imagine you're a hiker dropped in foggy mountains at night...]{.highlight}

. . .

**Your Mission:** Find the highest peak (global optimum)
**Your Tool:** An altimeter (objective function)
**Your Vision:** Only the ground at your feet (local neighborhood)

. . .

**The Greedy Strategy:** Always step uphill

. . .

[Question]{.question}: What happens when you reach the top of a small hill?

. . .

:::{.callout-warning}
You're stuck! Every step is downhill, but you might be on a tiny hill while Mount Everest is nearby. This is the [local optimum trap]{.highlight}!
:::

## Visualizing Local Optima

```{python}
#| eval: true
#| echo: false
# Illustrate local vs global optimum concept
fig, ax = plt.subplots(figsize=(10, 5))

x = np.linspace(0, 10, 500)
y = -np.sin(x) * np.exp(-x/10) + 0.1*np.sin(5*x) + 2

ax.plot(x, y, color=BRAND_COLORS["twoDark"], linewidth=2.5)
ax.scatter([2.1], [-np.sin(2.1) * np.exp(-2.1/10) + 0.1*np.sin(5*2.1) + 2],
           color=BRAND_COLORS["threeDark"], s=200, zorder=3, label='Local Minimum')
ax.scatter([0.5], [-np.sin(0.5) * np.exp(-0.5/10) + 0.1*np.sin(5*0.5) + 2],
           color=BRAND_COLORS["oneDark"], s=200, zorder=3, label='Global Minimum')
ax.scatter([6.3], [-np.sin(6.3) * np.exp(-6.3/10) + 0.1*np.sin(5*6.3) + 2],
           color=BRAND_COLORS["oneDark"], s=200, zorder=3)

ax.annotate('Stuck here!', xy=(2.1, 1.65), xytext=(1, 1.3),
            arrowprops=dict(arrowstyle='->', color=BRAND_COLORS["threeDark"]),
            fontsize=11)
ax.annotate('Want here!', xy=(6.3, 1.45), xytext=(7.5, 1.2),
            arrowprops=dict(arrowstyle='->', color=BRAND_COLORS["oneDark"]),
            fontsize=11)

ax.set_xlabel('Solution Space', fontsize=11)
ax.set_ylabel('Total Distance', fontsize=11)
ax.set_title('The Local Optimum Trap', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.2)
ax.legend()
plt.tight_layout()
plt.show()
```

## Escaping Local Optima: Multi-Start Strategy

[Simple fix: Don't put all eggs in one basket!]{.highlight}

. . .

```python
def multi_start_optimization(n_starts=10):
    """Try multiple random starts, keep the best"""
    best_route = None
    for i in range(n_starts):
        # New random start
        route = random_initial_route()
        # Improve with 2-opt
        route = improve_with_2opt(route)
        # Keep if best so far
        if better_than(route, best_route):
            best_route = route
    return best_route
```

. . .

:::{.callout-note}
Like hiring 10 drivers, letting each plan their own route, then picking the best! Simple but effective.
:::

:::{.callout-tip}
**No Free Lunch Theorem:** There's no universal "best" algorithm for all problems.
What works great for routing might fail for scheduling. Always match your tool to your problem!
:::

## Real-World Impact: How Good is Good Enough?

[Industry benchmarks for delivery optimization:]{.highlight}

| Method | vs Optimal | Industry Use |
|--------|------------|--------------|
| Human intuition | +40-60% | Still common! |
| Nearest Neighbor | +20-25% | Quick dispatch |
| NN + 2-opt | +5-15% | Standard practice |
| Advanced Meta | +2-5% | Premium logistics |
| Exact (if possible) | 0% | Research only |

. . .

:::{.callout-important}
**Business Reality:** A 10% improvement = millions in savings for large logistics companies. Your 2-opt implementation could literally pay for itself in one day!
:::

## Time Windows: The Real-World Constraint

[Remember our bakery? Some cafés open earlier than others:]{.highlight}

**Artisan Bakery's Morning Schedule:**
- **Bakery opens:** 5:00 AM (van departs)
- **Early Birds (3 cafés):** Must receive by 6:45 AM
  - Café Europa, Sunrise Bistro, Morning Glory
- **Standard (13 cafés):** Must receive by 8:00 AM

. . .

[Question]{.question}: Can we just find the shortest route?

. . .

:::{.callout-warning}
**NO!** The shortest route might deliver to early cafés last, arriving at 7:30 AM. [Feasibility first, optimization second!]{.highlight}
:::

## Time Windows: Practical Approach

[Each location has a delivery time window:]{.highlight}

**Key Concepts:**
- **Earliest time:** When café opens
- **Latest time:** Delivery deadline
- **Service time:** Time to unload

. . .

**Arrival Time = Previous departure + Travel time**

. . .

**Feasible route:** All deadlines met
**Infeasible route:** At least one deadline missed (even if shortest!)

## Time Windows: Nearest Neighbor Modification

[Modify greedy construction to prioritize early deadlines:]{.highlight}

```python
def nearest_neighbor_with_time_windows(locations, time_windows, start_time):
    """Greedy construction respecting time constraints"""
    unvisited = set(range(len(locations)))
    route = []
    current_time = start_time

    while unvisited:
        # Find feasible neighbors (can reach before deadline)
        feasible = [i for i in unvisited
                   if current_time + travel_time(current, i)
                      <= time_windows[i]['latest']]

        if not feasible:
            return None  # No feasible route exists!

        # Among feasible, choose nearest OR most urgent
        next_stop = min(feasible,
                       key=lambda i: (time_windows[i]['latest'],
                                     distance(current, i)))

        # Update state
        route.append(next_stop)
        unvisited.remove(next_stop)
        current_time += travel_time(current, next_stop) + service_time

    return route
```

## 2-Opt with Time Windows: The Challenge

[Problem: 2-opt can break time feasibility!]{.highlight}

```{python}
#| eval: true
#| echo: false
# Illustrate time window violation
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Original feasible route
stops = ['Bakery', 'Early1', 'Early2', 'Late1', 'Late2']
times_feasible = [5.0, 5.5, 6.2, 7.1, 7.8]
deadlines = [None, 6.75, 6.75, 8.0, 8.0]

ax1.plot(range(len(stops)), times_feasible, 'o-',
         color=BRAND_COLORS["twoDark"], linewidth=2.5, markersize=10)
for i, (stop, deadline) in enumerate(zip(stops, deadlines)):
    if deadline:
        ax1.axhline(y=deadline, xmin=i/5, xmax=(i+0.5)/5,
                   color=BRAND_COLORS["oneDark"], linestyle='--', alpha=0.5)
ax1.set_xticks(range(len(stops)))
ax1.set_xticklabels(stops, rotation=45, ha='right')
ax1.set_ylabel('Time (decimal hours)', fontsize=11)
ax1.set_title('Original Route: FEASIBLE ✓', fontsize=13, fontweight='bold')
ax1.grid(True, alpha=0.2)
ax1.set_ylim(4.5, 8.5)

# After 2-opt: violated
times_infeasible = [5.0, 5.5, 7.2, 6.8, 7.8]
ax2.plot(range(len(stops)), times_infeasible, 'o-',
         color=BRAND_COLORS["threeDark"], linewidth=2.5, markersize=10)
for i, (stop, deadline) in enumerate(zip(stops, deadlines)):
    if deadline:
        ax2.axhline(y=deadline, xmin=i/5, xmax=(i+0.5)/5,
                   color=BRAND_COLORS["oneDark"], linestyle='--', alpha=0.5)
ax2.scatter([2], [times_infeasible[2]], color='red', s=200, zorder=5, marker='x', linewidths=3)
ax2.set_xticks(range(len(stops)))
ax2.set_xticklabels(stops, rotation=45, ha='right')
ax2.set_ylabel('Time (decimal hours)', fontsize=11)
ax2.set_title('After 2-Opt: INFEASIBLE ✗', fontsize=13, fontweight='bold')
ax2.grid(True, alpha=0.2)
ax2.set_ylim(4.5, 8.5)

plt.tight_layout()
plt.show()
```

:::{.callout-warning}
**Early2 now arrives at 7:12 AM** - missed its 6:45 deadline by 27 minutes!
:::

## 2-Opt with Time Windows: The Solution

[Only accept swaps that maintain feasibility:]{.highlight}

```python
def two_opt_with_time_windows(route, distances, time_windows, start_time):
    """2-opt that respects time constraints"""
    improved = True

    while improved:
        improved = False

        for i in range(len(route) - 1):
            for j in range(i + 2, len(route)):
                # Create candidate route
                new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]

                # Check feasibility FIRST
                if not is_feasible(new_route, time_windows, start_time):
                    continue  # Skip infeasible swaps

                # Among feasible swaps, take if shorter
                if calculate_distance(new_route) < calculate_distance(route):
                    route = new_route
                    improved = True
                    break

            if improved:
                break

    return route
```

:::{.callout-tip}
**Key Principle:** Feasibility is a hard constraint, distance is the objective. Never violate constraints to improve objective!
:::

# [Mission Briefing]{.flow} {.title}

## Choosing Your Weapon: Algorithm Selection

[Different situations call for different approaches:]{.highlight}

| Situation | Best Approach | Why |
|-----------|--------------|-----|
| Need solution NOW (< 1 sec) | Nearest Neighbor | Lightning fast |
| Have 1 minute | NN + 2-opt | Good balance |
| Have 5 minutes | Multi-start + 2-opt | Explore more options |
| Time windows critical | NN (prioritize early) + Or-opt | Preserves time feasibility |
| Academic benchmark | 3-opt or advanced | Maximum quality |

. . .

:::{.callout-tip}
**Today's Competition:** You have 60 minutes - use multi-start with 2-opt!
:::

## Implementation Pitfalls to Avoid

[Common bugs that cost you 30 minutes:]{.highlight}

❌ **Forgetting return to bakery:** Your distance calculation must include the trip back!
```python
# WRONG
total = sum(distances between consecutive stops)
# RIGHT
total = sum(distances) + distance(last_stop, bakery)
```

❌ **Index confusion in 2-opt:** Remember Python slicing!
```python
# The 2-opt swap reverses route[i+1:j+1], not route[i:j]
```

❌ **Modifying while iterating:** Make a copy!
```python
new_route = current_route.copy()  # Don't modify original
```

## Next Week: Escaping Local Optima

[When local search gets stuck, we need clever escapes:]{.highlight}

. . .

**Advanced Techniques Coming:**
- **Simulated Annealing:** Sometimes accept worse moves (like heating metal)
- **Genetic Algorithms:** Combine good routes to make better ones
- **Tabu Search:** Remember where you've been to avoid circles

. . .

:::{.callout-note}
Today's local search foundation makes next week's advanced methods possible!
:::

# [Literature]{.flow} {.title}

## Resources

**Essential Reading:**
- Applegate et al. (2011): *The Traveling Salesman Problem* - The definitive TSP reference
- Laporte (1992): *The Vehicle Routing Problem* - Overview of routing algorithms
- Lin & Kernighan (1973): Classic paper on k-opt improvements

**Python Libraries:**
- `scipy.spatial.distance` - Fast distance calculations
- `networkx` - Graph algorithms including TSP approximations
- `ortools` - Google's optimization tools with routing

## Summary

[Key Takeaways:]{.highlight}

::: incremental
- TSP is computationally hard (factorial growth)
- Local search is a universal framework (4 pillars)
- Greedy construction gives fast initial solutions
- 2-opt improves solutions iteratively
- Multi-start helps escape local optima
- Real constraints (time windows) add complexity
- Two-phase approach: Build then improve!
:::
