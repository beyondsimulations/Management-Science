---
title: "The Metaheuristics Toolkit"
subtitle: "Lecture 9 - Management Science"
author: "Dr. Tobias Vlćek"
format:
  revealjs:
    footer: " {{< meta title >}} | {{< meta author >}} | [Home](lec_09_metaheuristics.qmd)"
    output-file: lec_09_presentation.html
---

# [Introduction]{.flow} {.title}

## **[Client Briefing: La Étoile Restaurant]{.invert-font}** {background-image="https://unsplash.com/photos/Gg5tmm48v0w/download?ixid=M3wxMjA3fDB8MXxzZWFyY2h8Mnx8bWljaGVsaW4lMjBzdGFyJTIwcmVzdGF1cmFudHxlbnwwfHx8fDE3MzE1MjQxMDF8MA&force=true&w=2400" background-size="cover"}

. . .

[Restaurant Manager's Crisis:]{.invert-font}

["We need to schedule 18 servers for this weekend, but we don't have enough experienced staff to meet all quality requirements!"]{.invert-font .fragment}

## The Staffing Challenge

**La Étoile** - Three Michelin star restaurant facing a scheduling crisis:

::: {.incremental}
- 18 servers available (6 experienced, 12 junior)
- 6 shifts this weekend (Fri-Sun)
- Each shift needs 3 servers
- **Problem**: Need 8 experienced servers, only have 6!
:::

. . .

[How do we minimize the damage?]{.question}

## Quick Recap: Our Optimization Journey

```{python}
#| echo: false
#| eval: true

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

# Set style
plt.style.use('seaborn-v0_8-darkgrid')

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Greedy
ax = axes[0]
x = np.linspace(0, 10, 100)
y = -0.5*x**2 + 3*x + 2
ax.plot(x, y, 'b-', linewidth=2)
ax.scatter([3], [6.5], color='red', s=200, marker='*', zorder=5)
ax.arrow(0, 2, 2.8, 4.3, head_width=0.3, head_length=0.2, fc='green', ec='green')
ax.set_title('Greedy Algorithms\n(Fast, Good Enough)', fontsize=12, fontweight='bold')
ax.set_xlabel('Solution Space')
ax.set_ylabel('Quality')
ax.text(3, 5.5, 'Quick\nDecision', ha='center', fontsize=10)

# Local Search
ax = axes[1]
np.random.seed(42)
x = np.linspace(0, 10, 100)
y = -0.3*(x-3)**2 + 6 + 2*np.sin(3*x)
ax.plot(x, y, 'b-', linewidth=2)
ax.scatter([4.5], [7.8], color='orange', s=200, marker='*', zorder=5)
ax.scatter([3], [6.5], color='gray', s=100, alpha=0.5)
ax.arrow(3, 6.5, 1.3, 1.0, head_width=0.3, head_length=0.2, fc='orange', ec='orange')
ax.set_title('Local Search\n(Improves Greedy)', fontsize=12, fontweight='bold')
ax.set_xlabel('Solution Space')
ax.text(4.5, 6.8, 'Local\nOptimum', ha='center', fontsize=10)

# Metaheuristics
ax = axes[2]
x = np.linspace(0, 10, 100)
y = -0.3*(x-3)**2 + 6 + 2*np.sin(3*x)
ax.plot(x, y, 'b-', linewidth=2)
ax.scatter([7.8], [8.5], color='green', s=200, marker='*', zorder=5)
ax.scatter([4.5], [7.8], color='gray', s=100, alpha=0.5)
ax.arrow(4.5, 7.8, 3.0, 0.5, head_width=0.3, head_length=0.2, 
         fc='purple', ec='purple', linestyle='--')
ax.set_title('Metaheuristics\n(Escapes Local Traps)', fontsize=12, fontweight='bold')
ax.set_xlabel('Solution Space')
ax.text(7.8, 7.5, 'Global\nOptimum', ha='center', fontsize=10)

plt.tight_layout()
plt.show()
```

# [Why Simple Methods Fail]{.flow} {.title}

## Restaurant Staffing: The Numbers

```{python}
#| echo: false
#| eval: true

# Create staffing requirements table
shifts = pd.DataFrame({
    'Shift': ['Friday Dinner', 'Friday Late', 'Saturday Lunch', 
              'Saturday Dinner', 'Sunday Lunch', 'Sunday Dinner'],
    'Type': ['Dinner', 'Late', 'Lunch', 'Dinner', 'Lunch', 'Dinner'],
    'Servers Needed': [3, 3, 3, 3, 3, 3],
    'Experienced Required': [2, 0, 1, 2, 1, 2],
    'Penalty if Violated': ['€200', '€0', '€200', '€200', '€200', '€200']
})

from IPython.display import HTML, display
display(HTML(shifts.to_html(index=False, classes='table table-striped')))

print("\nStaff Available:")
print("• 6 Experienced servers (€75/hour)")
print("• 12 Junior servers (€25/hour)")
print("\nMINIMUM experienced needed: 2+0+1+2+1+2 = 8")
print("AVAILABLE experienced: 6")
print("\n⚠️ IMPOSSIBLE to meet all requirements!")
```

## Why Greedy Gets Stuck

```python
# Greedy approach: Assign experienced to high-penalty shifts first
greedy_assignment = assign_greedy(shifts, servers)
# Result: €2,400 total cost
```

**Problem**: Once assigned, can't backtrack!

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots(figsize=(10, 6))

# Simulate greedy getting stuck
iterations = range(6)
costs = [3000, 2800, 2600, 2400, 2400, 2400]  # Gets stuck at 2400

ax.plot(iterations, costs, 'o-', linewidth=2, markersize=10, color='red')
ax.axhline(y=2200, color='green', linestyle='--', alpha=0.5, label='Better solution exists')
ax.set_xlabel('Assignment Step', fontsize=12)
ax.set_ylabel('Total Cost (€)', fontsize=12)
ax.set_title('Greedy Algorithm Gets Stuck', fontsize=14, fontweight='bold')
ax.set_ylim(2000, 3200)
ax.grid(True, alpha=0.3)
ax.legend()

# Add annotations
ax.annotate('Stuck here!', xy=(5, 2400), xytext=(4.5, 2600),
            arrowprops=dict(arrowstyle='->', color='red'),
            fontsize=11, color='red')
ax.annotate('Better solution\n(unreachable)', xy=(5, 2200), xytext=(3.5, 2050),
            arrowprops=dict(arrowstyle='->', color='green'),
            fontsize=11, color='green')

plt.tight_layout()
plt.show()
```

## Local Search Also Struggles

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Left: Solution space visualization
ax = axes[0]
np.random.seed(123)
x = np.linspace(0, 100, 1000)
y = 2400 - 300*np.sin(x/10) - 150*np.sin(x/3) + 50*np.random.randn(1000)

ax.plot(x, y, alpha=0.7, linewidth=1)
ax.scatter([30], [2400], color='red', s=200, marker='o', zorder=5, label='Local Search')
ax.scatter([78], [2100], color='green', s=200, marker='*', zorder=5, label='Global Optimum')

ax.set_xlabel('Solution Space', fontsize=12)
ax.set_ylabel('Total Cost (€)', fontsize=12)
ax.set_title('Many Local Optima Trap Local Search', fontsize=12, fontweight='bold')
ax.legend()
ax.grid(True, alpha=0.3)

# Right: Swap attempts
ax = axes[1]
swaps = ['Swap 1-2', 'Swap 3-4', 'Swap 5-6', 'Swap 2-5', 'Swap 1-6']
improvements = [50, -30, 0, -40, -20]
colors = ['green' if x > 0 else 'red' for x in improvements]

bars = ax.bar(swaps, improvements, color=colors, alpha=0.7)
ax.axhline(y=0, color='black', linewidth=1)
ax.set_ylabel('Cost Change (€)', fontsize=12)
ax.set_title('Local Swaps: Mostly Make Things Worse', fontsize=12, fontweight='bold')
ax.grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()
```

[We need smarter exploration strategies!]{.highlight}

# [Metaheuristic #1: Simulated Annealing]{.flow} {.title}

## The Metallurgy Metaphor

::: columns
::: {.column width="50%"}
**Annealing Metal:**
1. Heat to high temperature
2. Atoms move freely
3. Slowly cool down
4. Forms perfect crystal structure

**Key insight**: Temperature controls randomness
:::

::: {.column width="50%"}
**Optimization:**
1. Start with high "temperature"
2. Accept bad moves often
3. Gradually reduce temperature
4. Converge to good solution

**Key insight**: Escape local optima early
:::
:::

## Temperature Controls Acceptance

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

temperatures = [1000, 100, 10]
titles = ['Hot (Early): Accept Almost Anything', 
          'Warm (Middle): Getting Pickier', 
          'Cold (Late): Only Improvements']

for ax, T, title in zip(axes, temperatures, titles):
    delta_costs = np.linspace(-500, 500, 100)
    probabilities = np.exp(-np.maximum(0, delta_costs) / T)
    
    ax.plot(delta_costs, probabilities, linewidth=3)
    ax.fill_between(delta_costs, 0, probabilities, alpha=0.3)
    ax.set_xlabel('Cost Change (€)', fontsize=11)
    ax.set_ylabel('Acceptance Probability', fontsize=11)
    ax.set_title(title, fontsize=12, fontweight='bold')
    ax.set_ylim(0, 1.1)
    ax.grid(True, alpha=0.3)
    ax.axvline(x=0, color='red', linestyle='--', alpha=0.5)
    
    # Add annotations
    if T == 1000:
        ax.text(200, 0.8, '80% chance\nof accepting\n€200 worse', 
                ha='center', fontsize=9, bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.3))
    elif T == 100:
        ax.text(200, 0.2, '13% chance\nof accepting\n€200 worse', 
                ha='center', fontsize=9, bbox=dict(boxstyle='round', facecolor='orange', alpha=0.3))
    else:
        ax.text(200, 0.02, '~0% chance\nof accepting\nworse solutions', 
                ha='center', fontsize=9, bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.3))

plt.tight_layout()
plt.show()
```

## Simulated Annealing in Action

```{python}
#| echo: false
#| eval: true

# Simulate SA performance
np.random.seed(456)
iterations = range(0, 101, 5)
greedy_cost = [2400] * len(iterations)
sa_cost = []
temperature = []

for i in iterations:
    T = 1000 * (0.95 ** i)
    temperature.append(T)
    
    if i < 20:
        # High temp: exploring wildly
        cost = 2400 + np.random.randn() * 200
    elif i < 60:
        # Medium temp: converging
        cost = 2300 - (i-20) * 3 + np.random.randn() * 50
    else:
        # Low temp: fine-tuning
        cost = 2100 + np.random.randn() * 20
    
    sa_cost.append(max(2050, cost))

fig, axes = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

# Top: Cost over time
ax = axes[0]
ax.plot(iterations, greedy_cost, 'r--', linewidth=2, label='Greedy (stuck)')
ax.plot(iterations, sa_cost, 'b-', linewidth=2, label='Simulated Annealing')
ax.fill_between(iterations, greedy_cost, sa_cost, where=[s < g for s, g in zip(sa_cost, greedy_cost)],
                 color='green', alpha=0.2, label='SA Improvement')
ax.set_ylabel('Total Cost (€)', fontsize=12)
ax.set_title('Simulated Annealing Escapes Local Optimum', fontsize=14, fontweight='bold')
ax.legend()
ax.grid(True, alpha=0.3)

# Bottom: Temperature
ax = axes[1]
ax.plot(iterations, temperature, 'orange', linewidth=2)
ax.fill_between(iterations, 0, temperature, color='orange', alpha=0.3)
ax.set_xlabel('Iteration', fontsize=12)
ax.set_ylabel('Temperature', fontsize=12)
ax.set_title('Temperature Schedule (Cooling)', fontsize=12)
ax.grid(True, alpha=0.3)

# Add phase annotations
ax.text(10, 800, 'Exploration\nPhase', ha='center', fontsize=10, fontweight='bold')
ax.text(40, 400, 'Transition\nPhase', ha='center', fontsize=10, fontweight='bold')
ax.text(80, 100, 'Exploitation\nPhase', ha='center', fontsize=10, fontweight='bold')

plt.tight_layout()
plt.show()
```

[Notice: SA accepts worse solutions early, then converges!]{.highlight}

## Using SA with AI Tools

::: {.callout-tip}
## ChatGPT/Copilot Prompt Template
"I need to solve a staff scheduling problem using simulated annealing:
- 18 servers (6 experienced, 12 junior) 
- 6 shifts, each needs 3 servers
- Minimize: labor cost + penalty for understaffing
- Constraints: Each server works once

Please implement simulated annealing with:
- Initial temperature: 1000
- Cooling rate: 0.95
- Neighborhood: swap two server assignments"
:::

AI tools know SA templates - just describe YOUR problem clearly!

# [Metaheuristic #2: Genetic Algorithms]{.flow} {.title}

## Evolution as Optimization

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 4, figsize=(16, 4))

# Generation 1: Random population
ax = axes[0]
np.random.seed(789)
costs = np.random.uniform(2200, 3000, 50)
ax.scatter(range(50), costs, alpha=0.6, s=30)
ax.axhline(y=np.min(costs), color='green', linestyle='--', alpha=0.5)
ax.set_title('Generation 1\nRandom Solutions', fontsize=11, fontweight='bold')
ax.set_ylabel('Cost (€)')
ax.set_ylim(2000, 3200)

# Generation 10: Some improvement
ax = axes[1]
costs = np.random.normal(2600, 200, 50)
costs = np.clip(costs, 2100, 3000)
ax.scatter(range(50), costs, alpha=0.6, s=30, color='orange')
ax.axhline(y=np.min(costs), color='green', linestyle='--', alpha=0.5)
ax.set_title('Generation 10\nGetting Better', fontsize=11, fontweight='bold')
ax.set_ylim(2000, 3200)

# Generation 50: Converging
ax = axes[2]
costs = np.random.normal(2300, 100, 50)
costs = np.clip(costs, 2050, 2800)
ax.scatter(range(50), costs, alpha=0.6, s=30, color='blue')
ax.axhline(y=np.min(costs), color='green', linestyle='--', alpha=0.5)
ax.set_title('Generation 50\nConverging', fontsize=11, fontweight='bold')
ax.set_ylim(2000, 3200)

# Generation 100: Optimized
ax = axes[3]
costs = np.random.normal(2100, 50, 50)
costs = np.clip(costs, 2050, 2300)
ax.scatter(range(50), costs, alpha=0.6, s=30, color='green')
ax.axhline(y=np.min(costs), color='green', linestyle='--', alpha=0.5)
ax.set_title('Generation 100\nOptimized!', fontsize=11, fontweight='bold')
ax.set_ylim(2000, 3200)
ax.set_xlabel('Solution in Population')

plt.tight_layout()
plt.show()
```

Population evolves toward better solutions!

## The Genetic Process

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# 1. Selection
ax = axes[0, 0]
fitness = [2800, 2300, 2600, 2100, 2900, 2200, 2700, 2400, 2500, 3000]
colors = ['green' if f <= 2400 else 'red' for f in fitness]
bars = ax.bar(range(10), fitness, color=colors, alpha=0.7)
ax.set_title('1. Selection: Pick the Best', fontsize=12, fontweight='bold')
ax.set_ylabel('Cost (€)')
ax.set_xlabel('Solution')
ax.axhline(y=2400, color='black', linestyle='--', label='Selection threshold')
ax.legend()

# 2. Crossover
ax = axes[0, 1]
ax.axis('off')
ax.text(0.5, 0.8, 'Parent 1: [E, E, J, J, E, J, ...]', fontsize=11, ha='center', 
        bbox=dict(boxstyle='round', facecolor='lightblue'))
ax.text(0.5, 0.6, 'Parent 2: [J, E, E, J, J, E, ...]', fontsize=11, ha='center',
        bbox=dict(boxstyle='round', facecolor='lightgreen'))
ax.arrow(0.5, 0.55, 0, -0.1, head_width=0.02, head_length=0.02, fc='black', ec='black')
ax.text(0.5, 0.35, 'Child: [E, E, E, J, J, J, ...]', fontsize=11, ha='center',
        bbox=dict(boxstyle='round', facecolor='yellow'))
ax.set_title('2. Crossover: Combine Solutions', fontsize=12, fontweight='bold')
ax.text(0.5, 0.15, 'Take first half from Parent 1,\nsecond half from Parent 2', 
        fontsize=10, ha='center', style='italic')

# 3. Mutation
ax = axes[1, 0]
ax.axis('off')
ax.text(0.5, 0.7, 'Before: [E, E, J, J, E, J]', fontsize=11, ha='center',
        bbox=dict(boxstyle='round', facecolor='lightblue'))
ax.arrow(0.5, 0.6, 0, -0.1, head_width=0.02, head_length=0.02, fc='black', ec='black')
ax.text(0.5, 0.4, 'After: [E, J, E, J, E, J]', fontsize=11, ha='center',
        bbox=dict(boxstyle='round', facecolor='orange'))
ax.text(0.5, 0.25, 'Random swap!', fontsize=10, ha='center', color='red')
ax.set_title('3. Mutation: Add Randomness', fontsize=12, fontweight='bold')
ax.text(0.5, 0.1, 'Prevents getting stuck,\nexplores new areas', 
        fontsize=10, ha='center', style='italic')

# 4. New Generation
ax = axes[1, 1]
generation_data = {
    'Type': ['Elite (kept)', 'Children (crossover)', 'Mutated', 'Random (diversity)'],
    'Count': [5, 30, 10, 5]
}
colors = ['gold', 'lightblue', 'orange', 'gray']
ax.pie(generation_data['Count'], labels=generation_data['Type'], colors=colors,
       autopct='%1.0f%%', startangle=90)
ax.set_title('4. New Generation Composition', fontsize=12, fontweight='bold')

plt.tight_layout()
plt.show()
```

## Real-World GA Applications

::: columns
::: {.column width="50%"}
**NASA Antenna Design**
- Evolved weird-looking but highly efficient antennas
- Outperformed human designs
- Now flying on spacecraft!

**Trading Strategies**
- Evolve trading rules
- Adapt to market changes
- Used by hedge funds
:::

::: {.column width="50%"}
**Production Scheduling**
- Complex factory schedules
- Multiple constraints
- Better than manual planning

**Neural Architecture Search**
- Design AI models automatically
- Google's AutoML
- Finds novel architectures
:::
:::

[GAs excel when you don't know what good solutions look like!]{.highlight}

# [More Metaheuristics]{.flow} {.title}

## Metaheuristic #3: Tabu Search

**The Memory-Based Explorer**

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots(figsize=(10, 6))

# Create a path with tabu memory
np.random.seed(234)
x = [5]
y = [5]
tabu_x = []
tabu_y = []

for i in range(15):
    # Next move (avoiding tabu)
    dx, dy = np.random.randn(2)
    new_x = x[-1] + dx
    new_y = y[-1] + dy
    
    # Mark previous positions as tabu
    if i > 0 and i % 3 == 0:
        tabu_x.extend(x[-3:])
        tabu_y.extend(y[-3:])
    
    x.append(new_x)
    y.append(new_y)

# Plot exploration
ax.plot(x, y, 'b-', alpha=0.5, linewidth=2)
ax.plot(x, y, 'bo', markersize=8)
ax.scatter(tabu_x, tabu_y, color='red', s=100, marker='x', linewidth=3, label='Tabu (no return)')
ax.scatter(x[0], y[0], color='green', s=200, marker='*', label='Start')
ax.scatter(x[-1], y[-1], color='orange', s=200, marker='*', label='Current')

ax.set_title('Tabu Search: Memory Prevents Cycling', fontsize=14, fontweight='bold')
ax.set_xlabel('Solution Space X')
ax.set_ylabel('Solution Space Y')
ax.legend()
ax.grid(True, alpha=0.3)

# Add annotation
ax.annotate('Cannot return here\nfor 10 iterations', xy=(tabu_x[0], tabu_y[0]),
            xytext=(tabu_x[0]-2, tabu_y[0]+2),
            arrowprops=dict(arrowstyle='->', color='red'),
            fontsize=10, color='red')

plt.tight_layout()
plt.show()
```

**Key Ideas:**
- Keep a "tabu list" of recent moves
- Don't repeat them for N iterations
- Forces exploration of new areas

## Metaheuristic #4: Ant Colony Optimization

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Create nodes for paths
nodes = [(1, 3), (3, 4), (5, 3), (4, 1), (2, 1), (1, 3)]

for idx, (ax, title) in enumerate(zip(axes, 
    ['Early: Random Exploration', 'Middle: Pheromone Trails Form', 'Late: Converged to Best Path'])):
    
    # Draw all possible paths with different intensities
    for i in range(len(nodes)-1):
        for j in range(i+1, len(nodes)):
            if idx == 0:
                alpha = 0.1  # All paths weak
            elif idx == 1:
                alpha = 0.1 + np.random.rand() * 0.3  # Some stronger
            else:
                # Strong path for best route
                if (i, j) in [(0, 1), (1, 2), (2, 3)]:
                    alpha = 0.8
                else:
                    alpha = 0.05
            
            ax.plot([nodes[i][0], nodes[j][0]], 
                   [nodes[i][1], nodes[j][1]], 
                   'gray', alpha=alpha, linewidth=alpha*10)
    
    # Draw nodes
    for node in nodes:
        ax.scatter(node[0], node[1], s=200, color='blue', zorder=5)
    
    ax.set_title(title, fontsize=12, fontweight='bold')
    ax.set_xlim(0, 6)
    ax.set_ylim(0, 5)
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

**Applications:** Amazon warehouse routing, network design, delivery optimization

## Quick Mentions

::: columns
::: {.column width="50%"}
**Particle Swarm Optimization**
- Birds flocking behavior
- Particles "fly" through solution space
- Good for continuous optimization

**Variable Neighborhood Search**
- Switch between different neighborhoods
- When stuck with 2-opt, try 3-opt
- Systematic diversification
:::

::: {.column width="50%"}
**GRASP**
- Greedy Randomized Adaptive Search
- Random greedy + local search
- Simple but effective

**Memetic Algorithms**
- Genetic Algorithm + Local Search
- "Lamarckian evolution"
- Best of both worlds
:::
:::

[Many more exist - active research area!]{.highlight}

# [Decision Framework]{.flow} {.title}

## Your Metaheuristic Decision Guide

```{python}
#| echo: false
#| eval: true

import pandas as pd
from IPython.display import HTML, display

decision_table = pd.DataFrame({
    'Method': ['Greedy', 'Local Search (2-opt)', 'Simulated Annealing', 
               'Genetic Algorithm', 'Tabu Search', 'Ant Colony'],
    'Speed': ['⚡⚡⚡', '⚡⚡', '⚡⚡', '⚡', '⚡⚡', '⚡'],
    'Code Complexity': ['Simple', 'Medium', 'Medium', 'Complex', 'Medium', 'Complex'],
    'Best For': ['Quick decisions', 'Route improvement', 'Escaping local optima',
                 'Complex multi-variable', 'Preventing cycling', 'Path problems'],
    'AI Help': ['✓✓✓', '✓✓✓', '✓✓✓', '✓✓', '✓✓', '✓']
})

# Create styled HTML table
html = decision_table.to_html(index=False, classes='table table-striped')
display(HTML(html))
```

::: {.callout-important}
## Key Insight
You don't need to code these from scratch! AI tools can implement them if you describe your problem clearly.
:::

## When to Use What?

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots(figsize=(12, 8))

# Decision tree visualization
ax.text(0.5, 0.9, 'Start Here', fontsize=14, fontweight='bold', ha='center',
        bbox=dict(boxstyle='round', facecolor='lightblue'))

# Time constraint branch
ax.arrow(0.5, 0.85, -0.2, -0.15, head_width=0.01, head_length=0.01, fc='black', ec='black')
ax.text(0.25, 0.65, 'Need answer\nin < 1 minute?', fontsize=11, ha='center',
        bbox=dict(boxstyle='round', facecolor='lightyellow'))

ax.arrow(0.25, 0.6, -0.1, -0.1, head_width=0.01, head_length=0.01, fc='green', ec='green')
ax.text(0.1, 0.45, 'YES\n→ Use Greedy', fontsize=10, ha='center', color='green',
        bbox=dict(boxstyle='round', facecolor='lightgreen'))

ax.arrow(0.25, 0.6, 0.1, -0.1, head_width=0.01, head_length=0.01, fc='blue', ec='blue')
ax.text(0.4, 0.45, 'NO\n→ Continue', fontsize=10, ha='center', color='blue')

# Problem type branch
ax.arrow(0.5, 0.85, 0.2, -0.15, head_width=0.01, head_length=0.01, fc='black', ec='black')
ax.text(0.75, 0.65, 'Is it a\nrouting problem?', fontsize=11, ha='center',
        bbox=dict(boxstyle='round', facecolor='lightyellow'))

ax.arrow(0.75, 0.6, 0.1, -0.1, head_width=0.01, head_length=0.01, fc='green', ec='green')
ax.text(0.9, 0.45, 'YES\n→ Try 2-opt first\n→ Then ACO', fontsize=10, ha='center', color='green',
        bbox=dict(boxstyle='round', facecolor='lightgreen'))

# Complex problem branch
ax.arrow(0.4, 0.4, 0, -0.1, head_width=0.01, head_length=0.01, fc='black', ec='black')
ax.text(0.4, 0.25, 'Getting stuck in\nlocal optima?', fontsize=11, ha='center',
        bbox=dict(boxstyle='round', facecolor='lightyellow'))

ax.arrow(0.4, 0.2, -0.15, -0.08, head_width=0.01, head_length=0.01, fc='orange', ec='orange')
ax.text(0.2, 0.08, 'YES + Simple\n→ Simulated Annealing', fontsize=10, ha='center', color='orange',
        bbox=dict(boxstyle='round', facecolor='#FFE4B5'))

ax.arrow(0.4, 0.2, 0.15, -0.08, head_width=0.01, head_length=0.01, fc='purple', ec='purple')
ax.text(0.6, 0.08, 'YES + Complex\n→ Genetic Algorithm', fontsize=10, ha='center', color='purple',
        bbox=dict(boxstyle='round', facecolor='#E6E6FA'))

ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.axis('off')
ax.set_title('Metaheuristic Selection Flowchart', fontsize=16, fontweight='bold', pad=20)

plt.tight_layout()
plt.show()
```

## Working with AI Tools

::: {.callout-tip}
## Best Practices for AI-Assisted Metaheuristics

1. **Describe the problem clearly**
   - State variables, constraints, objective
   - Provide sample data

2. **Ask for specific algorithm**
   - "Implement simulated annealing for..."
   - "Use genetic algorithm to solve..."

3. **Request explanations**
   - "Explain each step"
   - "Add comments to code"

4. **Validate results**
   - Check constraints are met
   - Compare with simple baseline
:::

[AI is your implementation partner, not your decision maker!]{.highlight}

# [Mission Briefing]{.flow} {.title}

## Restaurant Competition Preview

**Your Challenge:** Schedule 18 servers for weekend shifts

**The Twist:** Impossible constraints!
- Need 8 experienced servers
- Only have 6 available
- Must decide where to accept penalties

**Approaches Welcome:**
- Smart greedy heuristics
- Local search improvements  
- Metaheuristics (with AI help)
- Creative solutions!

## What You'll Practice Today

### Hour 3: Bean Counter Scenarios
**See metaheuristics in action:**
- Compare algorithms on Bean Counter problems
- Use AI tools to adapt solutions
- Learn when each technique shines

### Hour 4: Restaurant Staffing Competition
**Apply your knowledge:**
- Choose your approach (simple to advanced)
- Minimize total cost (labor + penalties)
- Present your solution strategy

## Key Takeaways

::: {.incremental}
1. **Greedy is often good enough** - Start simple!
2. **Local search improves greedy** - Easy wins
3. **Metaheuristics escape traps** - When stuck
4. **Different tools for different problems** - Know when to use what
5. **AI tools are your allies** - Implementation help available
:::

. . .

[Remember: The goal isn't to memorize algorithms, but to know when and how to apply them!]{.highlight}

## Break!

```{python}
#| echo: false
#| eval: true

import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(figsize=(10, 8))

# Draw restaurant tables
tables = [(2, 6), (5, 6), (8, 6), (2, 3), (5, 3), (8, 3)]
for x, y in tables:
    rect = plt.Rectangle((x-0.5, y-0.5), 1, 0.8, 
                         facecolor='brown', edgecolor='black', linewidth=2)
    ax.add_patch(rect)

# Draw servers (dots moving between tables)
np.random.seed(567)
for _ in range(6):
    # Random path between tables
    start = tables[np.random.randint(len(tables))]
    end = tables[np.random.randint(len(tables))]
    
    # Create path
    t = np.linspace(0, 1, 20)
    x_path = start[0] + (end[0] - start[0]) * t + np.random.randn(20) * 0.1
    y_path = start[1] + (end[1] - start[1]) * t + np.random.randn(20) * 0.1
    
    ax.plot(x_path, y_path, alpha=0.3, color='blue')
    ax.scatter(x_path[-1], y_path[-1], s=50, color='blue', zorder=5)

# Add title
ax.text(5, 8.5, 'Restaurant Staffing Optimization', 
        fontsize=16, fontweight='bold', ha='center')
ax.text(5, 7.8, 'Who serves which tables when?', 
        fontsize=12, ha='center', style='italic')

# Add labels
ax.text(1, 1, 'Junior Servers: €25/hour', fontsize=10, color='blue')
ax.text(1, 0.5, 'Experienced: €75/hour', fontsize=10, color='red')
ax.text(6, 1, 'Challenge: Not enough\nexperienced servers!', fontsize=10, 
        bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.5))

ax.set_xlim(0, 10)
ax.set_ylim(0, 10)
ax.axis('off')
plt.tight_layout()
plt.show()
```

[Time to explore beyond greedy!]{.flow}