---
title: "Competition - Restaurant Staffing Crisis"
subtitle: "Management Science - La Étoile Three-Star Restaurant"
format:
  html:
    code-fold: true
    code-tools: true
---

## Client Briefing

**La Étoile**, our three-Michelin-star restaurant, faces a staffing crisis this weekend.

### The Situation
"I need to schedule my 18 servers across 6 shifts this weekend. The problem? My experienced servers cost €75/hour while juniors cost only €25/hour. But if I don't have enough experienced servers on busy shifts, service quality suffers and we get complaints - that damages our reputation!"

### The Challenge
You have **impossible constraints** - you need more experienced servers than you have available. Your job is to find the best compromise:
- Minimize total cost (labor + penalties)
- Decide which shifts to "sacrifice"
- Balance cost vs. service quality

### Your Resources
- 6 Experienced Servers (€75/hour)
- 12 Junior Servers (€25/hour)
- 6 Shifts to cover (3 servers each)
- Everyone works exactly one shift

## The Data

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from typing import Dict, List, Tuple

# Set seeds
np.random.seed(2025)
random.seed(2025)

# Server data
servers = pd.DataFrame({
    'Server_ID': [f'E{i:02d}' for i in range(1, 7)] + [f'J{i:02d}' for i in range(1, 13)],
    'Type': ['Experienced'] * 6 + ['Junior'] * 12,
    'Hourly_Rate': [75] * 6 + [25] * 12,
    'Name': ['Alice', 'Bob', 'Carlos', 'Diana', 'Elena', 'Frank'] + 
            [f'Junior_{i}' for i in range(1, 13)]
})

# Shift data
shifts = pd.DataFrame({
    'Shift_ID': ['FD', 'FL', 'SL', 'SD', 'UL', 'UD'],
    'Shift_Name': ['Friday Dinner', 'Friday Late', 'Saturday Lunch', 
                   'Saturday Dinner', 'Sunday Lunch', 'Sunday Dinner'],
    'Day': ['Friday', 'Friday', 'Saturday', 'Saturday', 'Sunday', 'Sunday'],
    'Time': ['18:00-22:00', '22:00-02:00', '12:00-16:00', 
             '18:00-22:00', '12:00-16:00', '18:00-22:00'],
    'Hours': [4, 4, 4, 4, 4, 4],
    'Required_Servers': [3, 3, 3, 3, 3, 3],
    'Min_Experienced': [2, 0, 1, 2, 1, 2],  # Requirements
    'Expected_Covers': [120, 40, 80, 140, 90, 130],  # Number of guests
    'Penalty_Per_Missing': [200, 0, 200, 200, 200, 200]  # € penalty for each missing experienced server
})

print("SERVERS AVAILABLE:")
print("=" * 60)
print(servers.to_string(index=False))

print("\n\nSHIFT REQUIREMENTS:")
print("=" * 60)
print(shifts.to_string(index=False))

print("\n\nTHE PROBLEM:")
print("=" * 60)
print(f"Total experienced servers needed: {shifts['Min_Experienced'].sum()}")
print(f"Total experienced servers available: {(servers['Type'] == 'Experienced').sum()}")
print(f"SHORTAGE: {shifts['Min_Experienced'].sum() - (servers['Type'] == 'Experienced').sum()} experienced servers!")
print("\n⚠️ You MUST accept some penalties - choose wisely!")
```

## Understanding the Costs

```{python}
# Visualize the requirements
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Shift requirements
ax = axes[0]
x = range(len(shifts))
width = 0.35
ax.bar([i - width/2 for i in x], shifts['Required_Servers'], width, 
       label='Total Needed', color='gray', alpha=0.7)
ax.bar([i + width/2 for i in x], shifts['Min_Experienced'], width,
       label='Experienced Needed', color='red', alpha=0.7)
ax.set_xlabel('Shift')
ax.set_ylabel('Number of Servers')
ax.set_title('Server Requirements by Shift')
ax.set_xticks(x)
ax.set_xticklabels(shifts['Shift_ID'])
ax.legend()
ax.axhline(y=6, color='green', linestyle='--', label='Available Experienced')
ax.grid(True, alpha=0.3)

# Expected covers (business volume)
ax = axes[1]
colors = ['red' if covers > 100 else 'orange' if covers > 60 else 'green' 
          for covers in shifts['Expected_Covers']]
bars = ax.bar(shifts['Shift_ID'], shifts['Expected_Covers'], color=colors, alpha=0.7)
ax.set_xlabel('Shift')
ax.set_ylabel('Expected Covers (Guests)')
ax.set_title('Business Volume by Shift')
ax.grid(True, alpha=0.3)

# Add value labels
for bar, val in zip(bars, shifts['Expected_Covers']):
    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 2,
           str(val), ha='center', va='bottom')

# Penalty structure
ax = axes[2]
penalties = shifts['Penalty_Per_Missing'].values
bars = ax.bar(shifts['Shift_ID'], penalties, color=['red' if p > 0 else 'green' for p in penalties], alpha=0.7)
ax.set_xlabel('Shift')
ax.set_ylabel('Penalty per Missing Experienced (€)')
ax.set_title('Understaffing Penalties')
ax.grid(True, alpha=0.3)

# Add annotations
for bar, val in zip(bars, penalties):
    if val > 0:
        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 5,
               f'€{val}', ha='center', va='bottom', fontweight='bold')

plt.tight_layout()
plt.show()
```

## Helper Functions

```{python}
def calculate_schedule_cost(schedule: Dict[str, List[str]], 
                           servers_df: pd.DataFrame, 
                           shifts_df: pd.DataFrame) -> Tuple[float, Dict]:
    """
    Calculate total cost of a schedule including labor and penalties.
    
    Returns:
        total_cost: Total cost in euros
        cost_breakdown: Dictionary with detailed cost breakdown
    """
    labor_cost = 0
    penalty_cost = 0
    violations = []
    
    for shift_idx, shift_row in shifts_df.iterrows():
        shift_id = shift_row['Shift_ID']
        
        if shift_id not in schedule:
            continue
            
        assigned_servers = schedule[shift_id]
        
        # Calculate labor cost for this shift
        for server_id in assigned_servers:
            server = servers_df[servers_df['Server_ID'] == server_id].iloc[0]
            labor_cost += server['Hourly_Rate'] * shift_row['Hours']
        
        # Check experienced server requirement
        experienced_count = sum(1 for sid in assigned_servers 
                               if servers_df[servers_df['Server_ID'] == sid].iloc[0]['Type'] == 'Experienced')
        
        shortage = max(0, shift_row['Min_Experienced'] - experienced_count)
        if shortage > 0:
            penalty = shortage * shift_row['Penalty_Per_Missing']
            penalty_cost += penalty
            violations.append({
                'shift': shift_row['Shift_Name'],
                'needed': shift_row['Min_Experienced'],
                'assigned': experienced_count,
                'shortage': shortage,
                'penalty': penalty
            })
    
    total_cost = labor_cost + penalty_cost
    
    cost_breakdown = {
        'labor_cost': labor_cost,
        'penalty_cost': penalty_cost,
        'total_cost': total_cost,
        'violations': violations
    }
    
    return total_cost, cost_breakdown

def validate_schedule(schedule: Dict[str, List[str]], 
                     servers_df: pd.DataFrame, 
                     shifts_df: pd.DataFrame) -> Tuple[bool, List[str]]:
    """
    Validate that a schedule meets all hard constraints.
    
    Returns:
        is_valid: Boolean indicating if schedule is valid
        errors: List of constraint violations
    """
    errors = []
    
    # Check each shift has exactly 3 servers
    for shift_row in shifts_df.itertuples():
        if shift_row.Shift_ID not in schedule:
            errors.append(f"Shift {shift_row.Shift_Name} has no assignment")
        elif len(schedule[shift_row.Shift_ID]) != shift_row.Required_Servers:
            errors.append(f"Shift {shift_row.Shift_Name} has {len(schedule[shift_row.Shift_ID])} servers, needs {shift_row.Required_Servers}")
    
    # Check each server works exactly once
    all_assignments = []
    for shift_servers in schedule.values():
        all_assignments.extend(shift_servers)
    
    server_counts = pd.Series(all_assignments).value_counts()
    
    # Check no duplicates
    for server_id, count in server_counts.items():
        if count > 1:
            errors.append(f"Server {server_id} assigned {count} times (should be 1)")
    
    # Check all servers are assigned
    all_server_ids = set(servers_df['Server_ID'])
    assigned_ids = set(all_assignments)
    
    if len(assigned_ids) != len(all_server_ids):
        missing = all_server_ids - assigned_ids
        if missing:
            errors.append(f"Servers not assigned: {', '.join(missing)}")
    
    is_valid = len(errors) == 0
    return is_valid, errors

def visualize_schedule(schedule: Dict[str, List[str]], 
                      servers_df: pd.DataFrame,
                      shifts_df: pd.DataFrame,
                      cost_breakdown: Dict):
    """Create a visual representation of the schedule."""
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    # 1. Schedule Grid
    ax = axes[0, 0]
    
    # Create schedule matrix
    schedule_matrix = np.zeros((len(servers_df), len(shifts_df)))
    
    for shift_idx, shift_row in shifts_df.iterrows():
        shift_id = shift_row['Shift_ID']
        if shift_id in schedule:
            for server_id in schedule[shift_id]:
                server_idx = servers_df[servers_df['Server_ID'] == server_id].index[0]
                schedule_matrix[server_idx, shift_idx] = 1
    
    # Color based on server type
    colors = []
    for server in servers_df.itertuples():
        if server.Type == 'Experienced':
            colors.append('red')
        else:
            colors.append('blue')
    
    # Plot
    im = ax.imshow(schedule_matrix, cmap='YlOrRd', aspect='auto')
    ax.set_xticks(range(len(shifts_df)))
    ax.set_xticklabels(shifts_df['Shift_ID'])
    ax.set_yticks(range(len(servers_df)))
    ax.set_yticklabels([f"{row.Server_ID} ({row.Type[0]})" for row in servers_df.itertuples()], 
                       fontsize=8)
    ax.set_xlabel('Shift')
    ax.set_ylabel('Server')
    ax.set_title('Schedule Assignment Matrix')
    
    # Add grid
    for i in range(len(servers_df) + 1):
        ax.axhline(i - 0.5, color='gray', linewidth=0.5)
    for i in range(len(shifts_df) + 1):
        ax.axvline(i - 0.5, color='gray', linewidth=0.5)
    
    # 2. Cost Breakdown
    ax = axes[0, 1]
    costs = {
        'Labor': cost_breakdown['labor_cost'],
        'Penalties': cost_breakdown['penalty_cost']
    }
    bars = ax.bar(costs.keys(), costs.values(), color=['green', 'red'], alpha=0.7)
    ax.set_ylabel('Cost (€)')
    ax.set_title(f"Total Cost: €{cost_breakdown['total_cost']:.2f}")
    
    for bar, val in zip(bars, costs.values()):
        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 10,
               f'€{val:.0f}', ha='center', va='bottom', fontweight='bold')
    
    # 3. Violations
    ax = axes[1, 0]
    if cost_breakdown['violations']:
        violations_df = pd.DataFrame(cost_breakdown['violations'])
        x = range(len(violations_df))
        ax.bar(x, violations_df['shortage'], color='red', alpha=0.7)
        ax.set_xticks(x)
        ax.set_xticklabels(violations_df['shift'], rotation=45, ha='right')
        ax.set_ylabel('Missing Experienced Servers')
        ax.set_title('Understaffing by Shift')
        ax.grid(True, alpha=0.3)
    else:
        ax.text(0.5, 0.5, 'No Violations!\n(All requirements met)', 
               ha='center', va='center', fontsize=14, color='green')
        ax.set_title('Violations')
    ax.axis('on')
    
    # 4. Server Type Distribution
    ax = axes[1, 1]
    shift_composition = []
    for shift_id in shifts_df['Shift_ID']:
        if shift_id in schedule:
            exp_count = sum(1 for sid in schedule[shift_id]
                          if servers_df[servers_df['Server_ID'] == sid].iloc[0]['Type'] == 'Experienced')
            jun_count = len(schedule[shift_id]) - exp_count
            shift_composition.append({'Shift': shift_id, 'Experienced': exp_count, 'Junior': jun_count})
    
    if shift_composition:
        comp_df = pd.DataFrame(shift_composition)
        x = range(len(comp_df))
        width = 0.35
        ax.bar([i - width/2 for i in x], comp_df['Experienced'], width, 
               label='Experienced', color='red', alpha=0.7)
        ax.bar([i + width/2 for i in x], comp_df['Junior'], width,
               label='Junior', color='blue', alpha=0.7)
        ax.set_xticks(x)
        ax.set_xticklabels(comp_df['Shift'])
        ax.set_ylabel('Number of Servers')
        ax.set_title('Staff Composition by Shift')
        ax.legend()
        ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

# Example: Test with a random valid schedule
def create_random_schedule(servers_df, shifts_df):
    """Create a random valid schedule for testing."""
    schedule = {}
    available_servers = list(servers_df['Server_ID'])
    random.shuffle(available_servers)
    
    server_idx = 0
    for shift_row in shifts_df.itertuples():
        schedule[shift_row.Shift_ID] = available_servers[server_idx:server_idx + shift_row.Required_Servers]
        server_idx += shift_row.Required_Servers
    
    return schedule

# Test the helper functions
test_schedule = create_random_schedule(servers, shifts)
test_cost, test_breakdown = calculate_schedule_cost(test_schedule, servers, shifts)
is_valid, errors = validate_schedule(test_schedule, servers, shifts)

print(f"\nRANDOM SCHEDULE TEST:")
print(f"Valid: {is_valid}")
print(f"Total Cost: €{test_cost:.2f}")
print(f"  - Labor: €{test_breakdown['labor_cost']:.2f}")
print(f"  - Penalties: €{test_breakdown['penalty_cost']:.2f}")
if test_breakdown['violations']:
    print(f"Violations: {len(test_breakdown['violations'])} shifts understaffed")
```

## Your Task

Design the optimal server schedule that minimizes total cost (labor + penalties).

### Approach Options

You can use ANY approach you prefer:

1. **Greedy Heuristic** - Design your own rules
2. **Local Search** - Start with greedy, improve with swaps
3. **Metaheuristics** - Use AI to implement SA, GA, etc.
4. **Hybrid** - Combine approaches
5. **Creative** - Surprise us!

### Starter Code - Greedy Approach

```{python}
def greedy_schedule(servers_df, shifts_df):
    """
    Greedy scheduling heuristic.
    Strategy: Assign experienced servers to high-penalty dinner shifts first.
    """
    schedule = {}
    assigned_servers = set()
    
    # Get server lists by type
    experienced = servers_df[servers_df['Type'] == 'Experienced']['Server_ID'].tolist()
    junior = servers_df[servers_df['Type'] == 'Junior']['Server_ID'].tolist()
    
    # Sort shifts by penalty (highest first) and expected covers
    shift_priority = shifts_df.sort_values(['Penalty_Per_Missing', 'Expected_Covers'], 
                                          ascending=[False, False])
    
    # YOUR CODE HERE
    # Implement your greedy strategy
    # Remember: Each shift needs exactly 3 servers, each server works once
    
    for _, shift in shift_priority.iterrows():
        shift_id = shift['Shift_ID']
        shift_servers = []
        
        # Try to meet experienced requirement
        exp_needed = min(shift['Min_Experienced'], len([e for e in experienced if e not in assigned_servers]))
        
        # Assign experienced servers
        for e in experienced:
            if e not in assigned_servers and len(shift_servers) < exp_needed:
                shift_servers.append(e)
                assigned_servers.add(e)
        
        # Fill remaining spots with junior servers
        remaining_spots = shift['Required_Servers'] - len(shift_servers)
        for j in junior:
            if j not in assigned_servers and remaining_spots > 0:
                shift_servers.append(j)
                assigned_servers.add(j)
                remaining_spots -= 1
        
        schedule[shift_id] = shift_servers
    
    return schedule

# Test greedy approach
greedy_result = greedy_schedule(servers, shifts)
greedy_cost, greedy_breakdown = calculate_schedule_cost(greedy_result, servers, shifts)

print("GREEDY SOLUTION:")
print("=" * 60)
for shift_id, staff in greedy_result.items():
    shift_name = shifts[shifts['Shift_ID'] == shift_id].iloc[0]['Shift_Name']
    print(f"{shift_name}: {', '.join(staff)}")

print(f"\nCost Analysis:")
print(f"  Labor Cost: €{greedy_breakdown['labor_cost']:.2f}")
print(f"  Penalty Cost: €{greedy_breakdown['penalty_cost']:.2f}")
print(f"  TOTAL COST: €{greedy_breakdown['total_cost']:.2f}")

if greedy_breakdown['violations']:
    print(f"\nViolations ({len(greedy_breakdown['violations'])} shifts):")
    for v in greedy_breakdown['violations']:
        print(f"  - {v['shift']}: {v['shortage']} experienced short (€{v['penalty']} penalty)")

visualize_schedule(greedy_result, servers, shifts, greedy_breakdown)
```

### AI-Assisted Metaheuristic Template

```{python}
# Template for using AI to implement metaheuristics

ai_prompt_template = """
I need to solve a restaurant staff scheduling problem using [ALGORITHM NAME].

PROBLEM DETAILS:
- 18 servers total: 6 experienced (€75/hour), 12 junior (€25/hour)
- 6 shifts, each needs exactly 3 servers
- Each server works exactly one 4-hour shift
- Some shifts need minimum experienced servers, but we don't have enough

CONSTRAINTS:
- Each shift: exactly 3 servers
- Each server: exactly 1 shift
- Experienced servers needed: [2, 0, 1, 2, 1, 2] for shifts
- Available experienced: only 6 (need 8 total)

OBJECTIVE:
Minimize: labor_cost + penalty_cost
- Penalty: €200 for each missing experienced server (except Friday Late)

Please provide:
1. Solution representation (how to encode a schedule)
2. Neighborhood/move function
3. Cost calculation
4. Main algorithm loop
5. Parameter recommendations

The schedule should be a dictionary: {shift_id: [list of 3 server_ids]}
"""

print("AI IMPLEMENTATION TEMPLATE")
print("=" * 60)
print(ai_prompt_template)
print("=" * 60)
print("\nReplace [ALGORITHM NAME] with:")
print("- 'simulated annealing' for SA")
print("- 'genetic algorithm' for GA")
print("- 'tabu search' for Tabu")
print("\nPaste this into ChatGPT or GitHub Copilot!")
```

## Your Solution

Implement your solution below:

```{python}
# YOUR SOLUTION CODE HERE

def my_scheduling_algorithm(servers_df, shifts_df):
    """
    Your scheduling algorithm implementation.
    Can be greedy, metaheuristic, or hybrid.
    """
    # YOUR CODE HERE
    
    # Example structure (replace with your approach):
    schedule = {}
    
    # ... your implementation ...
    
    # For now, returning the greedy solution as placeholder
    return greedy_schedule(servers_df, shifts_df)

# Run your solution
my_schedule = my_scheduling_algorithm(servers, shifts)
my_cost, my_breakdown = calculate_schedule_cost(my_schedule, servers, shifts)

# Validate
is_valid, validation_errors = validate_schedule(my_schedule, servers, shifts)

print("MY SOLUTION:")
print("=" * 60)
if not is_valid:
    print("⚠️ INVALID SCHEDULE:")
    for error in validation_errors:
        print(f"  - {error}")
else:
    print("✓ Valid Schedule")
    
print(f"\nTotal Cost: €{my_cost:.2f}")
print(f"  Labor: €{my_breakdown['labor_cost']:.2f}")
print(f"  Penalties: €{my_breakdown['penalty_cost']:.2f}")

print(f"\nImprovement over random: {(test_cost - my_cost)/test_cost*100:.1f}%")
print(f"Improvement over greedy: {(greedy_cost - my_cost)/greedy_cost*100:.1f}%")

# Visualize your solution
if is_valid:
    visualize_schedule(my_schedule, servers, shifts, my_breakdown)
```

## Competition Submission

Create your final submission:

```{python}
# Generate submission summary
submission = {
    'team_name': 'YOUR_TEAM_NAME',  # CHANGE THIS
    'approach': 'Greedy with improvements',  # DESCRIBE YOUR APPROACH
    'total_cost': my_cost,
    'labor_cost': my_breakdown['labor_cost'],
    'penalty_cost': my_breakdown['penalty_cost'],
    'violations': len(my_breakdown['violations']),
    'schedule': my_schedule
}

# Create executive summary slide
fig, axes = plt.subplots(2, 3, figsize=(16, 10))
fig.suptitle('RESTAURANT STAFFING SOLUTION - [YOUR TEAM NAME]', 
             fontsize=16, fontweight='bold', y=1.02)

# 1. Schedule Overview
ax = axes[0, 0]
ax.axis('off')
schedule_text = "SCHEDULE:\n" + "="*30 + "\n"
for shift_id in shifts['Shift_ID']:
    shift_name = shifts[shifts['Shift_ID'] == shift_id].iloc[0]['Shift_Name']
    if shift_id in my_schedule:
        exp_count = sum(1 for sid in my_schedule[shift_id]
                       if servers[servers['Server_ID'] == sid].iloc[0]['Type'] == 'Experienced')
        schedule_text += f"{shift_name}:\n  {exp_count}E + {3-exp_count}J\n"

ax.text(0.1, 0.5, schedule_text, fontsize=10, family='monospace',
       verticalalignment='center',
       bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.3))

# 2. Cost Breakdown
ax = axes[0, 1]
costs = [my_breakdown['labor_cost'], my_breakdown['penalty_cost']]
labels = ['Labor\nCost', 'Penalty\nCost']
colors = ['green', 'red'] if my_breakdown['penalty_cost'] > 0 else ['green', 'green']
bars = ax.bar(labels, costs, color=colors, alpha=0.7)
ax.set_ylabel('Cost (€)')
ax.set_title(f'Total Cost: €{my_cost:.2f}')

for bar, val in zip(bars, costs):
    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 20,
           f'€{val:.0f}', ha='center', va='bottom', fontweight='bold')

# 3. Comparison
ax = axes[0, 2]
comparison = {
    'Random': test_cost,
    'Greedy': greedy_cost,
    'Our Solution': my_cost
}
x = range(len(comparison))
colors = ['gray', 'orange', 'green']
bars = ax.bar(x, comparison.values(), color=colors, alpha=0.7)
ax.set_xticks(x)
ax.set_xticklabels(comparison.keys())
ax.set_ylabel('Total Cost (€)')
ax.set_title('Algorithm Comparison')

for bar, val in zip(bars, comparison.values()):
    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 20,
           f'€{val:.0f}', ha='center', va='bottom')

# 4. Violations Detail
ax = axes[1, 0]
if my_breakdown['violations']:
    violation_shifts = [v['shift'][:10] for v in my_breakdown['violations']]
    violation_costs = [v['penalty'] for v in my_breakdown['violations']]
    ax.barh(violation_shifts, violation_costs, color='red', alpha=0.7)
    ax.set_xlabel('Penalty Cost (€)')
    ax.set_title('Understaffing Penalties')
else:
    ax.text(0.5, 0.5, 'No Violations!', ha='center', va='center',
           fontsize=14, color='green', fontweight='bold')
    ax.set_title('Perfect Staffing!')
ax.grid(True, alpha=0.3)

# 5. Approach Description
ax = axes[1, 1]
ax.axis('off')
approach_text = f"""
APPROACH: {submission['approach']}
{'='*35}

Key Decisions:
• Prioritized high-penalty shifts
• Balanced cost vs quality
• Strategic penalty acceptance

Results:
• {(test_cost - my_cost)/test_cost*100:.1f}% better than random
• {(greedy_cost - my_cost)/greedy_cost*100:.1f}% better than greedy
• {submission['violations']} shifts understaffed
"""
ax.text(0.1, 0.5, approach_text, fontsize=10,
       verticalalignment='center',
       bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.3))

# 6. Key Metrics
ax = axes[1, 2]
ax.axis('off')
metrics_text = f"""
KEY METRICS
{'='*20}

Labor Cost:
€{my_breakdown['labor_cost']:.2f}

Penalty Cost:
€{my_breakdown['penalty_cost']:.2f}

Total Cost:
€{my_cost:.2f}

Cost per Cover:
€{my_cost / shifts['Expected_Covers'].sum():.2f}
"""
ax.text(0.1, 0.5, metrics_text, fontsize=11, fontweight='bold',
       verticalalignment='center',
       bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.3))

plt.tight_layout()
plt.show()

print("\n" + "="*60)
print("SUBMISSION READY!")
print("="*60)
print(f"Total Cost: €{submission['total_cost']:.2f}")
print(f"Approach: {submission['approach']}")
print("\nGood luck in the competition!")
```

## Evaluation Rubric

| Criterion | Points | What We Look For |
|-----------|--------|-------------------|
| **Solution Quality** | 40 | Lower total cost = more points |
| **Approach** | 30 | Smart strategy, good trade-offs |
| **Code Quality** | 20 | Clean, documented, correct |
| **Presentation** | 10 | Clear explanation of decisions |
| **Total** | 100 | |

### Tips for Success

1. **Understand the Trade-offs**
   - Is it better to pay penalties or higher wages?
   - Which shifts are most critical?

2. **Think Strategically**
   - Friday Late has no penalty - use junior servers!
   - Saturday Dinner is busiest - prioritize quality

3. **Try Multiple Approaches**
   - Start with greedy
   - Improve with local search
   - Consider metaheuristics if time allows

4. **Use AI Wisely**
   - Let AI help with implementation
   - But understand what it's doing
   - Verify the results make sense

5. **Document Your Logic**
   - Explain WHY you made certain choices
   - Show you understand the business impact

[Good luck! May the best schedule win!]{.highlight}