---
title: "Dealing with Uncertainty"
subtitle: "Lecture 4 - Management Science"
author: "Dr. Tobias Vlćek"
format:
  revealjs:
    footer: " {{< meta title >}} | {{< meta author >}} | [Home](lec_04_introduction.qmd)"
    output-file: lec_04_presentation.html
---

# [Quick Recap]{.flow} {.title}

## Quick Recap: Probability & Risk
[Use this slide to connect last lecture to today. Replace bullets for any lecture. Keep 2–3 items for cognitive load.]

- Expected value vs. realized outcomes — why averages can mislead when variance is high.
- Distributions as models of uncertainty (uniform, normal, etc.).
- [Prediction before demonstration]{.highlight}: Ask first, then reveal output. [. . . is your friend]

::: callout-tip
[Adaptation Tip:] Keep recaps short (3–5 minutes). Use [Question]{.question} to activate prior knowledge.
:::

. . .

[Transition:] Today we’ll “see” uncertainty by simulating many possible futures.

# [Introduction]{.flow} {.title}

## **[Client Briefing: TechVenture Innovation Fund]{.invert-font} {background-image="https://unsplash.com/photos/wgtJfd2Jhnk/download?ixid=M3wxMjA3fDB8MXxzZWFyY2h8MTF8fHNpbGljb24lMjB2YWxsZXl8ZW58MHx8fHwxNzYxMzM1MTMwfDA&force=true&w=2400" background-size="cover"}**

[Adaptation Tip:] Swap the background image to match your domain (e.g., healthcare, retail). Aim for high contrast or add `.invert-font`. If you use images elsewhere, add descriptive alt text in slide notes.

. . .

[The CEO's Problem:** "We have €2M to invest in **2 of 4 startups**. We can't predict the future. How do we make the best choice without just guessing?"]{.invert-font .fragment}

## The Business Challenge: Valuing Uncertainty

[Question]{.question}: **Why is this a hard problem for our client?** [. . .]

. . .

::: incremental
* **Point 1:** The real world is not certain. We don't know the *exact* return, only a *range* of possibilities (e.g., a bell curve).
* **Point 2:** A simple "guesstimate" (just using the average) is dangerous. It completely hides the **risk of failure**.
* **Point 3:** Our client needs to understand the **full spectrum of outcomes**, from the best case to the worst case.
:::

::: callout-warning
[Common Pitfall:] Optimizing on a single average outcome ignores tail risk. We need the distribution.
:::

[Adaptation Tip:] Rephrase “client” and “budget” for other lectures (e.g., staffing shifts, inventory levels, portfolio weights).

## Today: Monte Carlo Simulation

[We’re adding a tool to the toolkit. Keep this mapping as an anchor slide across lectures.]

| Problem                  | Tool                       |
| :----------------------- | :------------------------- |
| Repetitive Tasks         | Functions                  |
| Unstructured Data        | Dictionaries               |
| Tabular Data             | Pandas                     |
| **Business Uncertainty** | **Monte Carlo Simulation** |

. . .

[Adaptation Tip:] Update this table over the course as your toolbox grows (e.g., optimization, causal inference).

## Core Concept

[Rolling the Dice 10,000 Times]{.highlight}

[Question]{.question} If you roll two dice, what’s the chance of getting a 7? Think first. [. . .]

**How it works (Analogy):** You could compute combinations, **OR** you can simulate many rolls and count.

. . .

[Reveal:] **This is Monte Carlo Simulation.** We’ll do the same for startup returns.

## The Approach

1. **Model the Risk:** Instead of a die roll, we use `np.random.normal()` to model an uncertain variable (like daily_customers or investment_return).
2. **Simulate:** We run our model 10,000 times, getting 10,000 possible "futures."
3. **Analyze:** Look at the *distribution* of outcomes: mean, probability of loss, confidence ranges.

[Adaptation Tip:] Swap `np.random.normal` for other distributions as needed (e.g., `np.random.uniform`, `np.random.lognormal`) depending on your domain.

## The Logic (in 3 Steps)

::: panel-tabset

## Model the Risk

Define each startup's potential return not as one number, but as a distribution.

```{.python}
#| eval: false
#| echo: true
# Keep code examples <10 lines; show the one function that matters
import numpy as np
return_sample = np.random.normal(loc=0.25, scale=0.15)
```

## Run the Simulation

```{.python}
#| eval: false
#| echo: true
#| output-location: fragment
all_profits = []
for i in range(10_000):
    # "Roll the dice" for each startup
    # Calculate total profit for this one "future"
    # Store the result
    pass  # [Adaptation Tip:] Replace 'pass' with your domain calc
```

## Analyze the Results

```{.python}
#| eval: false
#| echo: true
#| output-location: fragment
# After collecting all_profits...
# Mean, Std, and simple risk metric
# all_profits = np.array(all_profits)
# all_profits.mean(), all_profits.std(), (all_profits < 0).mean()
```
:::

[Adaptation Tip:] Use `#| eval: false` for lecture-first walk-throughs; toggle on later when demoing. Use `#| output-location: fragment` to reveal the output after discussion.

## Example

[Key New Function:]{.highlight} `np.random.normal()`

* loc = The "center" or *average* (e.g., 25% return).
* scale = The "spread" or *standard deviation* (e.g., +/- 15%).
* size = How many "dice rolls" (e.g., 10,000).

```{.python}
#| eval: true
#| echo: true
#| output-location: fragment
import numpy as np

# Simulate 10,000 possible return scenarios for CloudAI
# Average return = 25% (0.25); Risk/StdDev = 15% (0.15)
returns_cloudai = np.random.normal(loc=0.25, scale=0.15, size=10_000)

# Quick sanity check (progressive reveal)
returns_cloudai.mean(), returns_cloudai.std()
```

[Prediction Question]{.question}: Before revealing output, what do you expect for mean and std? [. . .]

[Adaptation Tip:] For other lectures, swap the context (e.g., daily demand, processing times). Keep the exact same pattern.

## Interactive Check (Code-Based Question)

[Question]{.question}: What fraction of outcomes are negative (loss)? How would that change if `scale` doubles? [. . .]

```{.python}
#| eval: true
#| echo: true
#| output-location: fragment
risk_of_loss = (returns_cloudai < 0).mean()
risk_of_loss
```

::: callout-note
[Instructor Note:] Ask students for a verbal estimate before revealing code output.
:::

## Tip: Using GenAI for This

- GitHub Copilot is your **AI Pair Programmer**
- It's excellent at this!
- Don't ask it to "solve the problem."
- Ask it to "help with the tool."

. . .

[Question:]{.question} What would be a good prompt?

## Good Prompt

[You are the strategist:]{.highlight}

> I have a variable 'avg_purchase' that is a uniform distribution between $8 and $12. Write the numpy code to simulate this 10,000 times.

. . .

[Question:]{.question} What would be a bad prompt?

## Bad Prompt

[AI is the strategist:]{.highlight}

> Solve the TechVenture startup problem.

::: callout-tip
Your job is to **think**; let Copilot remember the exact syntax.  
[Adaptation Tip:] Encourage tool-use prompts that target one function or code idiom at a time.
:::

# Advanced: Necessary Techniques for Practice & Competition

[This section is required if students will work on the practice notebook or the competition. It contains techniques they’ll need later.]

## Portfolio Simulation: Choose 2 of 4

[Question]{.question}: If you must choose 2 of 4 startups, how many unique pairs are there and how would you compare them fairly? [. . .]

- Simulate each startup’s returns as distributions
- Enumerate all pairs
- Aggregate pair returns (e.g., equal-weight average)
- Compare by mean, probability of loss, and expected shortfall (worst 10%)

```{.python}
#| eval: false
#| echo: true
import numpy as np
# Example parameters (swap for your case)
means = np.array([0.22, 0.25, 0.28, 0.20])
stds  = np.array([0.10, 0.15, 0.20, 0.12])
n = 10_000

# Independent draws (no correlation; see next slide for correlated)
samples = [np.random.normal(m, s, size=n) for m, s in zip(means, stds)]

pairs = [(0,1), (0,2), (0,3), (1,2), (1,3), (2,3)]

def expected_shortfall(x, q=0.10):
    k = max(1, int(len(x) * q))
    return np.sort(x)[:k].mean()

# Sketch scoring (turn into a DataFrame later if desired)
scores = []
for i, j in pairs:
    portfolio = 0.5 * samples[i] + 0.5 * samples[j]
    scores.append({
        "pair": (i, j),
        "mean": portfolio.mean(),
        "p_loss": (portfolio < 0).mean(),
        "es_10": expected_shortfall(portfolio, 0.10),
    })
# [Adaptation Tip:] Present top-1 and trade-offs (mean vs. tail risk).
```

## Adding Correlation (When Risks Move Together)

[Question]{.question}: Why might independent simulations be misleading when market conditions affect all startups? [. . .]

- Use multivariate normals to model correlated shocks
- Same means/stds but with a covariance matrix

```{.python}
#| eval: false
#| echo: true
# Correlation matrix (example; replace with your estimates)
corr = np.array([
    [1.00, 0.30, 0.20, 0.10],
    [0.30, 1.00, 0.35, 0.15],
    [0.20, 0.35, 1.00, 0.25],
    [0.10, 0.15, 0.25, 1.00],
])
cov = np.outer(stds, stds) * corr

# Draw correlated samples (mean vector, covariance matrix)
mv_samples = np.random.multivariate_normal(mean=means, cov=cov, size=n)  # shape: (n, 4)

# Reuse the same pair loop, but now with correlated columns
# portfolio = 0.5 * mv_samples[:, i] + 0.5 * mv_samples[:, j]
```

::: callout-important
[Key Takeaway:] Correlation increases tail risk. A pair with the same mean may become less attractive once correlation is considered.
:::

## Choosing a Decision Rule

[Question]{.question}: Which metric aligns with a risk-aware investor: mean return, probability of loss, expected shortfall, or a weighted composite? Justify your choice. [. . .]

- Mean: central tendency, but can hide tails
- Probability of loss: intuitive downside likelihood
- Expected shortfall (ES10): depth of worst outcomes
- Composite: e.g., maximize mean − λ × ES10 (set λ by risk appetite)

[Adaptation Tip:] Keep one “default rule” across sessions for comparability; invite teams to argue for alternatives with evidence.

# [Your Mission for Today]{.flow} {.title}

[The Plan (Hour 2)]{.highlight}

1. **Hour 2: Basic Training (45 min)**
   1. **Goal:** Master the np.random tool.
   2. **Where:** Interactive Notebook below this lecture
   3. We will code-along to build a simple simulation for *one* coffee shop.

[Adaptation Tip:] This lecture (first hour) is concept-first. Hands-on practice starts in Hour 2. No tasks here; use code-based questions to keep engagement.

# [Your Mission for Today]{.flow} {.title}

[The Plan (Hour 3-4)]{.highlight}

2. **Hours 3-4: The Competition (80 min)**
   1. **Goal:** Solve the ["TechVenture Investment Challenge"]{.highlight}
   2. **Deliverable:** A 1-slide recommendation.
   3. **Your Pitch:** Which 2 startups should they fund and why?

. . .

3. **Presentations & Debrief (10 min)**
   2. Top 3 teams present their 1-slide pitch.
   3. **10 / 6 / 3 Bonus Points** are on the line.

. . .

[Adaptation Tip:] Replace “investment challenge” with a domain case (e.g., staffing plan, assortment selection). Keep the 1-slide constraint.

# Closing

::: callout-important
[Summary:]
- Monte Carlo = model uncertainty with distributions and simulate many futures.
- Decisions should consider the full distribution, not just the average.
- Risk metrics (probability of loss, expected shortfall) provide actionable insight.
- [Advanced section today is required] for later practice and competition.
:::

## Resources
- NumPy random sampling: https://numpy.org/doc/stable/reference/random/index.html
- Multivariate normals: https://numpy.org/doc/stable/reference/random/generated/numpy.random.multivariate_normal.html
- Monte Carlo simulation (overview): https://en.wikipedia.org/wiki/Monte_Carlo_method

[Adaptation Tip:] Keep a stable “Resources” slide across lectures; add 1–2 domain-specific links each time.

**Let's open the notebook and start building.**