[
  {
    "objectID": "assignments/assignment_02.html",
    "href": "assignments/assignment_02.html",
    "title": "Assignment 2: Optimization in Practice",
    "section": "",
    "text": "Due: Start of Lecture 10\nWeight: 30% of final grade\nExpected Time: 5-7 hours\nWork: Groups\n\nYour consulting firm has landed a major contract with CityExpress, a rapidly growing local delivery company. The CEO is concerned about rising operational costs and worker turnover. Your team has been tasked with:\n\nRoute Optimization: Reduce fuel costs by finding better delivery routes\nWorkforce Satisfaction: Improve worker retention by creating shift schedules that respect preferences",
    "crumbs": [
      "Assignments",
      "Assignment 02"
    ]
  },
  {
    "objectID": "assignments/assignment_02.html#assignment-overview",
    "href": "assignments/assignment_02.html#assignment-overview",
    "title": "Assignment 2: Optimization in Practice",
    "section": "",
    "text": "Due: Start of Lecture 10\nWeight: 30% of final grade\nExpected Time: 5-7 hours\nWork: Groups\n\nYour consulting firm has landed a major contract with CityExpress, a rapidly growing local delivery company. The CEO is concerned about rising operational costs and worker turnover. Your team has been tasked with:\n\nRoute Optimization: Reduce fuel costs by finding better delivery routes\nWorkforce Satisfaction: Improve worker retention by creating shift schedules that respect preferences",
    "crumbs": [
      "Assignments",
      "Assignment 02"
    ]
  },
  {
    "objectID": "assignments/assignment_02.html#consultants",
    "href": "assignments/assignment_02.html#consultants",
    "title": "Assignment 2: Optimization in Practice",
    "section": "Consultants",
    "text": "Consultants\nWho is part of your group?\n\n\"\"\"\nYOUR ANSWER HERE:\n\"\"\"",
    "crumbs": [
      "Assignments",
      "Assignment 02"
    ]
  },
  {
    "objectID": "assignments/assignment_02.html#setup",
    "href": "assignments/assignment_02.html#setup",
    "title": "Assignment 2: Optimization in Practice",
    "section": "Setup",
    "text": "Setup\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport math\n\n# Sets a random seed for reproducibility (CHANGE THIS HERE!!!)\ngroup_name = \"[THE NAMES OF YOUR GROUP MEMBERS HERE]\"\n# Convert string to integer for seeding\nseed = hash(group_name) % (2**31)\nnp.random.seed(seed)\n\n\n\n\n\n\n\nFill in the names of all the members of your group in group_name instead of [THE NAMES OF YOUR GROUP MEMBERS HERE]. If you don’t do so, you will maximally receive half of the points.",
    "crumbs": [
      "Assignments",
      "Assignment 02"
    ]
  },
  {
    "objectID": "assignments/assignment_02.html#part-a-route-optimization-50",
    "href": "assignments/assignment_02.html#part-a-route-optimization-50",
    "title": "Assignment 2: Optimization in Practice",
    "section": "Part A: Route Optimization (50%)",
    "text": "Part A: Route Optimization (50%)\n\nThe Challenge\nCityExpress currently plans routes manually. A driver mentioned: “I feel like I’m driving in circles sometimes.” The operations manager suspects they’re wasting 15-20% on inefficient routing.\nTomorrow’s schedule has 20 customer deliveries. Your job: build a route that minimizes total distance, starting and ending at the depot.\nImpact: If successful, this approach will be rolled out to all 50 daily routes.\n\n\nThe Data\n\n\n\n\n\n\nUnique Data Per Group: The customer locations below are randomly generated based on your group’s seed. Each group will get different customer coordinates within a 20km × 20km service area.\n\n\n\n\n# DON'T CHANGE ANYTHING BELOW!\n# Generate customer locations based on your group's seed\n# Each group gets unique locations within a 20km × 20km area\n\n# Depot is always at the center\nlocations = {0: (10, 10)}\n\n# Generate 20 customer locations randomly\nfor i in range(1, 21):\n    x = np.random.uniform(2, 18)  # Between 2-18 km\n    y = np.random.uniform(2, 18)  # Between 2-18 km\n    locations[i] = (x, y)\n\nprint(\"=\" * 60)\nprint(\"YOUR GROUP'S UNIQUE CUSTOMER LOCATIONS\")\nprint(\"=\" * 60)\nprint(f\"Depot: {locations[0]}\")\nprint(f\"\\nCustomer locations (x, y in km):\")\nfor i in range(1, 21):\n    print(f\"  Customer {i:2d}: ({locations[i][0]:5.2f}, {locations[i][1]:5.2f})\")\nprint(\"=\" * 60)\n# DON'T CHANGE ANYTHING ABOVE!\n\n============================================================\nYOUR GROUP'S UNIQUE CUSTOMER LOCATIONS\n============================================================\nDepot: (10, 10)\n\nCustomer locations (x, y in km):\n  Customer  1: (13.41,  9.32)\n  Customer  2: (14.55,  4.67)\n  Customer  3: (10.71, 14.47)\n  Customer  4: (11.27, 15.32)\n  Customer  5: (11.82,  5.73)\n  Customer  6: (11.10,  9.35)\n  Customer  7: ( 8.43, 16.45)\n  Customer  8: ( 3.11,  3.47)\n  Customer  9: ( 4.17, 13.23)\n  Customer 10: (13.95,  7.63)\n  Customer 11: ( 5.25, 17.15)\n  Customer 12: ( 5.53, 11.07)\n  Customer 13: ( 4.00, 12.05)\n  Customer 14: (13.19,  7.65)\n  Customer 15: (15.84,  7.10)\n  Customer 16: (11.44, 14.39)\n  Customer 17: ( 4.21, 10.32)\n  Customer 18: (10.28, 13.27)\n  Customer 19: ( 6.13,  8.54)\n  Customer 20: (13.24, 14.61)\n============================================================\n\n\n\n\nTask 1: Build an Initial Route (20%)\nUse the nearest neighbor heuristic to create a baseline route.\nThe approach:\n\nStart at the depot\nAt each step, visit the nearest unvisited customer\nReturn to depot when all customers are visited\n\nYour deliverable:\n\nImplement functions to calculate distances and build the route\nPrint the route and its total distance\n\n\n\n\n\n\n\nThe Euclidean distance formula is: \\(\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}\\)\n\n\n\n\n# Build your nearest neighbor route here\n# You'll need functions to:\n# 1. Calculate distance between two locations\n# 2. Calculate total route distance\n# 3. Build the route using nearest neighbor logic\n# YOUR CODE HERE\n\n\n\nTask 2: Improve the Route (20%)\nThe nearest neighbor heuristic is fast but rarely optimal. Use 2-opt local search to improve your route.\nHow 2-opt works: The algorithm removes two edges from your route and reconnects them in a different way, potentially “uncrossing” the route.\nBefore:  Depot → A → B → C → D → Depot\nAfter reversing segment between positions 1 and 3:\nAfter:   Depot → C → B → A → D → Depot\nThe approach:\n\nTry all possible ways to reverse segments of your route\nIf a reversal improves the distance, keep it\nRepeat until no improvement is possible\n\nYour deliverable:\n\nImplement 2-opt improvement\nShow the improved route and distance\nReport how many iterations it took to converge\n\n\n\n\n\n\n\nKeep the depot fixed at the start and end! Only reverse segments between customers.\n\n\n\n\n# Implement 2-opt improvement here\n# YOUR CODE HERE\n\n\n\nTask 3: Visualize and Quantify Impact (10%)\nThe CEO wants to see the difference visually and understand the cost savings.\nYour deliverable:\n\nVisualization: Plot both routes (before and after optimization) showing:\n\nCustomer locations\nRoute paths\nClear labels for depot and customers\n\nBusiness metrics:\n\nOriginal distance vs. improved distance\nPercentage improvement\nCost savings per delivery (assume €2/km fuel cost)\nProjected monthly savings if applied to all 50 daily routes\n\n\n\n# Create visualizations and calculate business impact\n# YOUR CODE HERE\n\nBusiness Question: Investment Recommendation\nBased on your analysis, prepare a formal recommendation to the CEO about investing in route optimization software.\n\n\"\"\"\nRECOMMENDATION TO CEO\n\nTo: CityExpress CEO\nFrom: [Your Consulting Team]\nRe: Route Optimization Software Investment Recommendation\n\nInvestment Decision: [Should we invest in route optimization software? Yes/No]\n\nCost-Benefit Analysis: [2-3 sentences quantifying the monthly and annual savings\npotential based on your results. Include specific numbers from your analysis.]\n\nImplementation Recommendations: [2-3 sentences on how to roll out this solution. Consider pilot testing, training needs, and timeline.]\n\nLimitations & Risk Mitigation: [2-3 sentences acknowledging limitations of the\n2-opt approach and suggesting how to address them]\n\nExpected ROI: [1-2 sentences on payback period and long-term value, considering\nsoftware costs versus fuel savings.]\n\"\"\"",
    "crumbs": [
      "Assignments",
      "Assignment 02"
    ]
  },
  {
    "objectID": "assignments/assignment_02.html#part-b-worker-shift-scheduling-50",
    "href": "assignments/assignment_02.html#part-b-worker-shift-scheduling-50",
    "title": "Assignment 2: Optimization in Practice",
    "section": "Part B: Worker Shift Scheduling (50%)",
    "text": "Part B: Worker Shift Scheduling (50%)\n\nThe Challenge\nCityExpress warehouse operates with 6 workers across 6 shifts per week. Recently, worker turnover has been high. Exit interviews reveal: “They never give me the shifts I want.”\nThe warehouse manager manually assigns shifts each week, often just assigning workers in order without considering preferences. Your job: create a better assignment system that maximizes worker satisfaction.\nImpact: Higher satisfaction could reduce the 30% annual turnover rate, saving thousands in recruiting and training costs.\n\n\nThe Data\n\n\n\n\n\n\nUnique Data Per Group: Worker shift preferences below are randomly generated based on your group’s seed. Each group will get different preference patterns while maintaining similar complexity (varying numbers of preferences per worker, overlapping demands).\n\n\n\n\n# DON'T CHANGE ANYTHING BELOW!\n# Available shifts for the week (14 shifts across 7 days, 2 per day)\nshifts = [\n    'Monday-Morning', 'Monday-Evening',\n    'Tuesday-Morning', 'Tuesday-Evening',\n    'Wednesday-Morning', 'Wednesday-Evening',\n    'Thursday-Morning', 'Thursday-Evening',\n    'Friday-Morning', 'Friday-Evening',\n    'Saturday-Morning', 'Saturday-Evening',\n    'Sunday-Morning', 'Sunday-Evening'\n]\n\n# Generate worker preferences randomly for your group\nworker_preferences = {}\nfor worker_id in range(14):\n    # Each worker gets 2-4 preferred shifts\n    num_prefs = np.random.randint(2, 5)\n    # Randomly select preferred shifts (without replacement)\n    preferred_indices = np.random.choice(14, size=num_prefs, replace=False)\n    worker_preferences[worker_id] = [shifts[i] for i in sorted(preferred_indices)]\n\nprint(\"=\" * 70)\nprint(\"YOUR GROUP'S UNIQUE WORKER SHIFT PREFERENCES\")\nprint(\"=\" * 70)\nfor worker_id, prefs in worker_preferences.items():\n    print(f\"Worker {worker_id:2d}: {prefs}\")\nprint(f\"\\nTotal preferences across all workers: {sum(len(p) for p in worker_preferences.values())}\")\nprint(f\"Average preferences per worker: {sum(len(p) for p in worker_preferences.values()) / 14:.1f}\")\nprint(\"=\" * 70)\n\n# Each worker works exactly ONE shift\n# Each shift must have exactly ONE worker\n# DON'T CHANGE ANYTHING ABOVE!\n\n======================================================================\nYOUR GROUP'S UNIQUE WORKER SHIFT PREFERENCES\n======================================================================\nWorker  0: ['Wednesday-Evening', 'Thursday-Morning']\nWorker  1: ['Wednesday-Morning', 'Friday-Evening']\nWorker  2: ['Wednesday-Morning', 'Thursday-Evening', 'Sunday-Evening']\nWorker  3: ['Thursday-Evening', 'Friday-Evening']\nWorker  4: ['Tuesday-Morning', 'Tuesday-Evening', 'Wednesday-Morning', 'Sunday-Morning']\nWorker  5: ['Monday-Evening', 'Wednesday-Morning', 'Thursday-Morning', 'Sunday-Evening']\nWorker  6: ['Monday-Evening', 'Sunday-Evening']\nWorker  7: ['Thursday-Morning', 'Sunday-Morning']\nWorker  8: ['Wednesday-Evening', 'Saturday-Evening']\nWorker  9: ['Monday-Evening', 'Tuesday-Morning']\nWorker 10: ['Monday-Evening', 'Tuesday-Morning', 'Thursday-Evening', 'Saturday-Morning']\nWorker 11: ['Wednesday-Evening', 'Saturday-Evening', 'Sunday-Evening']\nWorker 12: ['Monday-Morning', 'Monday-Evening', 'Wednesday-Evening', 'Thursday-Evening']\nWorker 13: ['Thursday-Morning', 'Friday-Evening']\n\nTotal preferences across all workers: 38\nAverage preferences per worker: 2.7\n======================================================================\n\n\n\n\n\n\n\n\nAssignment representation: Use a list where assignment[worker_id] = shift_index\nExample: [0, 3, 1, 13, 2, 5, ...] means:\n\nWorker 0 → shift 0 (Monday-Morning)\nWorker 1 → shift 3 (Tuesday-Evening)\nWorker 2 → shift 1 (Monday-Evening)\nWorker 3 → shift 13 (Sunday-Evening)\netc.\n\n\n\n\n\n\nTask 1: Design a Greedy Assignment Strategy (15%)\nRemember greedy heuristics from Lecture 6 (SPT, EDD)? Design your own greedy rule for shift assignment.\nThink about:\n\nSPT prioritized shortest jobs\nEDD prioritized earliest deadlines\nWhat should YOU prioritize? Worker flexibility? Number of preferences? Something else?\n\nYour deliverable:\n\nImplement a function that creates a valid assignment using YOUR greedy strategy\nPrint the assignment (who gets which shift)\nWrite 3-4 sentences explaining:\n\nWhat attribute you chose to prioritize\nWhy this makes sense\nHow it relates to scheduling heuristics from Lecture 6\n\n\n\n# Implement your greedy assignment strategy\n# Must produce a valid assignment (all workers assigned, no duplicate shifts)\n# YOUR CODE HERE\n\n\n\"\"\"\nYOUR EXPLANATION HERE:\nMy greedy strategy: [what did you prioritize?]\nReasoning: [why does this make sense?]\nConnection to Lecture 6: [how does this relate to SPT/EDD/other heuristics?]\n\"\"\"\n\n\n\nTask 2: Measure Assignment Quality (15%)\nYou need a way to measure how “good” an assignment is. Design a satisfaction scoring system.\nDesign questions:\n\nShould 1st choice be worth more than 2nd choice? How much more?\nWhat if a worker gets a shift they didn’t list?\nShould some workers count more than others?\n\nYour deliverable:\n\nImplement a satisfaction calculation function\nCalculate the satisfaction score for your greedy assignment\nWrite 2-3 sentences explaining:\n\nYour scoring system design\nWhy you chose this approach\n\n\n\n# Implement satisfaction calculation\n# YOUR CODE HERE\n\n\n\"\"\"\nYOUR EXPLANATION HERE:\nMy scoring system: [how do you calculate satisfaction?]\nReasoning: [why this approach?]\n\"\"\"\n\n\n\nTask 3: Improve with Local Search (15%)\nYour greedy solution is probably not optimal. Use local search (like 2-opt from Part A) to improve it.\nThe approach:\n\nTry swapping shifts between pairs of workers\nIf a swap improves satisfaction, keep it\nRepeat until no improvement is found\n\nYour deliverable:\n\nImplement local search improvement\nShow before/after satisfaction scores\nCreate a visualization comparing the solutions (table or chart)\nWrite 3-4 sentences explaining:\n\nHow much you improved the greedy solution\nWhether you think you found the optimal solution\nWhat limitations local search might have\n\n\n\n# Implement local search improvement\n# YOUR CODE HERE\n\n\n# Visualize the improvement\n# YOUR CODE HERE\n\n\n\"\"\"\nYOUR EXPLANATION HERE:\nResults: [how much improvement?]\nOptimality: [did you reach the best possible solution? how do you know?]\nLimitations: [what are the downsides of local search?]\n\"\"\"\n\n\n\nTask 4: Business Recommendations & Contingency Planning (5%)\nBusiness Question 1: Emergency Coverage Protocol\nA critical situation has emerged: Worker 2 calls in sick 10 minutes before their shift. Prepare an emergency response to the warehouse manager.\n\n\"\"\"\nEMERGENCY COVERAGE\n\nTo: Warehouse Manager\nFrom: [Your Consulting Team]\nRe: Emergency Shift Coverage Protocol - Worker Absence\n\nImmediate Action Plan: [2-3 sentences]\n\nDecision Framework: [2-3 sentences]\n\nFuture System Adaptation: [2-3 sentences]\n\n\"\"\"\n\nBusiness Question 2: Strategic Workforce Management Analysis\nThe warehouse manager is skeptical: “This is too complicated. I just need bodies in shifts. I don’t care about preferences.” Prepare a strategic analysis comparing approaches.\n\n\"\"\"\nSTRATEGIC ANALYSIS\n\nTo: Warehouse Manager\nFrom: [Your Consulting Team]\nRe: Cost-Benefit Analysis of Worker Preference System\n\nCurrent Approach (Random Assignment):\n- Advantages: [2-3 sentences]\n- Hidden Costs: [2-3 sentences]\n\nProposed Approach (Preference-Based):\n- Implementation Costs: [2-3 sentences]\n- Expected Benefits: [2-3 sentences]\n\nROI Calculation: [2-3 sentences]\n\nRecommendation: [1-2 sentences with your final recommendation based on your\nquantitative analysis above.]\n\"\"\"",
    "crumbs": [
      "Assignments",
      "Assignment 02"
    ]
  },
  {
    "objectID": "assignments/assignment_02.html#submission-checklist",
    "href": "assignments/assignment_02.html#submission-checklist",
    "title": "Assignment 2: Optimization in Practice",
    "section": "Submission Checklist",
    "text": "Submission Checklist\n\nAll code cells run without errors\nPart A: Routes visualized and business impact calculated\nPart B: All three methods implemented (greedy, evaluation, local search)\nAll written explanations completed with business context\nCode is clean and understandable\nGroup member names listed at top",
    "crumbs": [
      "Assignments",
      "Assignment 02"
    ]
  },
  {
    "objectID": "assignments/assignment_02.html#tips",
    "href": "assignments/assignment_02.html#tips",
    "title": "Assignment 2: Optimization in Practice",
    "section": "Tips",
    "text": "Tips\n\nUse AI tools to help you understand concepts and write code, but make sure YOU understand the logic\nStart simple - get a basic version working before adding complexity\nTest incrementally - don’t write all functions at once\nExperiment - there’s no single “correct” greedy strategy or scoring system\nThink like a consultant - your audience is business stakeholders, not just programmers",
    "crumbs": [
      "Assignments",
      "Assignment 02"
    ]
  },
  {
    "objectID": "assignments/assignment_00.html",
    "href": "assignments/assignment_00.html",
    "title": "Assignments in this Course",
    "section": "",
    "text": "This course uses two practical assignments to help you learn how to think like an optimization-minded analyst. Your focus throughout should be: understand the problem, design a sensible algorithmic approach, interpret results, and translate findings into clear business recommendations. Perfect code is not the goal, insight is.\n\n\n\n\n\n\nYou’re encouraged to use AI tools responsibly. Treat them like a smart pair-programmer that helps you learn and debug, but make sure you understand all code you submit and can explain it. You are fully responsible for the correctness and originality of submitted work, regardless of gAI use.\n\n\n\n\n\n\n\n\n\nDo not include gAI-generated meta-comments describing what gAI changed. Thus, keep comments focused on explaining the code itself. If I find instances of such gAI meta-comments, you will loose points for the technical implementation. Keep your comments clean and relevant.\n\n\n\n\n\n\n\n\n\ngAI may hallucinate additional features that are not required. Be careful here!",
    "crumbs": [
      "Assignments",
      "Introduction"
    ]
  },
  {
    "objectID": "assignments/assignment_00.html#welcome",
    "href": "assignments/assignment_00.html#welcome",
    "title": "Assignments in this Course",
    "section": "",
    "text": "This course uses two practical assignments to help you learn how to think like an optimization-minded analyst. Your focus throughout should be: understand the problem, design a sensible algorithmic approach, interpret results, and translate findings into clear business recommendations. Perfect code is not the goal, insight is.\n\n\n\n\n\n\nYou’re encouraged to use AI tools responsibly. Treat them like a smart pair-programmer that helps you learn and debug, but make sure you understand all code you submit and can explain it. You are fully responsible for the correctness and originality of submitted work, regardless of gAI use.\n\n\n\n\n\n\n\n\n\nDo not include gAI-generated meta-comments describing what gAI changed. Thus, keep comments focused on explaining the code itself. If I find instances of such gAI meta-comments, you will loose points for the technical implementation. Keep your comments clean and relevant.\n\n\n\n\n\n\n\n\n\ngAI may hallucinate additional features that are not required. Be careful here!",
    "crumbs": [
      "Assignments",
      "Introduction"
    ]
  },
  {
    "objectID": "assignments/assignment_00.html#the-two-assignments",
    "href": "assignments/assignment_00.html#the-two-assignments",
    "title": "Assignments in this Course",
    "section": "The Two Assignments",
    "text": "The Two Assignments\nAssignment 1: Risk Analysis & Forecasting (Due at the start of Lecture 8, weight 30%)\nYou’ll simulate investment outcomes to understand risk and then forecast demand using simple time-series techniques. Expect to implement Monte Carlo simulations, moving averages, and exponential smoothing, then compare methods and justify a recommendation.\nAssignment 2: Optimization in Practice (Due at the start of Lecture 10, weight 30%)\nYou’ll build and improve delivery routes and construct valid staff schedules under constraints, then iterate to improve quality and satisfaction. Expect to implement heuristics, evaluate improvements, visualize routes/schedules, and discuss trade-offs.\nWork is in groups for both assignments. Typical time commitment is 4–6 hours for Assignment 1 and 5–7 hours for Assignment 2.",
    "crumbs": [
      "Assignments",
      "Introduction"
    ]
  },
  {
    "objectID": "assignments/assignment_00.html#how-youll-be-graded",
    "href": "assignments/assignment_00.html#how-youll-be-graded",
    "title": "Assignments in this Course",
    "section": "How You’ll Be Graded",
    "text": "How You’ll Be Graded\n\nTechnical Implementation (60% of assignment grade)\n\nExcellent (90-100%): Code runs correctly, handles edge cases, well-structured\nGood (80-89%): Code runs with minor issues, mostly well-structured\nSatisfactory (70-79%): Code runs but has some problems, basic structure\nNeeds Improvement (60-69%): Code has significant issues but shows understanding\nInadequate (&lt;60%): Code doesn’t run or shows fundamental misunderstanding\n\n\n\nBusiness Insight (20% of assignment grade)\n\nExcellent: Clear actionable recommendations with quantified impact\nGood: Solid insights with some quantification\nSatisfactory: Basic insights communicated clearly\nNeeds Improvement: Insights unclear or not business-relevant\nInadequate: No meaningful insights provided\n\n\n\nPresentation Quality (20% of assignment grade)\n\nExcellent: Compelling visualizations, clear narrative\nGood: Good visuals, mostly clear communication\nSatisfactory: Basic visualizations, understandable presentation\nNeeds Improvement: Poor visuals or unclear communication\nInadequate: No effective communication of results\n\n\n\n\n\n\n\nUse AI to clarify concepts, explore alternatives, and debug. Please, do not submit code you don’t understand. You’re responsible for every line. If you draw from external sources, cite them briefly in your notebook.",
    "crumbs": [
      "Assignments",
      "Introduction"
    ]
  },
  {
    "objectID": "assignments/assignment_00.html#tips-for-success",
    "href": "assignments/assignment_00.html#tips-for-success",
    "title": "Assignments in this Course",
    "section": "Tips for Success",
    "text": "Tips for Success\n\nStart simple, then iterate. Get a working baseline first.\nCheck your logic with small tests and intermediate prints.\nKeep business questions in view—your job is to inform a decision.\n\n\n\n\n\n\n\nCommon pitfalls to watch for: forgetting return-to-depot in routing, violating constraints after a change, optimizing forever instead of delivering “good enough,” and failing to actually answer the business questions.",
    "crumbs": [
      "Assignments",
      "Introduction"
    ]
  },
  {
    "objectID": "assignments/assignment_00.html#submission-requirements",
    "href": "assignments/assignment_00.html#submission-requirements",
    "title": "Assignments in this Course",
    "section": "Submission Requirements",
    "text": "Submission Requirements\nSubmit one Jupyter notebook per assignment that includes:\n\nYour commented code with outputs and clear visualizations.\nShort, direct answers to the business questions.\n\nFile naming:\n\nAssignment 1: Assignment_01_[GroupNames].ipynb\nAssignment 2: Assignment_02_[GroupNames].ipynb",
    "crumbs": [
      "Assignments",
      "Introduction"
    ]
  },
  {
    "objectID": "assignments/assignment_00.html#late-policy",
    "href": "assignments/assignment_00.html#late-policy",
    "title": "Assignments in this Course",
    "section": "Late Policy",
    "text": "Late Policy\nSubmissions lose 10% per day late, up to a maximum of three days. Exceptions are granted only for documented emergencies.",
    "crumbs": [
      "Assignments",
      "Introduction"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html",
    "href": "tutorials/nb_08_01_multi_objective.html",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "",
    "text": "Welcome back to Bean Counter! As CEO, you’re facing a critical decision: which new coffee product should we add to our menu in more than thousand locations?\nUnlike previous decisions where we optimized a single metric (like minimizing delivery distance), today we’ll learn to balance multiple competing objectives simultaneously. Specifically, we want to:\n\nMaximize profit margin (more revenue per cup)\nMinimize preparation time (faster service, more customers)\n\nBut there’s a problem: the most profitable drinks take longest to prepare! This is called a trade-off, and it’s at the heart of real-world decision-making.\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nWork through each section in order. Write code where marked “YOUR CODE BELOW” and verify with the provided assertions. This prepares you for the competition challenge!",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#introduction",
    "href": "tutorials/nb_08_01_multi_objective.html#introduction",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "",
    "text": "Welcome back to Bean Counter! As CEO, you’re facing a critical decision: which new coffee product should we add to our menu in more than thousand locations?\nUnlike previous decisions where we optimized a single metric (like minimizing delivery distance), today we’ll learn to balance multiple competing objectives simultaneously. Specifically, we want to:\n\nMaximize profit margin (more revenue per cup)\nMinimize preparation time (faster service, more customers)\n\nBut there’s a problem: the most profitable drinks take longest to prepare! This is called a trade-off, and it’s at the heart of real-world decision-making.\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nWork through each section in order. Write code where marked “YOUR CODE BELOW” and verify with the provided assertions. This prepares you for the competition challenge!",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#product-data",
    "href": "tutorials/nb_08_01_multi_objective.html#product-data",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Product Data",
    "text": "Product Data\nBean Counter’s R&D team has developed potential new products. Each has been evaluated on multiple criteria:\n\n# Product specifications\nproducts = pd.DataFrame({\n    'Product': ['Butterfly Lemonade', 'Ube Purple Latte', 'Tiger Nut Tea', \n                'Saffron Rose Milk', 'Moringa Mint Cooler', 'Black Sesame Frappé', \n                'Sakura Cherry Coffee', 'Blue Spirulina Smoothie', 'Charcoal Detox Shot', \n                'Pandan Coconut Cream', 'Lavender Honey Foam', 'Dragon Fruit Frappé',\n                'Cascara Coffee Cherry', 'Nitro Matcha Float'],\n    'Profit_Margin': [3.8, 4.1, 2.5, 4.3, 2.9, 3.5, 4.5, 3.2,\n                      1.8, 3.6, 3.7, 4.8, 2.1, 3.4],  # € per unit\n    'Prep_Time': [200, 240, 90, 270, 150, 210, 280, 180,\n                  60, 220, 190, 300, 100, 140],  # seconds\n    'Sustainability': [65, 40, 80, 55, 85, 62, 35, 60,\n                       45, 68, 59, 50, 82, 78]  # score 0-100\n})\n\nprint(\"Available Products:\")\nprint(products.to_string(index=False))\n\nAvailable Products:\n                Product  Profit_Margin  Prep_Time  Sustainability\n     Butterfly Lemonade            3.8        200              65\n       Ube Purple Latte            4.1        240              40\n          Tiger Nut Tea            2.5         90              80\n      Saffron Rose Milk            4.3        270              55\n    Moringa Mint Cooler            2.9        150              85\n    Black Sesame Frappé            3.5        210              62\n   Sakura Cherry Coffee            4.5        280              35\nBlue Spirulina Smoothie            3.2        180              60\n    Charcoal Detox Shot            1.8         60              45\n   Pandan Coconut Cream            3.6        220              68\n    Lavender Honey Foam            3.7        190              59\n    Dragon Fruit Frappé            4.8        300              50\n  Cascara Coffee Cherry            2.1        100              82\n     Nitro Matcha Float            3.4        140              78\n\n\n\n\n\n\n\n\nTipThe Core Trade-off\n\n\n\nNotice the fundamental conflict:\n\nSakura Cherry Coffee: Highest profit (€4.5) but slowest to make (280s!)\nCharcoal Detox Shot: Fastest (60s = 1 minute) but lowest profit (€1.8)\n\nWe can’t have both maximum profit AND minimum prep time. We must choose a trade-off.",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#exercise-1.1-visualize-the-profit-speed-trade-off",
    "href": "tutorials/nb_08_01_multi_objective.html#exercise-1.1-visualize-the-profit-speed-trade-off",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Exercise 1.1: Visualize the Profit-Speed Trade-off",
    "text": "Exercise 1.1: Visualize the Profit-Speed Trade-off\nCreate a scatter plot to see this trade-off visually.\n\n\n\n\n\n\nNoteCreating a Scatter Plot\n\n\n\nplt.figure(figsize=(10, 6))          # Create figure\nplt.scatter(x, y, s=size, alpha=0.7) # Plot points\nplt.annotate(label, (x, y), ...)     # Label each point\nplt.xlabel('X Label')                # Axis labels\nplt.ylabel('Y Label')\nplt.grid(True, alpha=0.3)            # Add grid\n\n\n\n\n\n\n\n\nNoteBefore You Start\n\n\n\n\nX-axis: Profit Margin (want to maximize → move right)\nY-axis: Prep Time (want to minimize → move down)\nBest corner: Lower-right (high profit, low time)\nUse a for-loop to annotate all products\n\n\n\n\n# YOUR CODE BELOW\n# Create a scatter plot: Profit (x) vs Prep Time (y)\n# Annotate each point with the product name",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#exercise-2.1-implement-dominance-check",
    "href": "tutorials/nb_08_01_multi_objective.html#exercise-2.1-implement-dominance-check",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Exercise 2.1: Implement Dominance Check",
    "text": "Exercise 2.1: Implement Dominance Check\nWrite a function to check if a product is dominated by any other product.\n\n\n\n\n\n\nNoteBefore You Start\n\n\n\n\nCompare the current product with ALL other products\nFor our objectives:\n\nProfit: higher is better (maximize)\nPrep Time: lower is better (minimize)\n\nReturn True if ANY product dominates the current one\n\n\n\n\ndef is_dominated(product_idx: int, products_df: pd.DataFrame) -&gt; bool:\n    \"\"\"\n    Check if a product at product_idx is dominated by any other product.\n    \n    Returns True if dominated, False otherwise.\n    \"\"\"\n    current = products_df.iloc[product_idx]\n    \n    # YOUR CODE BELOW\n    # Loop through all products and check if any dominates current\n    # Dominance: other has &gt;= profit AND &lt;= prep_time, with at least one strict &lt; or &gt;\n    \n    \n    return False\n\n\n# Test your function with the following\ndominated = []\nfor i in range(len(products)):\n    if is_dominated(i, products):\n        dominated.append(products.iloc[i]['Product'])\n\nprint(f\"Dominated products: {dominated}\")\n\n\n\nCode\n# Test your implementation\nassert 'is_dominated' in dir(), \"Define the is_dominated function\"\nassert len(dominated) &gt;= 5, \"Should find five dominated products\"\nassert 'Moringa Mint Cooler' in dominated, \"Chai Tea should be dominated (lower profit, slower than alternatives)\"\nprint(f\"Excellent! Found {len(dominated)} dominated products\")\nprint(\"These should NEVER be chosen - better alternatives exist!\")",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#exercise-2.2-find-the-pareto-frontier",
    "href": "tutorials/nb_08_01_multi_objective.html#exercise-2.2-find-the-pareto-frontier",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Exercise 2.2: Find the Pareto Frontier",
    "text": "Exercise 2.2: Find the Pareto Frontier\nThe Pareto frontier contains all non-dominated solutions - the only rational choices.\n\n\n\n\n\n\nTipWhat is the Pareto Frontier?\n\n\n\nThe Pareto frontier (or Pareto set) is the set of ALL non-dominated solutions.\nWhy it matters: These are the ONLY products worth considering. Every point on the frontier represents a different trade-off, and none is strictly better than the others.\nIn the competition, you’ll use this exact concept to find optimal fleet compositions!\n\n\n\n\n\n\n\n\nNoteBefore You Start\n\n\n\n\nCreate a boolean array is_pareto (all True initially)\nFor each product i, check if ANY product j dominates it\nIf dominated, set is_pareto[i] = False\nReturn only products where is_pareto is True\n\n\n\n\ndef find_pareto_frontier(products_df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Find all non-dominated products (Pareto frontier).\n    \n    Returns DataFrame with only Pareto optimal products.\n    \"\"\"\n    n = len(products_df)\n    is_pareto = np.ones(n, dtype=bool)\n    \n    # YOUR CODE BELOW\n    # For each product i, check if any product j dominates it\n    \n    \n    return products_df[is_pareto]\n\n\n# Find and display Pareto frontier based on your function\npareto_products = find_pareto_frontier(products)\nprint(f\"\\nPareto Frontier ({len(pareto_products)} products):\")\nprint(pareto_products[['Product', 'Profit_Margin', 'Prep_Time']].to_string(index=False))\n\n\n\nCode\n# Test your Pareto frontier function\nassert 'find_pareto_frontier' in dir(), \"Define find_pareto_frontier function\"\nassert len(pareto_products) &gt;= 3, \"Should find at least 3 Pareto optimal products\"\nassert 'Saffron Rose Milk' in pareto_products['Product'].values, \"Saffron Rose Milk (fastest) should be on frontier\"\nprint(\"Perfect! These are the ONLY products worth considering\")",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#visualizing-the-pareto-frontier",
    "href": "tutorials/nb_08_01_multi_objective.html#visualizing-the-pareto-frontier",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Visualizing the Pareto Frontier",
    "text": "Visualizing the Pareto Frontier\nLet’s plot the Pareto frontier to see it clearly:\n\n# Visualize Pareto frontier\nplt.figure(figsize=(10, 6))\n\n# Plot all products\nplt.scatter(products['Profit_Margin'], products['Prep_Time'], \n            alpha=0.3, color='gray', label='Dominated')\n\n# Highlight Pareto frontier\npareto_idx = pareto_products.index\nplt.scatter(products.loc[pareto_idx, 'Profit_Margin'], \n           products.loc[pareto_idx, 'Prep_Time'],\n           alpha=0.5, color='red', \n           label='Pareto Frontier', zorder=5)\n\n# Annotate Pareto products\nfor idx in pareto_idx:\n    plt.annotate(products.loc[idx, 'Product'],\n                (products.loc[idx, 'Profit_Margin'], products.loc[idx, 'Prep_Time']),\n                fontsize=10, va='bottom')\n\nplt.xlabel('Profit Margin (€)', fontsize=12)\nplt.ylabel('Preparation Time (seconds)', fontsize=12)\nplt.title('Pareto Frontier: Non-Dominated Products', fontsize=14, fontweight='bold')\nplt.legend(fontsize=11)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nTipInterpreting the Pareto Frontier\n\n\n\nEach point on the frontier represents a different trade-off:\n\nClassic Espresso (left): Fastest prep, lowest profit → “Speed Strategy”\nEnergy Smoothie (right): Highest profit, slowest prep → “Profit Strategy”\nMiddle products: Balanced compromises\n\nNone dominates the others - your choice depends on your priorities!",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#exercise-3.1-normalize-objectives",
    "href": "tutorials/nb_08_01_multi_objective.html#exercise-3.1-normalize-objectives",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Exercise 3.1: Normalize Objectives",
    "text": "Exercise 3.1: Normalize Objectives\nNormalize both objectives to [0, 1] scale.\n\n\n\n\n\n\nNoteWhat is a pandas Series?\n\n\n\nA pandas Series is like a single column from a DataFrame:\nproducts['Profit_Margin']  # This is a Series (one column)\n\nHas built-in methods: .min(), .max(), .mean()\nSupports arithmetic: series - 5, series * 2\nReturns a new Series when you do math on it\n\n\n\n\n\n\n\n\n\nNoteMin-Max Normalization Formula\n\n\n\nnormalized_value = (value - min_value) / (max_value - min_value)\n\nMinimum value → 0\nMaximum value → 1\nPreserves relative distances\n\n\n\n\ndef normalize_column(series: pd.Series) -&gt; pd.Series:\n    \"\"\"Normalize a pandas Series to [0, 1] range.\"\"\"\n    # YOUR CODE BELOW\n    # Hint: series.min() and series.max() give you the min/max values\n\n\n# Normalize objectives with your new normalize_column function\nproducts_norm = products.copy()\nproducts_norm['Profit_Norm'] = normalize_column(products['Profit_Margin'])\nproducts_norm['Prep_Norm'] = normalize_column(products['Prep_Time'])\nprint(\"Normalized values:\")\nprint(products_norm[['Product', 'Profit_Norm', 'Prep_Norm']].to_string(index=False))\n\n\n\nCode\n# Test normalization\nassert 'normalize_column' in dir(), \"Define normalize_column function\"\nassert products_norm['Profit_Norm'].min() &gt;= 0, \"Min should be &gt;= 0\"\nassert products_norm['Profit_Norm'].max() &lt;= 1, \"Max should be &lt;= 1\"\nassert abs(products_norm['Profit_Norm'].max() - 1.0) &lt; 0.01, \"Max should be exactly 1.0\"\nprint(\"Perfect! Objectives are now on the same scale [0, 1]\")",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#exercise-3.2-calculate-weighted-score",
    "href": "tutorials/nb_08_01_multi_objective.html#exercise-3.2-calculate-weighted-score",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Exercise 3.2: Calculate Weighted Score",
    "text": "Exercise 3.2: Calculate Weighted Score\nNow combine the normalized objectives using weights.\n\n\n\n\n\n\nTipWeighted Sum Method\n\n\n\nScore = w_profit × profit + w_speed × speed\nWhere weights sum to 1.0 (representing 100% of priorities).\n\n\n\n\n\n\n\n\nWe want to MINIMIZE prep time, so use (1 - prep_norm) to flip it in the weighted score!\n\n\n\n\ndef calculate_score(profit_norm, prep_norm, w_profit, w_speed):\n    \"\"\"Calculate weighted score. Higher is better.\"\"\"\n    # YOUR CODE BELOW\n    # Remember: minimize prep time means use (1 - prep_norm)\n\n\n# Test different weight scenarios with your new function\nscenarios = {\n    'Profit Focus': {'w_profit': 0.7, 'w_speed': 0.3},\n    'Balanced': {'w_profit': 0.5, 'w_speed': 0.5},\n    'Speed Focus': {'w_profit': 0.3, 'w_speed': 0.7}\n}\n\nresults = []\nfor name, weights in scenarios.items():\n    products_norm['Score'] = calculate_score(\n        products_norm['Profit_Norm'], \n        products_norm['Prep_Norm'],\n        weights['w_profit'], \n        weights['w_speed']\n    )\n    best_idx = products_norm['Score'].idxmax()\n    results.append({\n        'Scenario': name,\n        'Best Product': products.loc[best_idx, 'Product'],\n        'Score': products_norm.loc[best_idx, 'Score']\n    })\n\nresults_df = pd.DataFrame(results)\nprint(\"\\nBest product for each scenario:\")\nprint(results_df.to_string(index=False))\n\n\n\nCode\n# Test weighted scoring\nassert 'calculate_score' in dir(), \"Define calculate_score function\"\nassert len(results_df) == 3, \"Should have 3 scenarios\"\nassert all(results_df['Score'] &gt; 0), \"All scores should be positive\"\nassert all(results_df['Score'] &lt;= 1), \"All scores should be &lt;= 1\"\nprint(\"Excellent! Different weights lead to different optimal products\")",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#exercise-4.1-filter-by-sustainability-constraint",
    "href": "tutorials/nb_08_01_multi_objective.html#exercise-4.1-filter-by-sustainability-constraint",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Exercise 4.1: Filter by Sustainability Constraint",
    "text": "Exercise 4.1: Filter by Sustainability Constraint\nFilter products to only those meeting the sustainability requirement.\n\n# YOUR CODE BELOW\n# Filter products where Sustainability &gt;= 60\nsustainability_threshold = 60\nfeasible_products = # YOUR CODE HERE\n\nprint(f\"\\nFeasible products (sustainability &gt;= {sustainability_threshold}):\")\nprint(feasible_products[['Product', 'Profit_Margin', 'Prep_Time', 'Sustainability']].to_string(index=False))\n\n\n\nCode\n# Test constraint filtering\nassert 'feasible_products' in dir(), \"Create feasible_products variable\"\nassert len(feasible_products) &gt;= 9, \"Should have at least nine feasible products\"\nassert all(feasible_products['Sustainability'] &gt;= 60), \"All products should meet constraint\"\nprint(f\"✓ Great! {len(feasible_products)} products meet the sustainability requirement\")",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#exercise-4.2-pareto-frontier-with-constraints",
    "href": "tutorials/nb_08_01_multi_objective.html#exercise-4.2-pareto-frontier-with-constraints",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Exercise 4.2: Pareto Frontier with Constraints",
    "text": "Exercise 4.2: Pareto Frontier with Constraints\nFind the Pareto frontier AMONG only the feasible products.\n\n# YOUR CODE BELOW\n# Apply find_pareto_frontier to feasible_products only\nconstrained_pareto = # YOUR CODE HERE\n\nprint(f\"\\nConstrained Pareto Frontier ({len(constrained_pareto)} products):\")\nprint(constrained_pareto[['Product', 'Profit_Margin', 'Prep_Time', 'Sustainability']].to_string(index=False))\n\n\n\nCode\n# Test constrained Pareto frontier\nassert 'constrained_pareto' in dir(), \"Create constrained_pareto variable\"\nassert len(constrained_pareto) &lt;= len(feasible_products), \"Pareto set should be &lt;= feasible set\"\nassert all(constrained_pareto['Sustainability'] &gt;= 60), \"All should meet constraint\"\nprint(\"Perfect! This is your constrained Pareto frontier\")\nprint(\"These are the ONLY rational choices given the sustainability requirement\")",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#visualizing-constraints-and-pareto-frontier",
    "href": "tutorials/nb_08_01_multi_objective.html#visualizing-constraints-and-pareto-frontier",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Visualizing Constraints and Pareto Frontier",
    "text": "Visualizing Constraints and Pareto Frontier\n\n# Visualize feasible region and Pareto frontier\nplt.figure(figsize=(10, 6))\n\n# Plot infeasible products\ninfeasible = products[products['Sustainability'] &lt; 60]\nif len(infeasible) &gt; 0:\n    plt.scatter(infeasible['Profit_Margin'], infeasible['Prep_Time'],\n               alpha=0.3, color='red', marker='x', label='Infeasible')\n\n# Plot feasible but dominated\nfeasible_dominated = feasible_products[~feasible_products.index.isin(constrained_pareto.index)]\nif len(feasible_dominated) &gt; 0:\n    plt.scatter(feasible_dominated['Profit_Margin'], feasible_dominated['Prep_Time'],\n               alpha=0.4, color='gray', label='Feasible (dominated)')\n\n# Plot constrained Pareto frontier\nplt.scatter(constrained_pareto['Profit_Margin'], constrained_pareto['Prep_Time'],\n        alpha=0.9, color='green',\n           label='Constrained Pareto Frontier', zorder=5)\n\nfor idx in constrained_pareto.index:\n    plt.annotate(products.loc[idx, 'Product'],\n                (products.loc[idx, 'Profit_Margin'], products.loc[idx, 'Prep_Time']),\n                fontsize=10, va='bottom')\n\nplt.xlabel('Profit Margin (€)', fontsize=12)\nplt.ylabel('Preparation Time (seconds)', fontsize=12)\nplt.title('Constrained Pareto Frontier (Sustainability ≥ 60)', fontsize=14, fontweight='bold')\nplt.legend(fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#exercise-4.3-choose-the-best-product-with-weighted-scoring",
    "href": "tutorials/nb_08_01_multi_objective.html#exercise-4.3-choose-the-best-product-with-weighted-scoring",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Exercise 4.3: Choose the Best Product with Weighted Scoring",
    "text": "Exercise 4.3: Choose the Best Product with Weighted Scoring\nNow that we have the constrained Pareto frontier, let’s use weighted scoring to select the final product.\n\n\n\n\n\n\nNoteBefore You Start\n\n\n\n\nNormalize the constrained Pareto products (not all products!)\nApply your calculate_score function\nFind the product with the highest score\nUse weights: 60% profit, 40% speed (w_profit=0.6, w_speed=0.4)\n\n\n\n\n# YOUR CODE BELOW\n# 1. Normalize the constrained Pareto products\nconstrained_norm = constrained_pareto.copy()\nconstrained_norm['Profit_Norm'] = # YOUR CODE HERE\nconstrained_norm['Prep_Norm'] = # YOUR CODE HERE\n\n# 2. Calculate weighted scores (60% profit, 40% speed)\nconstrained_norm['Score'] = # YOUR CODE HERE\n\n# 3. Find the best product\nbest_idx = # YOUR CODE HERE\nbest_product = products.loc[best_idx]\n\nprint(f\"\\nRECOMMENDED PRODUCT: {best_product['Product']}\")\nprint(f\"  Profit Margin: €{best_product['Profit_Margin']:.2f}\")\nprint(f\"  Prep Time: {best_product['Prep_Time']:.0f}s\")\nprint(f\"  Sustainability: {best_product['Sustainability']:.0f}\")\nprint(f\"  Weighted Score: {constrained_norm.loc[best_idx, 'Score']:.3f}\")\n\n\n\nCode\n# Test your final selection\nassert 'constrained_norm' in dir(), \"Create constrained_norm DataFrame\"\nassert 'Score' in constrained_norm.columns, \"Calculate Score column\"\nassert 'best_idx' in dir(), \"Find best_idx\"\nassert best_product['Sustainability'] &gt;= 60, \"Best product must meet constraint\"\nprint(\"Excellent! You've completed the full optimization workflow!\")",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#key-takeaways",
    "href": "tutorials/nb_08_01_multi_objective.html#key-takeaways",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nTrade-offs are inevitable when optimizing multiple objectives\nDominated solutions should never be chosen\nPareto frontier contains all rational choices\nNormalization is critical before combining objectives\nWeighted sums let you express priorities\nHard constraints limit the feasible region\nConstrained Pareto frontier = intersection of Pareto set and feasible region",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_08_01_multi_objective.html#whats-next",
    "href": "tutorials/nb_08_01_multi_objective.html#whats-next",
    "title": "Notebook 8.1 - Multi-Objective Optimization",
    "section": "What’s Next?",
    "text": "What’s Next?\nIn the competition, you’ll apply these concepts to design EcoExpress’s sustainable delivery fleet:\n\n2 objectives: Minimize total cost, Maximize service score\n1 constraint: CO2 emissions ≤ 111 g/km\nYour task: Generate fleet alternatives, find Pareto frontier, recommend the best one\nDeliverable: One-slide visualization showing your analysis\n\nGood luck!",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-01 Pareto"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html",
    "href": "tutorials/nb_07_01_local_search.html",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "",
    "text": "Welcome back, CEO! Bean Counter has grown to up to 10 franchise locations across some cities, and you personally want to optimize the weekly coffee bean deliveries in all cities. Currently, delivery trucks just follow a random route. Time to optimize!\nThe Delivery Challenge:\n\nOne truck leaves from Bean Counter HQ in a city\nMust deliver coffee beans to all 10 franchises\nEach franchise needs their specific blend\nFuel costs €1.50 per km\nDriver costs €30 per hour\n\nYour board calculated that poor routing costs Bean Counter €2,500 monthly in excess fuel and labor. Let’s fix this!\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nWork through each section in order. Write code where marked “YOUR CODE BELOW” and verify with the provided assertions. This prepares you for the competition challenge!\n\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom itertools import combinations\nimport math\n\nprint(\"Libraries loaded! Let's optimize Bean Counter's deliveries.\")\n\nLibraries loaded! Let's optimize Bean Counter's deliveries.",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#bean-counters-franchise-locations",
    "href": "tutorials/nb_07_01_local_search.html#bean-counters-franchise-locations",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Bean Counter’s Franchise Locations",
    "text": "Bean Counter’s Franchise Locations\n\n# Set random seed for reproducibility\nnp.random.seed(876)\n\n# Generate franchise locations (x, y coordinates in km)\nn_franchises = 10\n\n# Bean Counter HQ at city center\nhq_location = (2, 3)\n\n# Generate 10 franchise locations randomly in a 10x10 km area\nfranchise_locations = []\nfor i in range(n_franchises):\n    x = np.random.uniform(0.5, 9.5)\n    y = np.random.uniform(0.5, 9.5)\n    franchise_locations.append((x, y))\n\nfranchise_names = [\n    \"North District\", \"Northeast Corner\", \"East Side\", \"Southeast\",\n    \"South Quarter\", \"Southwest\", \"West End\", \"North Central\",\n    \"City Center East\", \"Inner West\"\n]\n\nprint(f\"Bean Counter HQ: {hq_location}\")\nprint(f\"Number of franchises: {len(franchise_locations)}\")\nprint(f\"Total possible routes: {math.factorial(n_franchises):,}\")\n\nBean Counter HQ: (2, 3)\nNumber of franchises: 10\nTotal possible routes: 3,628,800",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-1.1---calculate-distance-between-two-points",
    "href": "tutorials/nb_07_01_local_search.html#exercise-1.1---calculate-distance-between-two-points",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 1.1 - Calculate Distance Between Two Points",
    "text": "Exercise 1.1 - Calculate Distance Between Two Points\nFirst, let’s implement the distance calculation using the Euclidean distance formula.\n\n\n\n\n\n\nTipThe Euclidean Distance Formula\n\n\n\nThe Euclidean distance between points \\((x_1, y_1)\\) and \\((x_2, y_2)\\) is: \\[d = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\\]\nExample: Distance from (0, 0) to (3, 4) \\[d = \\sqrt{(3-0)^2 + (4-0)^2} = \\sqrt{9 + 16} = \\sqrt{25} = 5\\]\n\n\n\n\n\n\n\n\nNoteWorking with Tuples\n\n\n\nA tuple is a collection of values in parentheses: point = (x, y)\n# Unpacking tuple values\npoint1 = (5, 5)\nx1, y1 = point1  # x1 = 5, y1 = 5\n\n# Or access by index\nx1 = point1[0]   # First element\ny1 = point1[1]   # Second element\n\n\n\n# YOUR CODE BELOW\ndef calculate_distance(point1, point2):\n    \"\"\"\n    Calculate Euclidean distance between two points.\n\n    Args:\n        point1: Tuple (x, y) for first location\n        point2: Tuple (x, y) for second location\n\n    Returns:\n        Distance in km\n    \"\"\"\n    # Step 1: Extract x and y coordinates from both points\n    \n    # Step 2: Calculate differences and apply distance formula\n    \n    pass  # Remove this and implement\n\n\n\nCode\n# Don't modify below - these test your solution\n# Test 1: Known distance (3-4-5 triangle)\ntest_dist = calculate_distance((0, 0), (3, 4))\nassert abs(test_dist - 5.0) &lt; 0.001, f\"Distance should be 5.0, got {test_dist}\"\n\n# Test 2: Distance to same point should be zero\nsame_point = calculate_distance(hq_location, hq_location)\nassert abs(same_point) &lt; 0.001, f\"Distance to same point should be 0, got {same_point}\"\n\n# Test 3: Distance should be positive for different points\nhq_to_first = calculate_distance(hq_location, franchise_locations[0])\nassert hq_to_first &gt; 0, f\"Distance should be positive, got {hq_to_first:.2f}\"\n\n# Test 4: Distance should be symmetric\ndist_a_to_b = calculate_distance(hq_location, franchise_locations[0])\ndist_b_to_a = calculate_distance(franchise_locations[0], hq_location)\nassert abs(dist_a_to_b - dist_b_to_a) &lt; 0.001, \"Distance should be symmetric\"\n\nprint(\"✓ Distance calculation correct!\")\nprint(f\"HQ to first franchise: {hq_to_first:.2f} km\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-1.2---create-distance-matrix",
    "href": "tutorials/nb_07_01_local_search.html#exercise-1.2---create-distance-matrix",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 1.2 - Create Distance Matrix",
    "text": "Exercise 1.2 - Create Distance Matrix\nNow create a matrix of all distances between locations (HQ and franchises).\n\n\n\n\n\n\nTipWhat is a Distance Matrix?\n\n\n\nA distance matrix stores all pairwise distances in a 2D array:\n\n\n\n\nHQ\nF1\nF2\nF3\n\n\n\n\nHQ\n0\n3.2\n5.1\n4.0\n\n\nF1\n3.2\n0\n2.8\n6.1\n\n\nF2\n5.1\n2.8\n0\n3.9\n\n\nF3\n4.0\n6.1\n3.9\n0\n\n\n\ndistances[0][1] = distance from HQ to Franchise 1 = 3.2 km\n\n\n\n\n\n\n\n\nNoteNested Loops for Matrices\n\n\n\nUse nested for loops to fill a 2D array:\n# Create 3x3 matrix\nmatrix = np.zeros((3, 3))\n\n# Fill it with nested loops\nfor i in range(3):      # Rows\n    for j in range(3):  # Columns\n        matrix[i][j] = i + j\n\n# Result: [[0, 1, 2],\n#          [1, 2, 3],\n#          [2, 3, 4]]\n\n\n\n# YOUR CODE BELOW\ndef create_distance_matrix(hq_location, franchise_locations):\n    \"\"\"\n    Create a distance matrix for all locations.\n\n    Args:\n        hq_location: Tuple (x, y) for HQ\n        franchise_locations: List of tuples for franchises\n\n    Returns:\n        2D numpy array where element [i][j] is distance from location i to j\n        Index 0 is HQ, indices 1-10 are franchises\n    \"\"\"\n    all_locations = [hq_location] + franchise_locations\n    n = len(all_locations)\n\n    # Create empty matrix\n    distances = np.zeros((n, n))\n\n    # Fill the matrix using nested loops\n    # Hint: Use your calculate_distance function!\n    # Remember: distance from i to i should be 0\n    # YOUR CODE HERE\n\n    return distances\n\n\n\nCode\n# Don't modify below - these test your solution\nassert distance_matrix.shape == (11, 11), \"Matrix should be 11x11 (HQ + 10 franchises)\"\nassert np.all(np.diag(distance_matrix) == 0), \"Diagonal should be zeros (distance to self)\"\nassert np.allclose(distance_matrix, distance_matrix.T), \"Matrix should be symmetric\"\nassert distance_matrix[0, 1] &gt; 0, \"HQ to first franchise distance check\"\nassert np.mean(distance_matrix[distance_matrix &gt; 0]) &gt; 3.5, \"Average distance between locations check\"\n\nprint(\"✓ Distance matrix created successfully!\")\nprint(f\"Average distance between locations: {np.mean(distance_matrix[distance_matrix &gt; 0]):.2f} km\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#understanding-nearest-neighbor",
    "href": "tutorials/nb_07_01_local_search.html#understanding-nearest-neighbor",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Understanding Nearest Neighbor",
    "text": "Understanding Nearest Neighbor\nThe algorithm is simple but effective:\n\nStart at HQ\nFind the nearest unvisited franchise\nGo there and deliver\nRepeat until all visited\nReturn to HQ\n\n\n# Visualize Bean Counter's delivery network\nplt.figure(figsize=(10, 8))\n\n# Plot franchises\nx_coords = [loc[0] for loc in franchise_locations]\ny_coords = [loc[1] for loc in franchise_locations]\nplt.scatter(x_coords, y_coords, c='#537E8F', s=500, zorder=3)\n\n# Plot HQ\nplt.scatter(hq_location[0], hq_location[1], c='#D73502', s=500,\n           marker='s', zorder=3)\n\n# Add labels\nfor i, (x, y) in enumerate(franchise_locations):\n    plt.annotate(f'F{i+1}', (x, y), ha='center', va='center',\n                color='white', fontweight='bold')\nplt.annotate('HQ', hq_location, ha='center', va='center',\n            color='white', fontweight='bold', fontsize=12)\n\nplt.xlabel('Distance East-West (km)')\nplt.ylabel('Distance North-South (km)')\nplt.title(\"Bean Counter's Franchise Network\", fontsize=14, fontweight='bold')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-2.1---implement-nearest-neighbor",
    "href": "tutorials/nb_07_01_local_search.html#exercise-2.1---implement-nearest-neighbor",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 2.1 - Implement Nearest Neighbor",
    "text": "Exercise 2.1 - Implement Nearest Neighbor\nBuild a route using the nearest neighbor heuristic.\n\n\n\n\n\n\nTipThe min() Function with key Parameter\n\n\n\nFind the minimum based on a custom criterion:\n# Find smallest number\nnumbers = [5, 2, 8, 1]\nsmallest = min(numbers)  # 1\n\n# Find shortest word\nwords = [\"hello\", \"hi\", \"hey\"]\nshortest = min(words, key=len)  # \"hi\"\n\n# Find franchise with minimum distance\nunvisited = [1, 2, 3]\ndistances_from_hq = [5.2, 3.1, 7.8]\nnearest = min(unvisited, key=lambda i: distances_from_hq[i-1])  # 2\nThe key=lambda i: ... tells Python how to compare items.\n\n\n\n\n\n\n\n\nNoteList Operations You’ll Need\n\n\n\n# Add to list\nroute.append(5)         # route = [1, 2, 3, 5]\n\n# Remove from list\nunvisited.remove(5)     # Removes value 5\n\n# Check if list is empty\nwhile unvisited:        # Loops while list has items\n    # do something\n\n\n\n# YOUR CODE BELOW\ndef nearest_neighbor_route(distance_matrix):\n    \"\"\"\n    Build a delivery route using nearest neighbor algorithm.\n\n    Args:\n        distance_matrix: 2D array of distances (index 0 is HQ)\n\n    Returns:\n        List of franchise indices in visit order (not including HQ)\n    \"\"\"\n    n_locations = len(distance_matrix)\n    unvisited = list(range(1, n_locations))  # Franchise indices (skip 0 which is HQ)\n    route = []\n    current = 0  # Start at HQ\n\n    while unvisited:\n        # Step 1: Find nearest unvisited franchise using min()\n        # Hint: key=lambda i: distance_matrix[current, i]\n        \n        # Step 2: Add it to the route\n        \n        # Step 3: Remove from unvisited\n        \n        # Step 4: Update current location\n        \n        pass  # Remove this\n\n    return route\n\n\n\nCode\n# Don't modify below - these test your solution\nassert len(initial_route) == 10, \"Route should visit all 10 franchises\"\nassert len(set(initial_route)) == 10, \"Each franchise should be visited exactly once\"\nassert all(1 &lt;= f &lt;= 10 for f in initial_route), \"Route should contain franchise indices 1-10\"\nprint(\"✓ Nearest neighbor route constructed!\")\nprint(f\"Visit order: {initial_route}\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-2.2---calculate-total-route-distance",
    "href": "tutorials/nb_07_01_local_search.html#exercise-2.2---calculate-total-route-distance",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 2.2 - Calculate Total Route Distance",
    "text": "Exercise 2.2 - Calculate Total Route Distance\nCalculate the total distance for a complete delivery route (HQ → Franchises → HQ).\n\n# YOUR CODE BELOW\ndef calculate_route_distance(route, distance_matrix):\n    \"\"\"\n    Calculate total distance for a delivery route.\n\n    Args:\n        route: List of franchise indices in visit order\n        distance_matrix: 2D array of distances\n\n    Returns:\n        Total distance in km\n    \"\"\"\n    total_distance = 0\n\n    # Add distance from HQ to first franchise\n    # YOUR CODE HERE\n\n    # Add distances between consecutive franchises\n    # YOUR CODE HERE\n\n    # Add distance from last franchise back to HQ\n    # YOUR CODE HERE\n\n    return total_distance\n\n\n\nCode\n# Don't modify below - these test your solution\n# Test 1: Partial route should have positive distance\ntest_route = [1, 2, 3]\ntest_dist = calculate_route_distance(test_route, distance_matrix)\nassert test_dist &gt; 0, \"Distance should be positive\"\n\n# Test 2: Full route distance should be reasonable (not too small, not too large)\nfull_dist = calculate_route_distance(initial_route, distance_matrix)\nassert full_dist &gt; 10, f\"Total distance too small, check if return trip included: {full_dist:.2f} km\"\nassert full_dist &lt; 150, f\"Total distance too large, check calculation: {full_dist:.2f} km\"\n\n# Test 3: Full route should be longer than partial route\nassert full_dist &gt; test_dist, \"Full route should be longer than partial route\"\n\nprint(f\"✓ Route distance calculation correct!\")\nprint(f\"Nearest neighbor route: {full_dist:.2f} km\")\nprint(f\"Fuel cost: €{full_dist * 1.5:.2f}\")\nprint(f\"Time estimate: {full_dist / 30:.1f} hours at 30 km/h average\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#understanding-2-opt-swaps",
    "href": "tutorials/nb_07_01_local_search.html#understanding-2-opt-swaps",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Understanding 2-Opt Swaps",
    "text": "Understanding 2-Opt Swaps\n2-opt looks for crossing paths in the route and uncrosses them:\n\nplt.figure(figsize=(10, 8))\n\n# Create route coordinates for plotting\nroute_coords = [hq_location]\nfor idx in initial_route:\n    route_coords.append(franchise_locations[idx - 1])\nroute_coords.append(hq_location)\n\n# Plot route\nroute_x = [coord[0] for coord in route_coords]\nroute_y = [coord[1] for coord in route_coords]\nplt.plot(route_x, route_y, 'o-', color='#A0A0A0', linewidth=2,\n         markersize=0, alpha=0.7, label='Delivery Route')\n\n# Plot locations\nplt.scatter(x_coords, y_coords, c='#537E8F', s=500, zorder=3)\nplt.scatter(hq_location[0], hq_location[1], c='#D73502', s=500,\n           marker='s', zorder=3)\n\n# Add labels\nfor i, (x, y) in enumerate(franchise_locations):\n    plt.annotate(f'F{i+1}', (x, y), ha='center', va='center',\n                color='white', fontweight='bold')\nplt.annotate('HQ', hq_location, ha='center', va='center',\n            color='white', fontweight='bold', fontsize=12)\n\nplt.xlabel('Distance East-West (km)')\nplt.ylabel('Distance North-South (km)')\nplt.title(f'Initial Route: {initial_distance:.1f} km', fontsize=14, fontweight='bold')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-3.1---implement-2-opt-swap",
    "href": "tutorials/nb_07_01_local_search.html#exercise-3.1---implement-2-opt-swap",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 3.1 - Implement 2-Opt Swap",
    "text": "Exercise 3.1 - Implement 2-Opt Swap\nImplement the logic to perform a 2-opt swap on a route.\n\n\n\n\n\n\nTipWhat Does 2-Opt Do?\n\n\n\nA 2-opt swap reverses a segment of the route to eliminate crossings:\n\nBefore: Route = [1, 2, 3, 4, 5, 6]\n\nSwap(1, 4): Reverse segment from position 2 to 4\n\nAfter: Route = [1, 2, 5, 4, 3, 6]\n\nThis uncrosses paths and usually reduces total distance!\n\n\n\n\n\n\n\n\nNoteList Slicing and Reversal\n\n\n\nroute = [1, 2, 3, 4, 5, 6]\n\n# Slice: get part of list\nroute[:3]        # [1, 2, 3] - start to index 3\nroute[3:]        # [4, 5, 6] - index 3 to end\nroute[2:5]       # [3, 4, 5] - index 2 to 5\n\n# Reverse: [::-1]\nroute[2:5][::-1] # [5, 4, 3] - reversed segment\n\n# Combine slices\nroute[:2] + route[2:5][::-1] + route[5:]\n# [1, 2] + [5, 4, 3] + [6] = [1, 2, 5, 4, 3, 6]\n\n\n\n# YOUR CODE BELOW\ndef perform_2opt_swap(route, i, j):\n    \"\"\"\n    Perform a 2-opt swap on a route.\n\n    Args:\n        route: Current route (list of indices)\n        i: First position for swap\n        j: Second position for swap (j &gt; i)\n\n    Returns:\n        New route with the swap applied\n    \"\"\"\n    # Create new route: beginning + reversed_middle + end\n    # route[:i+1] keeps elements from start to i (inclusive)\n    # route[i+1:j+1][::-1] reverses segment from i+1 to j\n    # route[j+1:] keeps elements after j\n    \n    # YOUR CODE HERE (combine the three parts)\n\n    pass  # Remove this\n\n\n\nCode\n# Don't modify below - these test your solution\ntest_route = [1, 2, 3, 4, 5]\nswapped = perform_2opt_swap(test_route, 1, 3)\nassert swapped == [1, 2, 4, 3, 5], f\"Expected [1, 2, 4, 3, 5], got {swapped}\"\n\ntest2 = perform_2opt_swap([1, 2, 3, 4, 5, 6], 0, 4)\nassert test2 == [1, 5, 4, 3, 2, 6], f\"Expected [1, 5, 4, 3, 2, 6], got {test2}\"\n\nprint(\"✓ 2-opt swap implemented correctly!\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-3.2---complete-2-opt-algorithm",
    "href": "tutorials/nb_07_01_local_search.html#exercise-3.2---complete-2-opt-algorithm",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 3.2 - Complete 2-Opt Algorithm",
    "text": "Exercise 3.2 - Complete 2-Opt Algorithm\nNow implement the full 2-opt improvement algorithm.\n\n\n\n\n\n\nTipThe 2-Opt Algorithm Logic\n\n\n\n\nKeep trying swaps until no improvement found\nFor each pair of positions (i, j):\n\nCreate new route with that swap\nCalculate its distance\nIf better, keep it and mark improved = True\n\nStop when a full pass finds no improvements\n\n\n\n\n\n\n\n\n\nNoteBreaking Out of Nested Loops\n\n\n\nWhen you find an improvement, you want to restart the search:\nfor i in range(10):\n    for j in range(10):\n        if found_improvement:\n            improved = True\n            break  # Exits inner loop\n    if improved:\n        break  # Exits outer loop\n# Now restart the whole search\n\n\n\n# YOUR CODE BELOW\ndef improve_route_2opt(route, distance_matrix, max_iterations=100):\n    \"\"\"\n    Improve a route using 2-opt local search.\n\n    Args:\n        route: Initial route\n        distance_matrix: Distance matrix\n        max_iterations: Maximum improvement iterations\n\n    Returns:\n        Tuple of (improved_route, final_distance, improvement_count)\n    \"\"\"\n    current_route = route.copy()\n    current_distance = calculate_route_distance(current_route, distance_matrix)\n    improvement_count = 0\n\n    for iteration in range(max_iterations):\n        improved = False\n\n        # Try all possible 2-opt swaps\n        for i in range(len(current_route) - 1):\n            for j in range(i + 2, len(current_route)):\n                # Step 1: Create new route with swap\n                \n                # Step 2: Calculate distance of new route\n                \n                # Step 3: If better, keep it and mark improved\n                # Remember to update: current_route, current_distance, improvement_count\n                \n                # Step 4: Break to restart search\n                \n                pass  # Remove this\n                \n            if improved:\n                break\n\n        if not improved:\n            break  # No more improvements found\n\n    return current_route, current_distance, improvement_count\n\n\n\nCode\n# Don't modify below - these test your solution\nassert len(improved_route) == 10, \"Improved route should still visit all franchises\"\nassert improved_distance &lt;= initial_distance, \"Distance shouldn't increase\"\nassert improvements &gt;= 0, \"Should track improvements\"\n\nimprovement_pct = (initial_distance - improved_distance) / initial_distance * 100\nprint(f\"✓ 2-opt improvement complete!\")\nprint(f\"Initial distance: {initial_distance:.2f} km\")\nprint(f\"Improved distance: {improved_distance:.2f} km\")\nprint(f\"Improvement: {improvement_pct:.1f}% ({improvements} swaps)\")\nprint(f\"Monthly savings: €{(initial_distance - improved_distance) * 1.5 * 20:.2f}\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-4.1---random-initial-route",
    "href": "tutorials/nb_07_01_local_search.html#exercise-4.1---random-initial-route",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 4.1 - Random Initial Route",
    "text": "Exercise 4.1 - Random Initial Route\nCreate a random initial route and see if 2-opt can improve it.\n\n# YOUR CODE BELOW\ndef create_random_route(n_franchises):\n    \"\"\"\n    Create a random delivery route.\n\n    Args:\n        n_franchises: Number of franchises\n\n    Returns:\n        Random route (list of indices 1 to n_franchises)\n    \"\"\"\n    # Create list [1, 2, ..., n_franchises] and shuffle it\n    # YOUR CODE HERE\n\n    pass  # Remove this\n\n# Create and improve random route\nrandom_route = create_random_route(10)\nrandom_distance = calculate_route_distance(random_route, distance_matrix)\n\n# Improve it with 2-opt\nrandom_improved, random_final_dist, random_swaps = improve_route_2opt(\n    random_route, distance_matrix\n)\n\n\n\nCode\n# Don't modify below - these test your solution\nassert len(random_route) == 10, \"Random route should have 10 franchises\"\nassert set(random_route) == set(range(1, 11)), \"Should contain franchises 1-10\"\nassert random_final_dist &lt;= random_distance, \"2-opt shouldn't make it worse\"\n\nprint(f\"✓ Random route analysis complete!\")\nprint(f\"Random initial: {random_distance:.2f} km\")\nprint(f\"After 2-opt: {random_final_dist:.2f} km\")\nprint(f\"Improvements: {random_swaps} swaps\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-4.2---multiple-random-starts",
    "href": "tutorials/nb_07_01_local_search.html#exercise-4.2---multiple-random-starts",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 4.2 - Multiple Random Starts",
    "text": "Exercise 4.2 - Multiple Random Starts\nTry multiple random starting points to find the best solution.\n\n# YOUR CODE BELOW\ndef multi_start_optimization(distance_matrix, n_starts=10):\n    \"\"\"\n    Run 2-opt from multiple random starting points.\n\n    Args:\n        distance_matrix: Distance matrix\n        n_starts: Number of random starts to try\n\n    Returns:\n        Best route found and its distance\n    \"\"\"\n    best_route = None\n    best_distance = float('inf')\n\n    for i in range(n_starts):\n        # Create random initial route\n        # YOUR CODE HERE\n\n        # Improve with 2-opt\n        # YOUR CODE HERE\n\n        # Keep if best so far\n        # YOUR CODE HERE\n\n        pass  # Remove this\n\n    return best_route, best_distance\n\n# Try multi-start optimization\nmulti_route, multi_distance = multi_start_optimization(distance_matrix, n_starts=20)\n\n\n\nCode\n# Don't modify below - these test your solution\nassert len(multi_route) == 10, \"Best route should have 10 franchises\"\nassert multi_distance &lt;= improved_distance, \"Multi-start shouldn't be worse than single\"\n\nprint(f\"✓ Multi-start optimization complete!\")\nprint(f\"Best distance found: {multi_distance:.2f} km\")\nprint(f\"vs. Nearest Neighbor + 2-opt: {improved_distance:.2f} km\")\nprint(f\"vs. Random + 2-opt: {random_final_dist:.2f} km\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#visualizing-all-solutions",
    "href": "tutorials/nb_07_01_local_search.html#visualizing-all-solutions",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Visualizing All Solutions",
    "text": "Visualizing All Solutions\n\n# Compare all approaches\nplt.figure(figsize=(14, 10))\n\n# Define all routes and methods for comparison\nroutes = [\n    (initial_route, initial_distance, \"Nearest Neighbor\", '#A0A0A0'),\n    (improved_route, improved_distance, \"NN + 2-Opt\", '#537E8F'),\n    (random_route, random_distance, \"Random Initial\", '#F4A582'),\n    (random_improved, random_final_dist, \"Random + 2-Opt\", '#92C5DE'),\n    (multi_route, multi_distance, \"Multi-Start Best\", '#D73502')\n]\n\n# Create subplots\nfor idx, (route, distance, title, color) in enumerate(routes[:4], 1):\n    plt.subplot(2, 2, idx)\n\n    # Create route coordinates\n    route_coords = [hq_location]\n    for r_idx in route:\n        route_coords.append(franchise_locations[r_idx - 1])\n    route_coords.append(hq_location)\n\n    # Plot route\n    route_x = [coord[0] for coord in route_coords]\n    route_y = [coord[1] for coord in route_coords]\n    plt.plot(route_x, route_y, 'o-', color=color, linewidth=2,\n             markersize=0, alpha=0.7)\n\n    # Plot locations\n    plt.scatter(x_coords, y_coords, c='#537E8F', s=100, zorder=3)\n    plt.scatter(hq_location[0], hq_location[1], c='#D73502',\n               s=200, marker='s', zorder=3)\n\n    plt.title(f'{title}: {distance:.1f} km', fontweight='bold')\n    plt.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.suptitle('Bean Counter Delivery Route Comparison', fontsize=14, fontweight='bold', y=1.02)\nplt.show()",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#exercise-5.1---performance-summary",
    "href": "tutorials/nb_07_01_local_search.html#exercise-5.1---performance-summary",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Exercise 5.1 - Performance Summary",
    "text": "Exercise 5.1 - Performance Summary\nCreate a summary comparing all approaches.\n\n# YOUR CODE BELOW\ndef create_performance_summary(methods_data):\n    \"\"\"\n    Create a performance summary DataFrame.\n\n    Args:\n        methods_data: List of tuples (method_name, distance, time_hours)\n\n    Returns:\n        DataFrame with performance metrics\n    \"\"\"\n    # Create DataFrame with columns: Method, Distance, Fuel Cost, Time, Labor Cost, Total Cost\n    # YOUR CODE HERE\n\n    pass  # Remove this\n\n# Prepare data (assuming 30 km/h average speed)\nmethods_data = [\n    (\"Nearest Neighbor\", initial_distance),\n    (\"NN + 2-Opt\", improved_distance),\n    (\"Random Initial\", random_distance),\n    (\"Random + 2-Opt\", random_final_dist),\n    (\"Multi-Start\", multi_distance)\n]\n\n# Create summary\nsummary_df = create_performance_summary(methods_data)\n\n\n\nCode\n# Don't modify below - these test your solution\n# Test 1: Should have all 5 methods\nassert len(summary_df) == 5, \"Should have 5 methods\"\n\n# Test 2: Should have required columns\nassert 'Total Cost (€)' in summary_df.columns, \"Should calculate total cost\"\nassert 'Distance (km)' in summary_df.columns, \"Should have distance\"\n\n# Test 3: Costs should be positive and reasonable\nassert summary_df['Total Cost (€)'].min() &gt; 0, \"Costs should be positive\"\nassert summary_df['Total Cost (€)'].max() &lt; 500, \"Costs should be reasonable (&lt; €500)\"\n\n# Test 4: Best method should beat worst method\nbest_cost = summary_df['Total Cost (€)'].min()\nworst_cost = summary_df['Total Cost (€)'].max()\nassert best_cost &lt; worst_cost, \"Best method should have lower cost than worst\"\n\nbest_method = summary_df.loc[summary_df['Total Cost (€)'].idxmin(), 'Method']\nbest_savings = worst_cost - best_cost\n\nprint(f\"\\n✓ CEO Decision Summary Complete!\")\nprint(f\"Best method: {best_method}\")\nprint(f\"Daily savings vs worst: €{best_savings:.2f}\")\nprint(f\"Annual savings: €{best_savings * 250:.2f} (250 delivery days)\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#final-ceo-recommendation",
    "href": "tutorials/nb_07_01_local_search.html#final-ceo-recommendation",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Final CEO Recommendation",
    "text": "Final CEO Recommendation\n\n# Create final recommendation visualization\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n\n# Cost comparison bar chart\nmethods = [m[0] for m in methods_data]\ndistances = [m[1] for m in methods_data]\ncosts = [d * 1.50 + (d/30) * 30 for d in distances]\n\nax1.bar(range(len(methods)), costs, color=['#A0A0A0', '#537E8F', '#F4A582', '#92C5DE', '#D73502'])\nax1.set_xticks(range(len(methods)))\nax1.set_xticklabels(methods, rotation=45, ha='right')\nax1.set_ylabel('Total Cost per Day (€)')\nax1.set_title('Daily Delivery Cost Comparison', fontweight='bold')\nax1.grid(True, alpha=0.3, axis='y')\n\n# Improvement over time\nbaseline = costs[0]\nsavings = [baseline - c for c in costs]\nmonths = range(1, 13)\ncumulative_savings = [s * 20 * m for m in months for s in [savings[1]]]  # Using NN+2-opt\n\nax2.plot(months, cumulative_savings, 'o-', color='#537E8F', linewidth=2.5, markersize=8)\nax2.fill_between(months, 0, cumulative_savings, alpha=0.3, color='#537E8F')\nax2.set_xlabel('Months')\nax2.set_ylabel('Cumulative Savings (€)')\nax2.set_title('Projected Annual Savings with Optimization', fontweight='bold')\nax2.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#key-takeaways",
    "href": "tutorials/nb_07_01_local_search.html#key-takeaways",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nThe Traveling Salesman Problem (TSP):\n\nVisiting all locations with minimum distance\nExact solutions impractical for real-world problems\n\nGreedy Construction Algorithms:\n\nNearest Neighbor: Fast, simple, decent quality\nStart somewhere, always go to closest unvisited location\nQuick to implement and understand\n\nLocal Search Improvement:\n\n2-opt: Systematically uncross routes to reduce distance\nConverges to local optimum (best among nearby solutions)\nSimple yet powerful optimization technique\n\nMulti-start Strategy:\n\nDifferent starting points → different local optima\nRandom starts help explore solution space\nBest found solution often much better than single attempt\n\nAlgorithm Performance:\n\nNearest Neighbor: Quick construction, reasonable results\nNN + 2-Opt: Balanced approach, more improvement possible\nChoice depends on time constraints and quality needs!\n\nBusiness Impact:\n\nRoute optimization delivers immediate, measurable savings\nBetter routes = lower fuel costs + faster deliveries\nScales to much larger real-world delivery networks",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_07_01_local_search.html#whats-next",
    "href": "tutorials/nb_07_01_local_search.html#whats-next",
    "title": "Notebook 7.1 - Routing Optimization",
    "section": "What’s Next?",
    "text": "What’s Next?\nYou’ve now mastered the core concepts of routing optimization! In the Artisan Bakery Competition, you’ll apply these techniques to a more challenging problem with:\n\n16 cafés (vs. 10 franchises)\nTime window constraints (early deliveries required!)\n\nIn future lectures, you’ll learn advanced techniques like metaheuristics (simulated annealing, genetic algorithms, tabu search) that can escape local optima and find even better solutions by intelligently exploring the solution space.\nYour Bean Counter deliveries are now optimized. Time to help the bakery!",
    "crumbs": [
      "07 Local Search",
      "NB-07-01 Routing"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html",
    "href": "tutorials/nb_06_01_scheduling.html",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "",
    "text": "Welcome to your role as Bean Counter’s Operations Manager! You’ve been tasked with solving two critical scheduling challenges that will determine the efficiency of your coffee empire:\nChallenge 1: The Corporate Event (Sections 1-4)\nA major tech company just ordered 20 specialty coffee drinks for their board meeting. All orders are known upfront with specific deadlines. This is a batch scheduling problem, you have complete information and need to sequence the orders optimally before starting work.\nChallenge 2: The Friday Morning Rush (Sections 5-6)\nEvery Friday, your flagship store faces a continuous stream of orders arriving throughout the morning. You can’t see future orders and thus you must make real-time decisions. This is an online scheduling problem where orders reveal themselves over time.\nThese two scenarios represent fundamentally different scheduling paradigms you’ll master today!\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nCells marked with “YOUR CODE BELOW” expect you to write code. Test your solutions with the provided assertions. Work through sections in order as each builds on previous concepts!\n\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nfrom datetime import datetime, timedelta\n\n# Set random seed for reproducibility\nnp.random.seed(2025)\n\nprint(\"Libraries loaded! Ready to optimize Bean Counter's operations.\")\n\nLibraries loaded! Ready to optimize Bean Counter's operations.",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#the-scenario",
    "href": "tutorials/nb_06_01_scheduling.html#the-scenario",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "The Scenario",
    "text": "The Scenario\nTechCorp’s board meeting starts in 90 minutes. They’ve pre-ordered 20 specialty drinks with specific requirements. You have:\n\nComplete information: All 20 orders known upfront\nOne machine: Must sequence orders optimally\nVarying complexity: From simple espressos (3 min) to complex mochas (12 min)\nDeadlines: Some executives need drinks early (rushed board members), others can wait (relaxed attendees)\n\nThis is static scheduling - you can plan the entire sequence before starting.",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#the-data-structure",
    "href": "tutorials/nb_06_01_scheduling.html#the-data-structure",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "The Data Structure",
    "text": "The Data Structure\nEach order contains:\n\nOrder ID: Customer identifier\nProcessing Time: How long it takes to make\nDue Time: When the customer needs it (measured from start of your shift)\n\nNote: No arrival times! All orders are available at time 0.\n\n# TechCorp Corporate Event - 20 pre-orders\n# All available at start (time 0)\nnp.random.seed(2025)\n\ncorporate_orders = []\nfor i in range(20):\n    processing = np.random.choice([3, 5, 7, 10, 12], p=[0.25, 0.30, 0.25, 0.15, 0.05])\n\n    # 30% tight (15-30 min), 40% medium (30-60 min), 30% relaxed (60-90 min)\n    deadline_type = np.random.choice(['tight', 'medium', 'relaxed'], p=[0.3, 0.4, 0.3])\n    if deadline_type == 'tight':\n        due = np.random.randint(15, 30)\n    elif deadline_type == 'medium':\n        due = np.random.randint(30, 60)\n    else:\n        due = np.random.randint(60, 90)\n\n    corporate_orders.append({\n        'id': f'C{i+1:02d}', # Order-ID\n        'processing': processing, # Time needed to process each order\n        'due': due # Time when each order is due\n    })\n\ndf_corporate = pd.DataFrame(corporate_orders)\n\nprint(\"TechCorp Corporate Event Orders:\")\nprint(f\"Total orders: {len(corporate_orders)}\")\nprint(f\"Total processing time needed: {df_corporate['processing'].sum()} minutes\")\nprint(f\"Event window: 90 minutes\")\nprint(f\"Tightest deadline: {df_corporate['due'].min()} minutes\")\nprint(f\"Latest deadline: {df_corporate['due'].max()} minutes\")\nprint(f\"\\nFirst 10 orders:\")\nprint(df_corporate.head(10)[['id', 'processing', 'due']])\n\nTechCorp Corporate Event Orders:\nTotal orders: 20\nTotal processing time needed: 122 minutes\nEvent window: 90 minutes\nTightest deadline: 18 minutes\nLatest deadline: 89 minutes\n\nFirst 10 orders:\n    id  processing  due\n0  C01           3   72\n1  C02           3   30\n2  C03           5   44\n3  C04           3   65\n4  C05           5   81\n5  C06           5   46\n6  C07           5   58\n7  C08           3   18\n8  C09           7   64\n9  C10          12   81",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#key-performance-metrics",
    "href": "tutorials/nb_06_01_scheduling.html#key-performance-metrics",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Key Performance Metrics",
    "text": "Key Performance Metrics\n\ndef calculate_metrics(schedule_df):\n    \"\"\"\n    Calculate key performance metrics for a schedule\n\n    - Makespan: Total time to complete all orders\n    - Avg Flow Time: Average time from start until completion\n    - Total Tardiness: Sum of delays beyond due times\n    - Late Orders: Count of orders completed after deadline\n    \"\"\"\n    metrics = {\n        'makespan': schedule_df['completion'].max(),\n        'avg_flow_time': schedule_df['completion'].mean(),\n        'total_tardiness': np.maximum(0, schedule_df['completion'] - schedule_df['due']).sum(),\n        'late_orders': (schedule_df['completion'] &gt; schedule_df['due']).sum()\n    }\n    return metrics\n\nprint(\"Metrics function ready for comparing scheduling rules!\")\n\nMetrics function ready for comparing scheduling rules!",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#exercise-1.1---calculate-order-slack",
    "href": "tutorials/nb_06_01_scheduling.html#exercise-1.1---calculate-order-slack",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Exercise 1.1 - Calculate Order Slack",
    "text": "Exercise 1.1 - Calculate Order Slack\nSlack tells you how much scheduling flexibility exists for each order. It’s the time buffer before an order becomes late.\nFormula: Slack = Due Time - Processing Time\nWhy? If an order takes 5 minutes and is due at 20 minutes, you have 15 minutes of slack (can start anytime from 0 to 15).\n\n\n\n\n\n\nNoteDataFrame Column Operations\n\n\n\n# Create new column from calculation\ndf['new_col'] = df['col1'] - df['col2']\n\n# Find index of minimum value\nmin_idx = df['column'].idxmin()\n\n# Get value from specific row\nvalue = df.loc[min_idx, 'column_name']\n\n\n\n# YOUR CODE BELOW\n# Calculate slack for each order\n# Add a 'slack' column to df_corporate\n\ndf_corporate['slack'] = # Calculate: due - processing\n\n# Find the most urgent order (minimum slack)\n# Hint: Use idxmin() to find index, then .loc[] to get the ID\nmost_urgent = # Find the order ID with minimum slack\n\n\n\nCode\n# Tests\nassert 'slack' in df_corporate.columns, \"Add a 'slack' column to df_corporate\"\nassert len(df_corporate['slack']) == 20, \"Should calculate slack for all 20 orders\"\nassert (df_corporate['slack'] == df_corporate['due'] - df_corporate['processing']).all(), \\\n    \"Slack formula: due - processing\"\nprint(f\"Perfect! Most urgent order: {most_urgent} with {df_corporate['slack'].min()} minutes slack\")\nprint(\"\\nTop 5 most urgent orders:\")\nprint(df_corporate.nsmallest(5, 'slack')[['id', 'processing', 'due', 'slack']])",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#rule-1-fifo-first-in-first-out",
    "href": "tutorials/nb_06_01_scheduling.html#rule-1-fifo-first-in-first-out",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Rule 1: FIFO (First In, First Out)",
    "text": "Rule 1: FIFO (First In, First Out)\nProcess orders in their original sequence (order ID order).\n\n\n\n\n\n\n\nsorted() function sorts a list based on a criterion\nlambda x: x['id'] is a mini-function that is used in sorted() saying “sort by the ‘id’ field”\n\n\n\n\n\ndef schedule_fifo_static(orders):\n    \"\"\"\n    Schedule orders using First In, First Out (FIFO)\n    Process in original order\n    \"\"\"\n    # Sort by ID to maintain original order\n    scheduled = sorted(orders, key=lambda x: x['id'])\n\n    # Calculate completion times\n    current_time = 0\n    for order in scheduled:\n        # In static scheduling, all orders are available at time 0\n        # So we just start immediately after the previous order\n        order['start'] = current_time\n        order['completion'] = current_time + order['processing']\n        current_time = order['completion']\n\n    return scheduled\n\n# Test FIFO\n# Why .copy()? We don't want to modify the original 'orders' list\n# Each scheduling function will modify the orders, so we give it a copy\nfifo_schedule = schedule_fifo_static(corporate_orders.copy())\ndf_fifo = pd.DataFrame(fifo_schedule)\n\nprint(\"FIFO Schedule (first 10 orders):\")\nprint(df_fifo.head(10)[['id', 'processing', 'start', 'completion', 'due']])\nprint(f\"\\nTotal makespan: {df_fifo['completion'].max()} minutes\")\n\nFIFO Schedule (first 10 orders):\n    id  processing  start  completion  due\n0  C01           3      0           3   72\n1  C02           3      3           6   30\n2  C03           5      6          11   44\n3  C04           3     11          14   65\n4  C05           5     14          19   81\n5  C06           5     19          24   46\n6  C07           5     24          29   58\n7  C08           3     29          32   18\n8  C09           7     32          39   64\n9  C10          12     39          51   81\n\nTotal makespan: 122 minutes",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#rule-2-spt-shortest-processing-time",
    "href": "tutorials/nb_06_01_scheduling.html#rule-2-spt-shortest-processing-time",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Rule 2: SPT (Shortest Processing Time)",
    "text": "Rule 2: SPT (Shortest Processing Time)\nNow we implement SPT to always process the shortest job next and to process the quickest orders first to minimize average wait times.\n\ndef schedule_spt_static(orders):\n    \"\"\"\n    Schedule orders using Shortest Processing Time (SPT)\n    Process shortest jobs first\n    \"\"\"\n    # Sort by processing time (shortest first)\n    scheduled = sorted(orders, key=lambda x: x['processing'])\n\n    # Calculate completion times\n    current_time = 0\n    for order in scheduled:\n        order['start'] = current_time\n        order['completion'] = current_time + order['processing']\n        current_time = order['completion']\n\n    return scheduled\n\n# Test SPT\nspt_schedule = schedule_spt_static(corporate_orders.copy())\ndf_spt = pd.DataFrame(spt_schedule)\n\nprint(\"SPT Schedule (first 10 orders - sorted by processing time):\")\nprint(df_spt.head(10)[['id', 'processing', 'start', 'completion', 'due']])\nprint(f\"\\nTotal makespan: {df_spt['completion'].max()} minutes\")\n\nSPT Schedule (first 10 orders - sorted by processing time):\n    id  processing  start  completion  due\n0  C01           3      0           3   72\n1  C02           3      3           6   30\n2  C04           3      6           9   65\n3  C08           3      9          12   18\n4  C15           3     12          15   52\n5  C17           3     15          18   89\n6  C20           3     18          21   36\n7  C03           5     21          26   44\n8  C05           5     26          31   81\n9  C06           5     31          36   46\n\nTotal makespan: 122 minutes",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#exercise-2.1---implement-edd-earliest-due-date",
    "href": "tutorials/nb_06_01_scheduling.html#exercise-2.1---implement-edd-earliest-due-date",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Exercise 2.1 - Implement EDD (Earliest Due Date)",
    "text": "Exercise 2.1 - Implement EDD (Earliest Due Date)\nImplement EDD to minimize tardiness by processing urgent orders first.\n\n\n\n\n\n\nStructure is identical to SPT! Just change what you sort by.\n\n\n\n\n# YOUR CODE BELOW\ndef schedule_edd_static(orders):\n    \"\"\"\n    Schedule orders using Earliest Due Date (EDD)\n    Process orders with earliest deadlines first\n    \"\"\"\n    # Sort by due date (earliest first)\n    scheduled = # YOUR CODE\n\n    # Calculate completion times\n    current_time = 0\n    for order in scheduled:\n        order['start'] = # YOUR CODE\n        order['completion'] = # YOUR CODE\n        current_time = # YOUR CODE\n\n    return scheduled\n\n# Test your EDD implementation\nedd_schedule = schedule_edd_static(corporate_orders.copy())\ndf_edd = pd.DataFrame(edd_schedule)\n\n\n\nCode\n# Tests\nassert df_edd.iloc[0]['due'] &lt;= df_edd.iloc[1]['due'], \"First order should have earliest due date\"\nassert df_edd['completion'].max() == df_fifo['completion'].max(), \"All schedules have same makespan\"\ntotal_tardiness = np.maximum(0, df_edd['completion'] - df_edd['due']).sum()\nprint(f\"EDD implementation correct!\")\nprint(f\"\\nEDD Schedule (first 10 orders - sorted by due date):\")\nprint(df_edd.head(10)[['id', 'due', 'processing', 'start', 'completion']])\nprint(f\"Total tardiness: {total_tardiness:.0f} minutes\")",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#exercise-4.1---compare-scheduling-rules",
    "href": "tutorials/nb_06_01_scheduling.html#exercise-4.1---compare-scheduling-rules",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Exercise 4.1 - Compare Scheduling Rules",
    "text": "Exercise 4.1 - Compare Scheduling Rules\nCalculate metrics for all three rules to see which performs best.\n\n\n\n\n\n\nTipCoding Hints\n\n\n\n\nThe calculate_metrics() function is already defined - you just call it!\nIt returns a dictionary with metrics like {'makespan': 29, 'avg_flow_time': 15.2, ...}\nPass the DataFrame to the function: calculate_metrics(df_fifo)\n\n\n\n\n\n\n\n\n\nNoteCreating DataFrames from Dictionaries\n\n\n\n# Dictionary of dictionaries\ndata = {\n    'Method_A': {'metric1': 10, 'metric2': 20},\n    'Method_B': {'metric1': 15, 'metric2': 18}\n}\n\n# Create DataFrame with .T to transpose (swap rows/columns)\ndf = pd.DataFrame(data).T\n\n# Result:\n#          metric1  metric2\n# Method_A      10       20\n# Method_B      15       18\n\n\n\n# YOUR CODE BELOW\n# Calculate metrics for each schedule\n# Hint: calculate_metrics(df_fifo) returns a dictionary\n\nmetrics_fifo = # YOUR CODE\nmetrics_spt = # YOUR CODE\nmetrics_edd = # YOUR CODE\n\n# Create comparison DataFrame\n# The .T transposes so methods are rows\ncomparison = pd.DataFrame({\n    'FIFO': metrics_fifo,\n    'SPT': metrics_spt,\n    'EDD': metrics_edd\n}).T\n\nprint(\"Performance Comparison - Corporate Event:\")\nprint(comparison.round(2))\n\n\n\nCode\n# Tests\nassert comparison.loc['SPT', 'avg_flow_time'] &lt;= comparison.loc['FIFO', 'avg_flow_time'], \\\n    \"SPT should have best average flow time\"\nassert comparison.loc['EDD', 'total_tardiness'] &lt;= comparison.loc['FIFO', 'total_tardiness'], \\\n    \"EDD should minimize tardiness\"\nassert comparison.loc['EDD', 'total_tardiness'] &lt;= comparison.loc['SPT', 'total_tardiness'], \\\n    \"EDD should beat SPT on tardiness\"\nprint(\"✓ Excellent analysis!\")\nprint(f\"\\nKey Insights:\")\nprint(f\" SPT reduces avg flow time by {(1 - comparison.loc['SPT', 'avg_flow_time']/comparison.loc['FIFO', 'avg_flow_time'])*100:.1f}% vs FIFO\")\nprint(f\" EDD reduces tardiness by {comparison.loc['FIFO', 'total_tardiness'] - comparison.loc['EDD', 'total_tardiness']:.0f} minutes vs FIFO\")\nprint(f\" EDD reduces late orders from {comparison.loc['FIFO', 'late_orders']:.0f} to {comparison.loc['EDD', 'late_orders']:.0f}\")\nprint(f\" All methods have same makespan: {comparison['makespan'].iloc[0]:.0f} minutes (sum of all processing times)\")",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#visualizing-the-trade-offs",
    "href": "tutorials/nb_06_01_scheduling.html#visualizing-the-trade-offs",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Visualizing the Trade-offs",
    "text": "Visualizing the Trade-offs\n\n# Create visual comparison\nfig, axes = plt.subplots(2, 2, figsize=(12, 8))\n\nmetrics_to_plot = ['makespan', 'avg_flow_time', 'total_tardiness', 'late_orders']\ncolors = ['#537E8F', '#F6B265', '#DB6B6B']\n\nfor ax, metric in zip(axes.flat, metrics_to_plot):\n    values = [comparison.loc[rule, metric] for rule in ['FIFO', 'SPT', 'EDD']]\n    bars = ax.bar(['FIFO', 'SPT', 'EDD'], values, color=colors, alpha=0.7)\n\n    # Highlight the best performer\n    best_idx = np.argmin(values)\n    bars[best_idx].set_edgecolor('black')\n    bars[best_idx].set_linewidth(2)\n\n    ax.set_title(metric.replace('_', ' ').title(), fontweight='bold')\n    ax.set_ylabel('Value')\n\n    # Add value labels\n    for bar, val in zip(bars, values):\n        height = bar.get_height()\n        ax.text(bar.get_x() + bar.get_width()/2., height,\n                f'{val:.1f}', ha='center', va='bottom')\n\nplt.suptitle('Corporate Event: Static Scheduling Performance', fontsize=14, fontweight='bold')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nWhy these results?\n\nSPT minimizes avg flow time: Short jobs finish quickly, reducing overall wait\nEDD minimizes tardiness: Processing by deadline directly optimizes late penalties\nFIFO is neutral: No optimization, just processes in arbitrary order\nSame makespan: All schedules do the same work, just in different orders",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#why-static-scheduling-isnt-enough",
    "href": "tutorials/nb_06_01_scheduling.html#why-static-scheduling-isnt-enough",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Why Static Scheduling Isn’t Enough",
    "text": "Why Static Scheduling Isn’t Enough\nThe corporate event was a batch problem, all orders known upfront. But most real operations face online problems where:\n\nOrders arrive over time\nYou can’t see future orders\nYou must make decisions with partial information\n\nFriday morning at Bean Counter is this type of problem!",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#the-friday-scenario",
    "href": "tutorials/nb_06_01_scheduling.html#the-friday-scenario",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "The Friday Scenario",
    "text": "The Friday Scenario\nIt’s 6 AM Friday. Your flagship store faces:\n\nOrders arriving continuously over 2 hours\nNo future visibility - can’t see orders that haven’t been placed yet\nReal-time decisions - when the machine is free, which available order should you process?\n\nThis requires dynamic dispatching: making decisions based only on orders that have already arrived.\n\n# Generate realistic Friday morning rush orders\n# Generate realistic Friday morning rush orders\nnp.random.seed(2025)\nn_orders = 30\n\nfriday_orders = []\ncurrent_arrival = 0\n\nfor i in range(n_orders):\n    # Orders arrive with gaps (exponential inter-arrival times)\n    if i &gt; 0:\n        current_arrival += np.random.exponential(2.0)\n\n    processing = np.random.choice([1,2,3], p=[0.1,0.5, 0.4])\n\n    # Due times are relative to arrival (customers want drinks soon after ordering)\n    order_urgency = np.random.choice(['rush', 'normal', 'relaxed'], p=[0.10, 0.40, 0.50])\n    if order_urgency == 'rush':\n        due = current_arrival + processing + np.random.randint(1, 3)\n    elif order_urgency == 'normal':\n        due = current_arrival + processing + np.random.randint(4, 6)\n    else:\n        due = current_arrival + processing + np.random.randint(7, 12)\n\n    friday_orders.append({\n        'id': f'F{i+1:02d}',\n        'arrival': round(current_arrival, 1),\n        'processing': processing,\n        'due': round(due, 1)\n    })\n\ndf_friday = pd.DataFrame(friday_orders)\n\nprint(\"Friday Morning Rush - Flagship Store\")\nprint(f\"Total orders: {len(friday_orders)}\")\nprint(f\"Arrival span: {df_friday['arrival'].min():.1f} to {df_friday['arrival'].max():.1f} minutes\")\nprint(f\"Total processing needed: {df_friday['processing'].sum()} minutes\")\nprint(f\"\\nFirst 10 orders:\")\nprint(df_friday.head(10)[['id', 'arrival', 'processing', 'due']])\n\nFriday Morning Rush - Flagship Store\nTotal orders: 30\nArrival span: 0.0 to 61.6 minutes\nTotal processing needed: 67 minutes\n\nFirst 10 orders:\n    id  arrival  processing   due\n0  F01      0.0           2  13.0\n1  F02      0.2           3  10.2\n2  F03      2.4           2  15.4\n3  F04      5.6           1  14.6\n4  F05      5.8           2  15.8\n5  F06      6.5           2  17.5\n6  F07      8.4           3  20.4\n7  F08      9.1           2  16.1\n8  F09      9.2           2  15.2\n9  F10     13.4           1  19.4",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#what-happens-if-we-use-static-scheduling",
    "href": "tutorials/nb_06_01_scheduling.html#what-happens-if-we-use-static-scheduling",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "What Happens If We Use Static Scheduling?",
    "text": "What Happens If We Use Static Scheduling?\nLet’s see what goes wrong if we apply static SPT to this dynamic problem:\n\n# Apply static SPT (sorts all orders, ignores arrivals)\nfriday_static_spt = schedule_spt_static(friday_orders.copy())\ndf_friday_static_spt = pd.DataFrame(friday_static_spt)\n\nprint(\"Static SPT on Friday Rush:\")\nprint(df_friday_static_spt.head(10)[['id', 'arrival', 'processing', 'start', 'completion']])\nprint(f\"\\nNotice the problem: Order {df_friday_static_spt.iloc[0]['id']} starts at time 0\")\nprint(f\"But it doesn't arrive until time {df_friday_static_spt.iloc[0]['arrival']:.1f}!\")\nprint(f\"This creates {df_friday_static_spt.iloc[0]['arrival']:.1f} minutes of idle time.\")\n\nStatic SPT on Friday Rush:\n    id  arrival  processing  start  completion\n0  F04      5.6           1      0           1\n1  F10     13.4           1      1           2\n2  F13     23.6           1      2           3\n3  F23     46.9           1      3           4\n4  F25     48.0           1      4           5\n5  F01      0.0           2      5           7\n6  F03      2.4           2      7           9\n7  F05      5.8           2      9          11\n8  F06      6.5           2     11          13\n9  F08      9.1           2     13          15\n\nNotice the problem: Order F04 starts at time 0\nBut it doesn't arrive until time 5.6!\nThis creates 5.6 minutes of idle time.\n\n\n\n\n\n\n\n\nStatic scheduling on online problems creates idle time!\nStatic SPT sorts all orders by processing time, then tries to do the shortest first. But if that order hasn’t arrived yet, the machine sits idle waiting.\nWe need dynamic dispatching that only considers orders that have already arrived.",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#the-dynamic-dispatching-algorithm",
    "href": "tutorials/nb_06_01_scheduling.html#the-dynamic-dispatching-algorithm",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "The Dynamic Dispatching Algorithm",
    "text": "The Dynamic Dispatching Algorithm\nInstead of sorting everything upfront, we make decisions one at a time as the machine becomes free:\n\nStart with current_time = 0\nWhile there are unscheduled orders:\n\nFind which orders have arrival &lt;= current_time (the “available pool”)\nIf no orders available, jump forward to the next arrival\nApply your rule (FIFO/SPT/EDD) to choose from the available pool\nSchedule that order, update time, repeat\n\n\nThis simulates real-time decision-making!",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#exercise-6.1---implement-dynamic-spt",
    "href": "tutorials/nb_06_01_scheduling.html#exercise-6.1---implement-dynamic-spt",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Exercise 6.1 - Implement Dynamic SPT",
    "text": "Exercise 6.1 - Implement Dynamic SPT\nImplement SPT with dynamic dispatching for Bean Counter.\n\n\n\n\n\n\nTipDynamic Scheduling Logic\n\n\n\nKey difference from static: You can only schedule orders that have already arrived!\n\nUse a while remaining: loop (not a for loop over pre-sorted list)\nFilter to available = [orders where arrival &lt;= current_time]\nIf no available orders, jump forward: current_time = min(arrival of remaining)\nThen apply SPT to the available pool\n\n\n\n\n\n\n\n\n\nNoteList Comprehension for Filtering\n\n\n\nList comprehension creates a new list based on a condition:\n# General pattern\nnew_list = [item for item in old_list if condition]\n\n# Example: filter numbers &gt; 5\nnumbers = [3, 7, 2, 9, 1, 6]\nbig_numbers = [n for n in numbers if n &gt; 5]\n# Result: [7, 9, 6]\n\n# Filter orders by arrival time\navailable = [order for order in remaining if order['arrival'] &lt;= current_time]\n\n\n\n# YOUR CODE BELOW\ndef schedule_spt_dynamic(orders):\n    \"\"\"\n    Schedule orders using DYNAMIC Shortest Processing Time\n    At each decision point, choose shortest job among those that have arrived\n    \"\"\"\n    scheduled = []\n    remaining = [o.copy() for o in orders]  # Make copies to avoid modifying originals\n    current_time = 0\n\n    while remaining:\n        # Find available orders (already arrived)\n        # Use list comprehension: [o for o in remaining if ...]\n        available = # YOUR CODE: list of orders where arrival &lt;= current_time\n\n        # If nothing available, jump to next arrival\n        if not available:\n            # Find earliest arrival among remaining orders\n            current_time = # YOUR CODE: min arrival time of remaining orders\n            # Now re-filter for available orders\n            available = # YOUR CODE: update available orders\n\n        # Choose shortest processing time among available\n        # Use min() with key=lambda\n        next_order = # YOUR CODE: min(available, key=lambda ...)\n\n        # Schedule it\n        next_order['start'] = current_time\n        next_order['completion'] = current_time + next_order['processing']\n        current_time = next_order['completion']\n\n        # Move from remaining to scheduled\n        scheduled.append(next_order)\n        remaining.remove(next_order)\n\n    return scheduled\n\n# Test dynamic SPT\nfriday_dynamic_spt = schedule_spt_dynamic(friday_orders)\ndf_friday_dynamic_spt = pd.DataFrame(friday_dynamic_spt)\n\n\n\nCode\n# Tests\nassert all(df_friday_dynamic_spt['start'] &gt;= df_friday_dynamic_spt['arrival']), \\\n    \"All orders should start at or after their arrival time\"\n\n# Calculate idle time for both approaches\nstatic_idle = sum(max(0, row['arrival'] - (df_friday_static_spt.iloc[i-1]['completion'] if i &gt; 0 else 0))\n                  for i, row in df_friday_static_spt.iterrows())\ndynamic_idle = sum(max(0, row['start'] - (df_friday_dynamic_spt.iloc[i-1]['completion'] if i &gt; 0 else 0))\n                   for i, row in df_friday_dynamic_spt.iterrows())\n\nprint(\"Excellent! Dynamic SPT implementation is correct!\")\nprint(f\"\\nDynamic vs Static SPT on Friday Rush:\")\nprint(f\" • Static makespan (with arrival violations!): {df_friday_static_spt['completion'].max():.1f} minutes\")\nprint(f\" • Dynamic makespan (no violations): {df_friday_dynamic_spt['completion'].max():.1f} minutes\")\nprint(f\" • Change: {df_friday_static_spt['completion'].max() - df_friday_dynamic_spt['completion'].max():.1f} minutes faster\")\nprint(f\" • Dynamic idle time: {dynamic_idle:.1f} minutes\")",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#exercise-6.2---implement-dynamic-edd",
    "href": "tutorials/nb_06_01_scheduling.html#exercise-6.2---implement-dynamic-edd",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Exercise 6.2 - Implement Dynamic EDD",
    "text": "Exercise 6.2 - Implement Dynamic EDD\nNow implement EDD with dynamic dispatching to minimize tardiness in the Friday rush.\n\n# YOUR CODE BELOW\ndef schedule_edd_dynamic(orders):\n    \"\"\"\n    Schedule orders using DYNAMIC Earliest Due Date\n    At each decision point, choose order with earliest deadline among available orders\n    \"\"\"\n    scheduled = []\n    remaining = [o.copy() for o in orders]\n    current_time = 0\n\n    while remaining:\n        # YOUR CODE: Find available orders\n        available = # [orders where arrival &lt;= current_time]\n\n        # YOUR CODE: Handle no available orders\n        if not available:\n            current_time = # min arrival of remaining\n            available = # update available\n\n        # YOUR CODE: Choose earliest due date\n        next_order = # Hint: Just change the key from SPT\n\n        # Schedule it (same as SPT)\n        next_order['start'] = current_time\n        next_order['completion'] = current_time + next_order['processing']\n        current_time = next_order['completion']\n\n        scheduled.append(next_order)\n        remaining.remove(next_order)\n\n    return scheduled\n\n# Test dynamic EDD\nfriday_dynamic_edd = schedule_edd_dynamic(friday_orders)\ndf_friday_dynamic_edd = pd.DataFrame(friday_dynamic_edd)\n\n\n\nCode\n# Tests\nassert all(df_friday_dynamic_edd['start'] &gt;= df_friday_dynamic_edd['arrival']), \\\n    \"All orders should start at or after arrival\"\n\nmetrics_dynamic_spt = calculate_metrics(df_friday_dynamic_spt)\nmetrics_dynamic_edd = calculate_metrics(df_friday_dynamic_edd)\n\nassert metrics_dynamic_edd['total_tardiness'] &lt;= metrics_dynamic_spt['total_tardiness'], \\\n    \"EDD should minimize tardiness better than SPT\"\n\nprint(\"✓ Dynamic EDD implementation correct!\")\nprint(f\"\\nFriday Rush: Dynamic SPT vs Dynamic EDD\")\nprint(f\" • SPT avg flow time: {metrics_dynamic_spt['avg_flow_time']:.1f} minutes\")\nprint(f\" • EDD avg flow time: {metrics_dynamic_edd['avg_flow_time']:.1f} minutes\")\nprint(f\" • SPT total tardiness: {metrics_dynamic_spt['total_tardiness']:.1f} minutes\")\nprint(f\" • EDD total tardiness: {metrics_dynamic_edd['total_tardiness']:.1f} minutes\")\nprint(f\" • SPT late orders: {metrics_dynamic_spt['late_orders']:.0f}\")\nprint(f\" • EDD late orders: {metrics_dynamic_edd['late_orders']:.0f}\")",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#final-performance-comparison",
    "href": "tutorials/nb_06_01_scheduling.html#final-performance-comparison",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Final Performance Comparison",
    "text": "Final Performance Comparison\n\n# Calculate metrics for all Friday approaches\nfriday_comparison = pd.DataFrame({\n    'Dynamic_SPT': calculate_metrics(df_friday_dynamic_spt),\n    'Dynamic_EDD': calculate_metrics(df_friday_dynamic_edd)\n}).T\n\nprint(\"Friday Morning Rush - Final Performance:\")\nprint(friday_comparison.round(2))\n\n# Visualization\nfig, axes = plt.subplots(2, 2, figsize=(12, 8))\nmetrics_to_plot = ['makespan', 'avg_flow_time', 'total_tardiness', 'late_orders']\ncolors = ['#F6B265', '#DB6B6B']\n\nfor ax, metric in zip(axes.flat, metrics_to_plot):\n    values = [friday_comparison.loc[rule, metric] for rule in ['Dynamic_SPT', 'Dynamic_EDD']]\n    bars = ax.bar(['Dynamic SPT', 'Dynamic EDD'], values, color=colors, alpha=0.7)\n\n    best_idx = np.argmin(values)\n    bars[best_idx].set_edgecolor('black')\n    bars[best_idx].set_linewidth(2)\n\n    ax.set_title(metric.replace('_', ' ').title(), fontweight='bold')\n    ax.set_ylabel('Value')\n\n    for bar, val in zip(bars, values):\n        height = bar.get_height()\n        ax.text(bar.get_x() + bar.get_width()/2., height,\n                f'{val:.1f}', ha='center', va='bottom')\n\nplt.suptitle('Friday Rush: Dynamic Scheduling Performance', fontsize=14, fontweight='bold')\nplt.tight_layout()\nplt.show()\n\nFriday Morning Rush - Final Performance:\n             makespan  avg_flow_time  total_tardiness  late_orders\nDynamic_SPT      69.1          33.82             20.5          5.0\nDynamic_EDD      69.1          34.18              8.3          6.0",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#key-takeaways",
    "href": "tutorials/nb_06_01_scheduling.html#key-takeaways",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nStatic Scheduling (Corporate Event):\n\nAll orders known upfront\nSort and sequence optimally\nSPT minimizes flow time, EDD minimizes tardiness\nSimple to implement and understand\n\nDynamic Scheduling (Friday Rush):\n\nOrders arrive over time\nMake real-time decisions with partial information\nOnly consider orders that have arrived\nBetter machine utilization, more realistic\n\nAlgorithm Performance:\n\nFIFO: Simple, fair, but not optimized\nSPT: Minimizes average wait time\nEDD: Minimizes tardiness and late orders\nChoice depends on business priorities!\n\nWhen to Use Each:\n\nStatic: Batch processing, complete information, planning ahead\nDynamic: Real-time operations, orders arrive continuously, reactive scheduling",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_06_01_scheduling.html#whats-next",
    "href": "tutorials/nb_06_01_scheduling.html#whats-next",
    "title": "Notebook 6.1 - Scheduling Mastery",
    "section": "What’s Next?",
    "text": "What’s Next?\nYou’ve now mastered both static and dynamic scheduling approaches! In the next notebook, you’ll tackle the Bike Factory Competition where you’ll apply these scheduling techniques to a real two-stage manufacturing problem.\nIn the following lectures, you’ll then learn advanced techniques like local search and metaheuristics that can improve even the best greedy solutions by intelligently exploring schedule variations.\nYour Bean Counter operations are now optimized for both planning and real-time scenarios!",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-01 Scheduling"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html",
    "href": "tutorials/nb_05_01_time_series.html",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "",
    "text": "Welcome back, CEO! After successfully using Monte Carlo simulation to plan Bean Counter’s expansion, you now face a new challenge: predicting future demand for your seasonal products.\nThe Seasonal Challenge: Bean Counter has expanded beyond regular coffee into seasonal drinks:\n\nIced Coffee (summer favorite)\nPumpkin Spice Latte (fall special)\nPeppermint Hot Chocolate (winter warmer)\n\nYou have 2 years of daily sales data. The board wants accurate forecasts for next month to optimize inventory. Overstock means waste (drinks expire), understock means lost sales and unhappy customers!\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nCells marked with “YOUR CODE BELOW” expect you to write code. Test your solutions with the provided assertions. Work through the sections in order - each builds on previous concepts!\n\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom datetime import datetime, timedelta\n\n# Set random seed for reproducibility\nnp.random.seed(2025)\nprint(\"Libraries loaded! Time to predict Bean Counter's future.\")\n\nLibraries loaded! Time to predict Bean Counter's future.",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#understanding-date-conversion",
    "href": "tutorials/nb_05_01_time_series.html#understanding-date-conversion",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Understanding Date Conversion",
    "text": "Understanding Date Conversion\n\n# Example: Converting strings to dates\ndate_strings = ['2024-01-15', '2024-02-20', '2024-03-10']\ndates = pd.to_datetime(date_strings)\nprint(\"Original strings:\", date_strings)\nprint(\"\\nConverted to datetime:\", dates)\nprint(\"\\nExtract components:\")\nprint(f\"  Months: {dates.month.tolist()}\")\nprint(f\"  Day of week: {dates.day_name().tolist()}\")\n\nOriginal strings: ['2024-01-15', '2024-02-20', '2024-03-10']\n\nConverted to datetime: DatetimeIndex(['2024-01-15', '2024-02-20', '2024-03-10'], dtype='datetime64[ns]', freq=None)\n\nExtract components:\n  Months: [1, 2, 3]\n  Day of week: ['Monday', 'Tuesday', 'Sunday']\n\n\n\n\n\n\n\n\nUse .dt accessor to extract date parts:\n\n.dt.month - Month (1-12)\n.dt.day_of_week - Day (0=Monday, 6=Sunday)\n.dt.quarter - Quarter (1-4)\n.dt.is_month_end - Boolean for month end\n\n\n\n\n\n\n\n\n\n\nTo access specific elements, e.g. the third month of a year from a DataFrame, you can use df['date'].dt.month.iloc[2]. Step by step this happens:\n\nYou access the date column using df['date'].\nYou use the .dt accessor to extract the month part.\nYou use .iloc[2] to select the third element.",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#exercise-1.1---load-and-prepare-sales-data",
    "href": "tutorials/nb_05_01_time_series.html#exercise-1.1---load-and-prepare-sales-data",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Exercise 1.1 - Load and Prepare Sales Data",
    "text": "Exercise 1.1 - Load and Prepare Sales Data\nCreate a DataFrame with Bean Counter’s sales data and convert the date column properly.\n\n# DON'T CHANGE ANYTHING BELOW!\n# Creates sample sales data for Bean Counter (3 years for enough seasonal cycles)\ndates = pd.date_range(start='2022-01-01', end='2024-12-31', freq='D')\n\n# Generate sales with trend and seasonality\nbase_sales = 100\ntrend = np.linspace(0, 60, len(dates))  # Growing trend over 3 years\n# Summer peaks for iced coffee! (high in June-Aug, low in Dec-Feb)\nseasonal = 45 * np.sin(2 * np.pi * (np.arange(len(dates)) - 80) / 365.25)  # Yearly pattern, peaks in summer\nweekly = 15 * np.sin(2 * np.pi * np.arange(len(dates)) / 7)  # Weekend peaks\nnoise = np.random.normal(0, 20, len(dates))  # Controlled noise\nsales = base_sales + trend + seasonal + weekly + noise\n# DON'T CHANGE ANYTHING ABOVE!\n\n\n\n\n\n\n\nNoteCreating DataFrames and Working with Dates\n\n\n\n# Create DataFrame from dictionary\ndf = pd.DataFrame({'col1': values1, 'col2': values2})\n\n# Access datetime attributes with .dt\ndf['date'].dt.month   # Extract month (1-12)\ndf['date'].dt.year    # Extract year\ndf['date'].dt.day     # Extract day\n\n# Get first/last element\ndf['column'].iloc[0]   # First element\ndf['column'].iloc[-1]  # Last element\n\n\n\n# YOUR CODE BELOW\n\n# Create DataFrame with date and sales columns\ndf =   # Create the DataFrame with 'date' and 'sales' columns\n\n# Extract month from the date column\n# Hint: Use .dt.month to get month, then .iloc[0] or .iloc[-1]\nfirst_month =   # Get the month of the first date\nlast_month =    # Get the month of the last date\n\n\n\nCode\n# Don't modify below - these test your solution\nassert 'date' in df.columns, \"DataFrame should have a 'date' column\"\nassert 'sales' in df.columns, \"DataFrame should have a 'sales' column\"\nassert first_month == 1, f\"First month should be January (1), got {first_month}\"\nassert last_month == 12, f\"Last month should be December (12), got {last_month}\"\nprint(\"Great! Sales data loaded and dates properly formatted!\")\n\n# Quick visualization of your loaded data\nplt.figure(figsize=(12, 8))\nplt.plot(df['date'], df['sales'], linewidth=1, alpha=0.7, color='#537E8F')\nplt.xlabel('Date')\nplt.ylabel('Sales (drinks)')\nplt.title('Bean Counter Sales - Your Loaded Data')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#exercise-1.2---analyze-sales-patterns",
    "href": "tutorials/nb_05_01_time_series.html#exercise-1.2---analyze-sales-patterns",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Exercise 1.2 - Analyze Sales Patterns",
    "text": "Exercise 1.2 - Analyze Sales Patterns\nCalculate key statistics about Bean Counter’s sales to understand the data.\n\n\n\n\n\n\nYou can use methods like mean(), max(), and min() to calculate basic statistics with DataFrames. You just need to call these methods on the ‘sales’ column of the DataFrame.\n\n\n\n\n# YOUR CODE BELOW\n# Calculate basic statistics\nmean_sales =   # Average daily sales\nmax_sales =    # Highest sales day\nmin_sales =    # Lowest sales day\n\n\n\nCode\n# Don't modify below\nassert 115 &lt; mean_sales &lt; 135, f\"Mean sales should be ~125, got {mean_sales:.1f}\"\nassert max_sales &gt; 180, f\"Max sales should be &gt;180, got {max_sales:.1f}\"\nassert min_sales &lt; 70, f\"Min sales should be &lt;70, got {min_sales:.1f}\"\nprint(f\"Excellent! Analysis complete!\")\nprint(f\"Daily average: {mean_sales:.0f} drinks\")",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#understanding-moving-averages",
    "href": "tutorials/nb_05_01_time_series.html#understanding-moving-averages",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Understanding Moving Averages",
    "text": "Understanding Moving Averages\nThe Concept: A moving average smooths data by calculating the average of a “window” of recent values. As we move forward in time, the window slides along the data.\nExample: For a 3-day moving average:\n\nDay 3 average: (Day1 + Day2 + Day3) / 3\nDay 4 average: (Day2 + Day3 + Day4) / 3\nDay 5 average: (Day3 + Day4 + Day5) / 3\n\n\n# Example: 7-day moving average\ndf['MA7'] = df['sales'].rolling(window=7).mean()\n\n# Plot comparison (first 60 days)\nplt.figure(figsize=(12, 8))\nplt.plot(df['date'][:60], df['sales'][:60], alpha=0.5, label='Daily Sales', linewidth=1)\nplt.plot(df['date'][:60], df['MA7'][:60], linewidth=2.5, label='7-Day Moving Avg', color='red')\nplt.xlabel('Date')\nplt.ylabel('Sales')\nplt.title('Bean Counter Daily Sales vs 7-Day Moving Average')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarningNaN Values in Moving Averages\n\n\n\nThe first (window-1) values will be NaN because there aren’t enough previous values to calculate the average! For a 7-day MA, the first 6 values are NaN. To find the number of NaN values in a moving average, you can use the isna() method to check for NaN values and then count them using the sum() method, e.g., df['MA7'].isna().sum().",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#exercise-2.1---create-multiple-moving-averages",
    "href": "tutorials/nb_05_01_time_series.html#exercise-2.1---create-multiple-moving-averages",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Exercise 2.1 - Create Multiple Moving Averages",
    "text": "Exercise 2.1 - Create Multiple Moving Averages\nCalculate different window sizes to see their smoothing effects.\n\n\n\n\n\n\nNoteRolling Windows and NaN Values\n\n\n\n# Create rolling window and calculate mean\ndf['MA7'] = df['sales'].rolling(window=7).mean()\n\n# Count missing (NaN) values\nna_count = df['MA7'].isna().sum()\n\n# Why NaN? First 6 rows have no 7-day window yet!\n# Window of 7 → first 6 values are NaN\n\n\n\n# YOUR CODE BELOW\n# Calculate moving averages with different windows\ndf['MA3'] =   # 3-day moving average\ndf['MA14'] =  # 14-day (2 week) moving average\ndf['MA30'] =  # 30-day (monthly) moving average\n\n# Count NaN values in each\n# Hint: Use .isna().sum()\nna_count_3 =   # Number of NaN values in MA3\nna_count_14 =  # Number of NaN values in MA14\nna_count_30 =  # Number of NaN values in MA30\n\n\n\nCode\n# Don't modify below\nassert na_count_3 == 2, f\"MA3 should have 2 NaN values, got {na_count_3}\"\nassert na_count_14 == 13, f\"MA14 should have 13 NaN values, got {na_count_14}\"\nassert na_count_30 == 29, f\"MA30 should have 29 NaN values, got {na_count_30}\"\nassert df['MA30'].std() &lt; df['MA3'].std(), \"MA30 should be smoother (lower std) than MA3\"\nprint(\"Perfect! Moving averages calculated correctly!\")\nprint(f\"  MA30 is {df['MA3'].std() / df['MA30'].std():.1f}x smoother than MA3\")\n\n# Visualize the smoothing effect\nplt.figure(figsize=(12, 8))\nplt.plot(df['date'], df['sales'], linewidth=1, alpha=0.2, color='gray', label='Daily Sales')\nplt.plot(df['date'], df['MA3'], linewidth=2, alpha=0.3, color='#DB6B6B', label='MA3 (noisy)')\nplt.plot(df['date'], df['MA14'], linewidth=2, alpha=0.6, color='#537E8F', label='MA14 (balanced)')\nplt.plot(df['date'], df['MA30'], linewidth=2.5, alpha=0.9, color='#F6B265', label='MA30 (smooth)')\nplt.xlabel('Date')\nplt.ylabel('Sales (drinks)')\nplt.title('Comparing Moving Average Windows - Notice How MA30 is Smoothest')\nplt.legend(loc='best')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#exercise-2.2---weighted-moving-average",
    "href": "tutorials/nb_05_01_time_series.html#exercise-2.2---weighted-moving-average",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Exercise 2.2 - Weighted Moving Average",
    "text": "Exercise 2.2 - Weighted Moving Average\nRecent data often matters more! A weighted moving average assigns higher weights to recent observations.\nThe Idea: Instead of equal weights [1/7, 1/7, 1/7, 1/7, 1/7, 1/7, 1/7], we use custom weights like [0.05, 0.05, 0.10, 0.15, 0.20, 0.20, 0.25] where recent days get more importance.\n\n\n\n\n\n\nNoteNumPy Array Operations\n\n\n\n# Element-wise multiplication\nsales = np.array([100, 105, 110])\nweights = np.array([0.2, 0.3, 0.5])\nweighted_sales = sales * weights  # [20, 31.5, 55]\n\n# Sum all elements\ntotal = np.sum(weighted_sales)    # 106.5\n\n# Or combine: weighted average\nweighted_avg = np.sum(sales * weights)\n\n\n\n# YOUR CODE BELOW\n# Create weighted moving average (last 7 days)\n# Weights: [0.05, 0.05, 0.10, 0.15, 0.20, 0.20, 0.25] (sum = 1.0)\nweights = np.array([0.05, 0.05, 0.10, 0.15, 0.20, 0.20, 0.25])\n\n# Calculate WMA for day 30 (using days 24-30)\nsales_window = df['sales'].iloc[24:31].values  # Days 24-30 (7 days)\nwma_day30 =   # Calculate weighted average: np.sum(sales * weights)\n\n# Compare to simple average for same window\nsma_day30 =   # Simple average: np.mean(sales_window)\n\n\n\nCode\n# Don't modify below\nassert 50 &lt; wma_day30 &lt; 150, f\"WMA should be between 50-150, got {wma_day30:.1f}\"\nassert abs(wma_day30 - sma_day30) &lt; 20, \"WMA and SMA shouldn't differ by more than 20\"\nassert len(weights) == 7, \"Should have 7 weights\"\nassert abs(sum(weights) - 1.0) &lt; 0.01, \"Weights should sum to 1.0\"\nprint(f\"✓ Excellent! Weighted MA: {wma_day30:.1f}, Simple MA: {sma_day30:.1f}\")",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#building-basic-forecast-functions",
    "href": "tutorials/nb_05_01_time_series.html#building-basic-forecast-functions",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Building Basic Forecast Functions",
    "text": "Building Basic Forecast Functions\n\ndef naive_forecast(data, periods=1):\n    \"\"\"Naive forecast: tomorrow = today (simplest baseline)\"\"\"\n    return [data.iloc[-1]] * periods\n\ndef moving_average_forecast(data, window=7, periods=1):\n    \"\"\"Forecast using moving average of last 'window' days\"\"\"\n    ma = data.iloc[-window:].mean()\n    return [ma] * periods\n\n# Example usage\nprint(f\"Last value: {df['sales'].iloc[-1]:.1f}\")\nprint(f\"Naive forecast (next 3 days): {naive_forecast(df['sales'], 3)}\")\nprint(f\"MA forecast (next 3 days): {moving_average_forecast(df['sales'], 7, 3)}\")\n\nLast value: 110.3\nNaive forecast (next 3 days): [np.float64(110.26466239914413), np.float64(110.26466239914413), np.float64(110.26466239914413)]\nMA forecast (next 3 days): [np.float64(117.69909865143963), np.float64(117.69909865143963), np.float64(117.69909865143963)]",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#understanding-exponential-smoothing",
    "href": "tutorials/nb_05_01_time_series.html#understanding-exponential-smoothing",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Understanding Exponential Smoothing",
    "text": "Understanding Exponential Smoothing\nThe Problem with Simple MA: All days in the window are treated equally. The sale from 7 days ago has the same importance as yesterday.\nExponential Smoothing Solution: Weight recent observations more heavily, and the weight decreases exponentially as you go back in time.\nThe Formula: \\[\\text{Forecast}_{t+1} = \\alpha \\times \\text{Actual}_t + (1-\\alpha) \\times \\text{Forecast}_t\\]\nWhere α (alpha) is between 0 and 1:\n\nα = 0.9: Very responsive (trust recent data heavily)\nα = 0.3: Balanced (typical default)\nα = 0.1: Very stable (smooth out noise)\n\n\n\n\n\n\n\nYou can also forecast multiple periods at once. The result is then just the last value of the forecast for all future periods.",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#exercise-3.1---implement-exponential-smoothing",
    "href": "tutorials/nb_05_01_time_series.html#exercise-3.1---implement-exponential-smoothing",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Exercise 3.1 - Implement Exponential Smoothing",
    "text": "Exercise 3.1 - Implement Exponential Smoothing\nCreate an exponential smoothing forecast function.\n\n\n\n\n\n\nTipExponential Smoothing Formula\n\n\n\nCore idea: New forecast = mix of (actual data) and (old forecast)\nFormula: forecast_new = α × actual_current + (1-α) × forecast_old\n\nα = 0.3 → 30% actual, 70% old forecast (smooth)\nα = 0.7 → 70% actual, 30% old forecast (reactive)\n\n\n\n\n\n\n\n\n\nNoteList Operations You’ll Need\n\n\n\n# Access last element\nlast_value = my_list[-1]\n\n# Multiply a list (creates repeated elements)\nfuture = [100] * 3  # [100, 100, 100]\n\n# In a loop, use data.iloc[i] to get value at index i\nfor i in range(1, len(data)):\n    current_value = data.iloc[i]\n\n\n\n# YOUR CODE BELOW\ndef exponential_smoothing_forecast(data, alpha=0.3, periods=1):\n    \"\"\"\n    Exponential smoothing forecast\n    Formula: forecast = alpha * latest_value + (1-alpha) * previous_forecast\n    For first forecast, use the first actual value\n    \"\"\"\n    forecasts = [data.iloc[0]]  # Start with first value\n\n    # Calculate smoothed values for historical data\n    for i in range(1, len(data)):\n        # Apply exponential smoothing formula\n        # Hint: data.iloc[i] is current actual, forecasts[-1] is previous forecast\n        forecast =   # alpha * current_actual + (1-alpha) * previous_forecast\n        forecasts.append(forecast)\n\n    # Use last smoothed value for future periods\n    last_forecast = forecasts[-1]\n    future =   # Return list: [last_forecast] * periods\n\n    return future\n\n# Test your function\ntest_data = pd.Series([100, 105, 98, 103, 107])\nresult = exponential_smoothing_forecast(test_data, alpha=0.3, periods=2)\n\n\n\nCode\n# Don't modify below\nassert len(result) == 2, \"Should return 2 forecasts\"\nassert 100 &lt; result[0] &lt; 105, f\"Forecast should be between 100-105, got {result[0]:.1f}\"\nassert result[0] == result[1], \"All future periods should have same forecast\"\nprint(f\"✓ Great! Exponential smoothing implemented correctly!\")\nprint(f\"  Forecast: {result[0]:.1f} for next 2 periods\")",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#understanding-time-series-aggregation",
    "href": "tutorials/nb_05_01_time_series.html#understanding-time-series-aggregation",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Understanding Time Series Aggregation",
    "text": "Understanding Time Series Aggregation\nBefore applying Holt’s method, we need to learn how to convert daily data to weekly data using resample().\nThe resample() Function:\ndf.set_index('date').resample('W')['sales'].mean()\nBreaking it down:\n\nset_index('date') - Makes the date column the index (required for resample)\nresample('W') - Groups data by week (‘W’ = week, ‘M’ = month, ‘D’ = day)\n['sales'] - Selects the sales column\n.mean() - Calculates the average for each week\n\nExample:\n\n# Convert daily Bean Counter sales to weekly averages\nweekly_sales = df.set_index('date').resample('W')['sales'].mean()\nprint(f\"Daily data: {len(df)} observations\")\nprint(f\"Weekly data: {len(weekly_sales)} observations\")\nprint(f\"\\nFirst 3 weeks:\")\nprint(weekly_sales.head(3))\n\n# Visualize the difference between daily and weekly data\nfig, axes = plt.subplots(2, 1, figsize=(14, 8))\n\n# Top: Daily data (noisy)\naxes[0].plot(df['date'], df['sales'], linewidth=0.8, alpha=0.7, color='#A7C7C6')\naxes[0].set_ylabel('Sales (drinks)', fontsize=11)\naxes[0].set_title('Daily Data - Noisy with lots of variation', fontsize=12, fontweight='bold')\naxes[0].grid(True, alpha=0.3)\n\n# Bottom: Weekly data (smooth)\naxes[1].plot(weekly_sales.index, weekly_sales.values, 'o-', linewidth=2, markersize=4,\n             alpha=0.8, color='#537E8F')\naxes[1].set_xlabel('Date', fontsize=11)\naxes[1].set_ylabel('Avg Sales (drinks/day)', fontsize=11)\naxes[1].set_title('Weekly Aggregated Data - Cleaner, easier to see patterns', fontsize=12, fontweight='bold')\naxes[1].grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\nDaily data: 1096 observations\nWeekly data: 158 observations\n\nFirst 3 weeks:\ndate\n2022-01-02    68.237589\n2022-01-09    62.470797\n2022-01-16    46.571824\nFreq: W-SUN, Name: sales, dtype: float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAggregating to weekly data reduces noise and makes trends easier to see! Notice how the weekly plot makes the trend much clearer.",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#understanding-holts-method",
    "href": "tutorials/nb_05_01_time_series.html#understanding-holts-method",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Understanding Holt’s Method",
    "text": "Understanding Holt’s Method\nThe Math (simplified):\n\nLevel: \\(L_t = \\alpha \\times Y_t + (1-\\alpha) \\times (L_{t-1} + b_{t-1})\\)\nTrend: \\(b_t = \\beta \\times (L_t - L_{t-1}) + (1-\\beta) \\times b_{t-1}\\)\nForecast: \\(\\hat{Y}_{t+h} = L_t + h \\times b_t\\)\n\nIn plain English:\n\nLevel smooths the current position\nTrend smooths the growth rate\nForecast = Current level + (periods ahead × trend)\n\nLet’s see Holt’s method in action using Python’s statsmodels library:\n\nfrom statsmodels.tsa.holtwinters import ExponentialSmoothing\n\n# Create sample trending data\nweeks = pd.date_range('2024-01-01', periods=20, freq='W')\ntrending_sales = 100 + 3*np.arange(20) + np.random.normal(0, 5, 20)\nts_trending = pd.Series(trending_sales, index=weeks)\n\n# Fit Holt's model (trend, but no seasonality)\nmodel_holt = ExponentialSmoothing(ts_trending, trend='add', seasonal=None)\nfitted_holt = model_holt.fit(smoothing_level=0.3, smoothing_trend=0.2)\n\n# Forecast next 4 periods\nforecast_holt = fitted_holt.forecast(steps=4)\n\nprint(\"Last 3 actual values:\")\nprint(ts_trending.tail(3))\nprint(f\"\\nNext 4 week forecast with Holt's method:\")\nprint(forecast_holt)\nprint(\"\\nNotice: Forecasts increase each week (captures trend!)\")\n\nLast 3 actual values:\n2024-05-05    147.700470\n2024-05-12    156.602208\n2024-05-19    165.404895\nFreq: W-SUN, dtype: float64\n\nNext 4 week forecast with Holt's method:\n2024-05-26    161.150728\n2024-06-02    164.553567\n2024-06-09    167.956406\n2024-06-16    171.359244\nFreq: W-SUN, dtype: float64\n\nNotice: Forecasts increase each week (captures trend!)",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#exercise-4.1---apply-holts-method-to-bean-counter",
    "href": "tutorials/nb_05_01_time_series.html#exercise-4.1---apply-holts-method-to-bean-counter",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Exercise 4.1 - Apply Holt’s Method to Bean Counter",
    "text": "Exercise 4.1 - Apply Holt’s Method to Bean Counter\nBean Counter’s sales are growing. Use Holt’s method to capture this trend.\n\n# Prepare weekly data (aggregate daily to weekly to reduce noise)\ndf_weekly = df.set_index('date').resample('W')['sales'].mean()\n\n# YOUR CODE BELOW\n# Split: first 90 weeks for training, last 14 for testing\ntrain_weekly =   # First 90 weeks\ntest_weekly =    # Last 14 weeks\n\n# Fit Holt's model\nmodel_holt =   # ExponentialSmoothing with trend='add', seasonal=None\nfitted_holt =  # Fit the model\nholt_forecast =  # Forecast 14 weeks\n\n\n\nCode\n# Don't modify below\nassert len(holt_forecast) == 14, \"Should forecast 14 weeks\"\nassert holt_forecast.iloc[0] &gt; holt_forecast.iloc[-1], \"Holt's forecast should decrease (season!)\"\nprint(f\"Excellent! Holt's method applied successfully!\")\nprint(f\"Holt's captures negative trend: {holt_forecast.iloc[0]:.1f} → {holt_forecast.iloc[-1]:.1f}\")\n\n# Create comparison forecast with simple exponential smoothing\nsimple_forecast_weekly = exponential_smoothing_forecast(train_weekly, alpha=0.3, periods=14)\n\n# Visualize comparison\nplt.figure(figsize=(12, 8))\n\n# Plot historical training data (last 30 weeks for context)\nplt.plot(train_weekly.index[-90:], train_weekly.values[-90:], 'o-', color='#537E8F',\n         linewidth=1.5, markersize=2, alpha=0.5, label='Historical (last 30 weeks)')\n\n# Plot actual test data\nplt.plot(test_weekly.index[:14], test_weekly.values[:14], 'o', color='black',\n         markersize=2, alpha=0.9, label='Actual', zorder=5)\n\n# Plot both forecasts\nplt.plot(test_weekly.index[:14], simple_forecast_weekly, 's--', color='#A7C7C6',\n         linewidth=2, markersize=3, label='Simple ES (flat)', alpha=0.8)\nplt.plot(test_weekly.index[:14], holt_forecast, 'd-', color='#F6B265',\n         linewidth=2.5, markersize=3, label=\"Holt's Method (with trend)\")\n\nplt.xlabel('Week', fontsize=12)\nplt.ylabel('Average Daily Sales', fontsize=12)\nplt.legend(loc='best', fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#understanding-holt-winters",
    "href": "tutorials/nb_05_01_time_series.html#understanding-holt-winters",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Understanding Holt-Winters",
    "text": "Understanding Holt-Winters\nWhen to use:\n\nData has trend AND seasonality\nYou have ideally 2 full seasonal cycles (e.g., 2 years for yearly patterns)\n\nLet’s demonstrate with monthly data:\n\n# Create data with trend AND seasonality\nmonths = pd.date_range('2022-01-01', periods=24, freq='M')\ntrend_comp = np.linspace(100, 150, 24)\nseasonal_comp = 30 * np.sin(2 * np.pi * np.arange(24) / 12)\nmonthly_sales = trend_comp + seasonal_comp + np.random.normal(0, 5, 24)\nts_seasonal = pd.Series(monthly_sales, index=months)\n\n# Fit Holt-Winters model\nmodel_hw = ExponentialSmoothing(\n    ts_seasonal,\n    trend='add',           # Additive trend\n    seasonal='add',        # Additive seasonality\n    seasonal_periods=12    # 12 months = 1 year\n)\nfitted_hw = model_hw.fit()\n\n# Forecast next 6 months\nforecast_hw = fitted_hw.forecast(steps=6)\n\nprint(\"Last 3 months actual:\")\nprint(ts_seasonal.tail(3))\nprint(f\"\\nNext 6 months forecast:\")\nprint(forecast_hw)\nprint(\"\\nNotice: Seasonal pattern continues (Jan is low, summer will be high)\")\n\nLast 3 months actual:\n2023-10-31    121.824928\n2023-11-30    121.818264\n2023-12-31    134.481744\nFreq: ME, dtype: float64\n\nNext 6 months forecast:\n2024-01-31    157.483905\n2024-02-29    175.816373\n2024-03-31    184.848236\n2024-04-30    187.735748\n2024-05-31    181.651676\n2024-06-30    183.597933\nFreq: ME, dtype: float64\n\nNotice: Seasonal pattern continues (Jan is low, summer will be high)\n\n\n/var/folders/_5/jkkjxxdd5f1955l380dky7n80000gn/T/ipykernel_91251/3645223708.py:2: FutureWarning: 'M' is deprecated and will be removed in a future version, please use 'ME' instead.\n  months = pd.date_range('2022-01-01', periods=24, freq='M')",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#exercise-5.1---apply-holt-winters",
    "href": "tutorials/nb_05_01_time_series.html#exercise-5.1---apply-holt-winters",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Exercise 5.1 - Apply Holt-Winters",
    "text": "Exercise 5.1 - Apply Holt-Winters\nNow use Holt-Winters to capture both trend and seasonality in Bean Counter’s weekly sales.\nNote: For weekly data with yearly seasonality, we need 2+ years (104+ weeks). We’ll use quarterly seasonality (13 weeks) since we have 104 weeks total.\n\n# YOUR CODE BELOW\n# Use the weekly data we created earlier\n# Split: first 150 weeks training, last 8 weeks testing\ntrain_hw = df_weekly.iloc[:150]\ntest_hw = df_weekly.iloc[150:158]  # Exactly 8 weeks for testing (all remaining data)\n\n# Fit Holt-Winters with yearly seasonality (52 weeks = 1 year)\nmodel_hw =   # ExponentialSmoothing with trend='add', seasonal='add', seasonal_periods=52\nfitted_hw =  # Fit the model\nhw_forecast =  # Forecast 8 weeks\n\n# Compare all three methods on same test period\nsimple_forecast = exponential_smoothing_forecast(train_hw, alpha=0.3, periods=8)\nholt_forecast_test = ExponentialSmoothing(train_hw, trend='add', seasonal=None).fit().forecast(8)\n\n\n\nCode\n# Don't modify below\nassert len(hw_forecast) == 8, \"Should forecast 8 weeks\"\n# Holt-Winters should vary (seasonality), simple ES should be flat\nhw_variation = hw_forecast.std()\nsimple_variation = np.std(simple_forecast)\nassert hw_variation &gt; simple_variation, \"Holt-Winters should show more variation (seasonality)\"\nprint(f\"Fantastic! Holt-Winters applied successfully!\")\nprint(f\"Holt-Winters range: {hw_forecast.min():.1f} to {hw_forecast.max():.1f}\")\nprint(f\"Simple ES (flat): {simple_forecast[0]:.1f}\")",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#forecast-error-metrics",
    "href": "tutorials/nb_05_01_time_series.html#forecast-error-metrics",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Forecast Error Metrics",
    "text": "Forecast Error Metrics\n\ndef calculate_mae(actual, forecast):\n    \"\"\"Mean Absolute Error - average size of errors\"\"\"\n    errors = np.abs(actual - forecast)\n    return np.mean(errors)\n\ndef calculate_rmse(actual, forecast):\n    \"\"\"Root Mean Squared Error - penalizes large errors more\"\"\"\n    errors = (actual - forecast) ** 2\n    return np.sqrt(np.mean(errors))\n\n# Example\nactual = np.array([100, 105, 98, 103])\nforecast = np.array([102, 103, 100, 101])\nprint(f\"MAE: {calculate_mae(actual, forecast):.1f} (average error)\")\nprint(f\"RMSE: {calculate_rmse(actual, forecast):.1f} (penalizes big errors)\")\n\nMAE: 2.0 (average error)\nRMSE: 2.0 (penalizes big errors)\n\n\n\n\n\n\n\n\nTipMAE vs RMSE\n\n\n\n\nMAE: Average error size (easier to interpret, in same units as data)\nRMSE: Penalizes large errors more heavily (sensitive to outliers)\nIn business: MAE often preferred for its simplicity and interpretability",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_05_01_time_series.html#exercise-6.1---compare-all-methods",
    "href": "tutorials/nb_05_01_time_series.html#exercise-6.1---compare-all-methods",
    "title": "Notebook 5.1 - Time Series Forecasting",
    "section": "Exercise 6.1 - Compare All Methods",
    "text": "Exercise 6.1 - Compare All Methods\nLet’s have a forecasting comparison! Which method works best for Bean Counter?\n\n# YOUR CODE BELOW\n# Calculate MAE for all methods on the test period (last 8 weeks)\ntest_actual = test_hw.values\n\n# Convert forecasts to numpy arrays for comparison\nsimple_array = np.array(simple_forecast)\nholt_array = holt_forecast_test.values\nhw_array = hw_forecast.values\n\n# Calculate MAE for each method\nmae_simple =   # MAE for simple exponential smoothing\nmae_holt =     # MAE for Holt's method\nmae_hw =       # MAE for Holt-Winters\n\n# Find the winner (lowest MAE)\nmae_values = [mae_simple, mae_holt, mae_hw]\nbest_method_index = np.argmin(mae_values) # Index of best method\n\n\n\nCode\n# Don't modify below\nmethods = ['Simple ES', \"Holt's Method\", 'Holt-Winters']\nprint(\"Forecast accuracy comparison complete!\")\nprint(f\"\\nWinner: {methods[best_method_index]}\")\n\n# Visualize the comparison\nplt.figure(figsize=(12, 8))\n\n# Plot historical training data\nplt.plot(train_hw.index[-30:], train_hw.values[-30:], 'o-', color='#537E8F',\n         linewidth=1.5, markersize=3, alpha=0.5, label='Historical (last 30 weeks)')\n\n# Plot actual test data\nplt.plot(test_hw.index, test_hw.values, 'o', color='black',\n         markersize=10, alpha=0.9, label='Actual (Test)', zorder=5)\n\n# Plot all three forecasts\nplt.plot(test_hw.index, simple_array, 's--', color='#A7C7C6',\n         linewidth=2, markersize=3, label=f'Simple ES (MAE: {mae_simple:.1f})')\nplt.plot(test_hw.index, holt_array, '^--', color='#F6B265',\n         linewidth=2, markersize=3, label=f\"Holt's (MAE: {mae_holt:.1f})\")\nplt.plot(test_hw.index, hw_array, 'd--', color='#DB6B6B',\n         linewidth=2.5, markersize=3, label=f'Holt-Winters (MAE: {mae_hw:.1f})')\n\nplt.xlabel('Week', fontsize=12)\nplt.ylabel('Average Daily Sales', fontsize=12)\nplt.title('Method Comparison: Which Captures Trend + Seasonality Best?', fontsize=14, fontweight='bold')\nplt.legend(loc='best', fontsize=10)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "05 Forecasting",
      "NB-05-01 Time Series"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html",
    "href": "tutorials/nb_04_01_monte_carlo.html",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "",
    "text": "Welcome back to Bean Counter, CEO! In the lecture, we saw how Monte Carlo simulation helps us make decisions when the future is uncertain. Now it’s time to apply these techniques to expand your coffee empire and prepare for the TechVenture competition.\nYour CEO Challenge: Bean Counter Expansion - analyzing single locations and portfolios for strategic growth\nKey Skills for Competition:\n\nSimulating uncertain returns\nAnalyzing risk metrics\nComparing portfolio combinations\nMaking data-driven recommendations\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom itertools import combinations # Allows us to generate all portfolio combinations\n\n# Set seed for reproducibility\nnp.random.seed(42)\nprint(\"Libraries loaded! Let's analyze Bean Counter expansion opportunities ☕\")\n\nLibraries loaded! Let's analyze Bean Counter expansion opportunities ☕",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#understanding-np.random",
    "href": "tutorials/nb_04_01_monte_carlo.html#understanding-np.random",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Understanding np.random",
    "text": "Understanding np.random\n\n# Example: Daily customer traffic follows a normal distribution\n# Historical data shows: mean = 100, std = 20\n\n# Simulate one day\none_day_customers = np.random.normal(100, 20)\nprint(f\"One random day: {one_day_customers:.0f} customers\")\n\n# Simulate many days to see the pattern\nmany_days = np.random.normal(100, 20, size=1000)\nprint(f\"\\n1000 days simulation:\")\nprint(f\"  Mean: {many_days.mean():.1f} (expected: 100)\")\nprint(f\"  Std Dev: {many_days.std():.1f} (expected: 20)\")\nprint(f\"  Min: {many_days.min():.0f}, Max: {many_days.max():.0f}\")\n\nOne random day: 110 customers\n\n1000 days simulation:\n  Mean: 100.4 (expected: 100)\n  Std Dev: 19.6 (expected: 20)\n  Min: 35, Max: 177",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#exercise-1.1---simulate-purchase-amounts",
    "href": "tutorials/nb_04_01_monte_carlo.html#exercise-1.1---simulate-purchase-amounts",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Exercise 1.1 - Simulate Purchase Amounts",
    "text": "Exercise 1.1 - Simulate Purchase Amounts\nAverage purchase per customer varies uniformly between €8 and €12. Simulate 10,000 purchase amounts.\n\n# YOUR CODE BELOW\n# Simulate 10,000 purchase amounts uniformly distributed between 8 and 12\npurchase_amounts =\n\n# Calculate statistics\nmean_purchase =\nmin_purchase =\nmax_purchase =\n\n\n\nCode\n# Don't modify below - these test your solution\nassert len(purchase_amounts) == 10_000, \"Should have 10,000 simulations\"\nassert 9.9 &lt; mean_purchase &lt; 10.1, f\"Mean should be ~10, got {mean_purchase:.2f}\"\nassert 8 &lt;= min_purchase &lt; 9, f\"Min should be ~8, got {min_purchase:.2f}\"\nassert 11 &lt; max_purchase &lt;= 12, f\"Max should be ~12, got {max_purchase:.2f}\"\nprint(\"Great, the purchase simulation is correct!\")",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#exercise-1.2---calculate-probabilities",
    "href": "tutorials/nb_04_01_monte_carlo.html#exercise-1.2---calculate-probabilities",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Exercise 1.2 - Calculate Probabilities",
    "text": "Exercise 1.2 - Calculate Probabilities\nUsing your simulated data from the previous task, calculate key probabilities.\n\n\n\n\n\n\nNoteBoolean Operations and Probabilities\n\n\n\n# Create boolean array (True/False)\ndata = np.array([50, 150, 80, 200])\nhigh_values = data &gt; 100  # [False, True, False, True]\n\n# Calculate probability: mean of boolean = proportion of True\nprob = (data &gt; 100).mean()  # 0.5 = 50%\n\n# Combine conditions with & (and) or | (or)\nprob_range = ((data &gt;= 80) & (data &lt;= 150)).mean()\n\n\n\n# YOUR CODE BELOW\n# Using the many_days array from above (1000 days of customer data)\n# Calculate the probability of different scenarios\n\n# Probability of getting more than 120 customers\nprob_high =\n\n# Probability of getting fewer than 80 customers\nprob_low =\n\n# Probability of being within one std dev of mean (80-120)\n# Hint: Use & to combine two conditions\nprob_normal =\n\n\n\nCode\n# Don't modify below\nassert 0.10 &lt; prob_high &lt; 0.20, f\"High probability should be ~0.16, got {prob_high:.3f}\"\nassert 0.10 &lt; prob_low &lt; 0.20, f\"Low probability should be ~0.16, got {prob_low:.3f}\"\nassert 0.65 &lt; prob_normal &lt; 0.72, f\"Normal range probability should be ~0.68, got {prob_normal:.3f}\"\nprint(f\"  P(&gt;120): {prob_high:.1%}\")\nprint(f\"  P(&lt;80): {prob_low:.1%}\")\nprint(f\"  P(80-120): {prob_normal:.1%}\")\nprint(\"Wonderful, probability calculations correct!\")",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#the-bean-counter-store-model",
    "href": "tutorials/nb_04_01_monte_carlo.html#the-bean-counter-store-model",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "The Bean Counter Store Model",
    "text": "The Bean Counter Store Model\n\ndef simulate_bean_counter_day(mean_customers=100, std_customers=20,\n                            min_purchase=8, max_purchase=12,\n                            fixed_costs=500, variable_cost_rate=0.35):\n    \"\"\"Simulate one day of Bean Counter store operations\"\"\"\n    # Uncertain variables\n    customers = np.random.normal(mean_customers, std_customers)\n    avg_purchase = np.random.uniform(min_purchase, max_purchase)\n\n    # Business calculations\n    revenue = customers * avg_purchase\n    variable_costs = variable_cost_rate * revenue\n    profit = revenue - fixed_costs - variable_costs\n\n    return {\n        'customers': customers,\n        'avg_purchase': avg_purchase,\n        'revenue': revenue,\n        'profit': profit\n    }\n\n# Test one simulation\none_day = simulate_bean_counter_day()\nprint(f\"One day at Bean Counter:\")\nprint(f\"  Customers: {one_day['customers']:.0f}\")\nprint(f\"  Avg purchase: €{one_day['avg_purchase']:.2f}\")\nprint(f\"  Revenue: €{one_day['revenue']:.2f}\")\nprint(f\"  Profit: €{one_day['profit']:.2f}\")\n\nOne day at Bean Counter:\n  Customers: 118\n  Avg purchase: €9.73\n  Revenue: €1153.10\n  Profit: €249.52\n\n\n\n\n\n\n\n\nWhen running simulations, we can typically:\n\nCreate an empty list to store results: results = []\nRun simulations in a loop, each time calling the simulation function\nAppend each result (dictionary) to the list: results.append(day_result)\nConvert the list of dictionaries to a DataFrame: pd.DataFrame(results)\n\nThis pattern is a common way to collect multiple simulation outcomes!",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#working-with-dataframes-for-simulation-results",
    "href": "tutorials/nb_04_01_monte_carlo.html#working-with-dataframes-for-simulation-results",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Working with DataFrames for Simulation Results",
    "text": "Working with DataFrames for Simulation Results\nWhen we run multiple simulations, we need to collect and analyze the results efficiently. Pandas DataFrames are perfect for this task.\n\nCreating DataFrames from Simulation Results\n\n# Example: Create a DataFrame from a few simulations\nsample_results = []\nfor i in range(5):\n    day_result = simulate_bean_counter_day()\n    sample_results.append(day_result)\n\n# Convert list of dictionaries to DataFrame\nsample_df = pd.DataFrame(sample_results)\nprint(\"Sample DataFrame structure:\")\nprint(sample_df)\nprint(f\"\\nDataFrame shape: {sample_df.shape}\")\nprint(f\"Columns: {list(sample_df.columns)}\")\n\nSample DataFrame structure:\n    customers  avg_purchase     revenue      profit\n0  104.435416      8.464214  883.963690   74.576399\n1   72.342082      8.092427  585.423044 -119.475021\n2  108.748490      8.271705  899.535406   84.698014\n3   84.989056      8.432641  716.682235  -34.156547\n4   37.171709     11.806321  438.861139 -214.740259\n\nDataFrame shape: (5, 4)\nColumns: ['customers', 'avg_purchase', 'revenue', 'profit']\n\n\n\n\nComputing Statistics with DataFrames\n\n# Specific calculations\nprint(f\"\\nMean profit: €{sample_df['profit'].mean():.2f}\")\nprint(f\"Standard deviation of profit: €{sample_df['profit'].std():.2f}\")\nprint(f\"Minimum profit: €{sample_df['profit'].min():.2f}\")\nprint(f\"Maximum profit: €{sample_df['profit'].max():.2f}\")\n\n# Conditional analysis\nloss_days = sample_df['profit'] &lt; 0\nprint(f\"Number of loss days: {loss_days.sum()}\")\nprint(f\"Probability of loss: {loss_days.mean():.1%}\")\n\n# Range analysis\nprofit_range = (sample_df['profit'] &gt;= 100) & (sample_df['profit'] &lt;= 200)\nprint(f\"Days with profit €100-200: {profit_range.sum()}\")\nprint(f\"Percentage in range: {profit_range.mean():.1%}\")\n\n\nMean profit: €-41.82\nStandard deviation of profit: €128.01\nMinimum profit: €-214.74\nMaximum profit: €84.70\nNumber of loss days: 3\nProbability of loss: 60.0%\nDays with profit €100-200: 0\nPercentage in range: 0.0%\n\n\n\n\nAccessing Specific Rows with iloc\n\n# iloc uses integer positions to access rows and columns\nprint(\"Using iloc to access specific simulation results:\")\n\n# Access first simulation (row 0)\nprint(f\"First simulation: {sample_df.iloc[0]}\")\n\n# Access last simulation\nprint(f\"\\nLast simulation profit: €{sample_df.iloc[-1]['profit']:.2f}\")\n\n# Access multiple rows (first 3 simulations)\nprint(f\"\\nFirst 3 simulations:\")\nprint(sample_df.iloc[0:3])\n\n# Access specific rows and columns\nprint(f\"\\nProfit from simulations 1, 3, and 4:\")\nprint(sample_df.iloc[[1, 3, 4]]['profit'])\n\n# Random sample using iloc\nimport random\nrandom_indices = random.sample(range(len(sample_df)), 2)\nprint(f\"\\nTwo random simulations (indices {random_indices}):\")\nprint(sample_df.iloc[random_indices][['customers', 'profit']])\n\nUsing iloc to access specific simulation results:\nFirst simulation: customers       104.435416\navg_purchase      8.464214\nrevenue         883.963690\nprofit           74.576399\nName: 0, dtype: float64\n\nLast simulation profit: €-214.74\n\nFirst 3 simulations:\n    customers  avg_purchase     revenue      profit\n0  104.435416      8.464214  883.963690   74.576399\n1   72.342082      8.092427  585.423044 -119.475021\n2  108.748490      8.271705  899.535406   84.698014\n\nProfit from simulations 1, 3, and 4:\n1   -119.475021\n3    -34.156547\n4   -214.740259\nName: profit, dtype: float64\n\nTwo random simulations (indices [2, 4]):\n    customers      profit\n2  108.748490   84.698014\n4   37.171709 -214.740259\n\n\n\n\n\n\n\n\nNoteKey DataFrame Operations for Simulations\n\n\n\n\ndf['column'].mean() - Calculate average\ndf['column'].std() - Calculate standard deviation\ndf['column'].min() / df['column'].max() - Find extremes\n(df['column'] &lt; value).mean() - Calculate probability\n(df['column'] &gt;= low) & (df['column'] &lt;= high) - Range conditions\ndf.iloc[i] - Access row i by position\ndf.iloc[start:end] - Access rows from start to end\ndf.iloc[[list]] - Access specific rows by list of indices",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#exercise-2.1---run-multiple-simulations",
    "href": "tutorials/nb_04_01_monte_carlo.html#exercise-2.1---run-multiple-simulations",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Exercise 2.1 - Run Multiple Simulations",
    "text": "Exercise 2.1 - Run Multiple Simulations\nSimulate 10,000 days of Bean Counter operations and analyze the results.\n\n\n\n\n\n\nNoteSimulation Loop Pattern\n\n\n\n# Standard Monte Carlo pattern\nresults = []  # Empty list to collect results\n\nfor i in range(n_simulations):\n    result = simulate_function()  # Run one simulation\n    results.append(result)        # Add to list\n\n# Convert to DataFrame for analysis\ndf = pd.DataFrame(results)\n\n\n\n# YOUR CODE BELOW\n# Run 10,000 simulations of Bean Counter store\nn_simulations = 10_000\nresults = []\n\nfor i in range(n_simulations):\n    # Simulate one day and add to results\n\n\n# Calculate key metrics (Tip: a DataFrame could help here!)\ndf =  # Convert results to DataFrame\nmean_profit =  # Average of 'profit' column\nprob_loss =  # Probability profit &lt; 0\nmax_profit =  # Maximum profit\n\n\n\nCode\n# Don't modify below\nassert len(df) == 10_000, \"Should have 10,000 simulations\"\nassert 100 &lt; mean_profit &lt; 200, f\"Mean profit should be ~150, got {mean_profit:.2f}\"\nassert 0.12 &lt; prob_loss &lt; 0.18, f\"Probability of loss should be ~15%, got {prob_loss:.1%}\"\nassert max_profit &gt; 500, f\"Max profit should be &gt;500, got {max_profit:.2f}\"\nprint(\"Very good, the simulation is correct!\")\nprint(f\"  Mean daily profit: €{mean_profit:.2f}\")\nprint(f\"  Probability of loss: {prob_loss:.1%}\")",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#exercise-2.2---visualize-the-distribution",
    "href": "tutorials/nb_04_01_monte_carlo.html#exercise-2.2---visualize-the-distribution",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Exercise 2.2 - Visualize the Distribution",
    "text": "Exercise 2.2 - Visualize the Distribution\nCreate a histogram of profit distribution and the percentage of profits between 100 and 400 Euro with key markers based on the results before.\n\n# YOUR CODE BELOW\n\n# Calculate what percentage of profits are between €100 and €400\nprob_target_range =\n\n\n# Create a histogram of the profit distribution with 50 bins\n\n\n\nCode\n# Don't modify below\nassert 0.5 &lt; prob_target_range &lt; 0.6, f\"Should be ~55% in range, got {prob_target_range:.1%}\"\nprint(f\"Visualization complete! {prob_target_range:.1%} of days have profit €100-400\")",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#value-at-risk-var",
    "href": "tutorials/nb_04_01_monte_carlo.html#value-at-risk-var",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Value at Risk (VaR)",
    "text": "Value at Risk (VaR)\n\n# Value at Risk: \"What's the worst-case scenario in X% of cases?\"\n# Convert DataFrame column to NumPy array for statistical calculations\nprofits_array = df['profit'].values\n\n# 5% VaR: The profit level that we'll exceed 95% of the time\nvar_5 = np.percentile(profits_array, 5)\nprint(f\"Value at Risk (5%): €{var_5:.2f}\")\nprint(f\"Interpretation: There's a 5% chance of daily profit below €{var_5:.2f}\")\n\n# 1% VaR: More extreme scenario\nvar_1 = np.percentile(profits_array, 1)\nprint(f\"\\nValue at Risk (1%): €{var_1:.2f}\")\nprint(f\"Interpretation: There's a 1% chance of daily profit below €{var_1:.2f}\")\n\n# Standard deviation\nstd_dev = np.std(profits_array)\nprint(f\"\\nStandard deviation: €{std_dev:.2f}\")\nprint(f\"Interpretation: Daily profit typically varies by €{std_dev:.2f} from the mean\")\n#\n\nValue at Risk (5%): €-85.35\nInterpretation: There's a 5% chance of daily profit below €-85.35\n\nValue at Risk (1%): €-168.99\nInterpretation: There's a 1% chance of daily profit below €-168.99\n\nStandard deviation: €150.82\nInterpretation: Daily profit typically varies by €150.82 from the mean",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#exercise-3.1---calculate-risk-metrics",
    "href": "tutorials/nb_04_01_monte_carlo.html#exercise-3.1---calculate-risk-metrics",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Exercise 3.1 - Calculate Risk Metrics",
    "text": "Exercise 3.1 - Calculate Risk Metrics\nCalculate comprehensive risk metrics for the coffee shop.\n\n# YOUR CODE BELOW\n# Calculate various risk metrics\n\n# Standard deviation (volatility)\nvolatility =\n\n# Probability of making at least €200 profit\nprob_good_day =\n\n# Expected Shortfall: average profit in worst 10% of days\nworst_10_pct_threshold = np.percentile(profits_array, 10)\nworst_days = profits_array[profits_array &lt;= worst_10_pct_threshold]\nexpected_shortfall =\n\n\n\nCode\n# Don't modify below\nassert 140 &lt; volatility &lt; 160, f\"Volatility should be ~150, got {volatility:.2f}\"\nassert 0.25 &lt; prob_good_day &lt; 0.45, f\"Probability should be ~35%, got {prob_good_day:.1%}\"\nassert -125 &lt; expected_shortfall &lt; -75, f\"ES should be ~100, got {expected_shortfall:.2f}\"\nprint(\"Risk metrics correct!\")\nprint(f\"  Volatility: €{volatility:.2f}\")\nprint(f\"  P(Profit ≥ €200): {prob_good_day:.1%}\")\nprint(f\"  Expected Shortfall (10%): €{expected_shortfall:.2f}\")",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#simulating-multiple-locations",
    "href": "tutorials/nb_04_01_monte_carlo.html#simulating-multiple-locations",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Simulating Multiple Locations",
    "text": "Simulating Multiple Locations\n\n# Bean Counter is considering 4 different expansion locations with different characteristics\ndef simulate_location(location_params, n_days=10_000):\n    \"\"\"Simulate n_days for a specific location\"\"\"\n    profits = []\n    for _ in range(n_days):\n        customers = np.random.normal(location_params['mean_customers'],\n                                    location_params['std_customers'])\n        avg_purchase = np.random.uniform(location_params['min_purchase'],\n                                        location_params['max_purchase'])\n        revenue = customers * avg_purchase\n        variable_costs = location_params['variable_rate'] * revenue\n        profit = revenue - location_params['fixed_costs'] - variable_costs\n        profits.append(profit)\n    return np.array(profits)\n\n# Define 4 different Bean Counter expansion locations\nlocations = {\n    'Downtown': {\n        'mean_customers': 150, 'std_customers': 30,\n        'min_purchase': 10, 'max_purchase': 15,\n        'fixed_costs': 800, 'variable_rate': 0.35\n    },\n    'Campus': {\n        'mean_customers': 200, 'std_customers': 60,\n        'min_purchase': 6, 'max_purchase': 10,\n        'fixed_costs': 600, 'variable_rate': 0.40\n    },\n    'Suburb': {\n        'mean_customers': 80, 'std_customers': 15,\n        'min_purchase': 12, 'max_purchase': 18,\n        'fixed_costs': 400, 'variable_rate': 0.30\n    },\n    'Airport': {\n        'mean_customers': 120, 'std_customers': 40,\n        'min_purchase': 15, 'max_purchase': 25,\n        'fixed_costs': 1200, 'variable_rate': 0.45\n    }\n}\n\n# Simulate all locations\nprint(\"Simulating 4 locations...\")\nlocation_profits = {}\nfor name, params in locations.items():\n    location_profits[name] = simulate_location(params)\n    print(f\"  {name}: Mean profit €{location_profits[name].mean():.2f}\")\n\nSimulating 4 locations...\n  Downtown: Mean profit €419.40\n  Campus: Mean profit €361.12\n  Suburb: Mean profit €438.15\n  Airport: Mean profit €115.67",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#exercise-4.1---analyze-all-portfolio-combinations",
    "href": "tutorials/nb_04_01_monte_carlo.html#exercise-4.1---analyze-all-portfolio-combinations",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Exercise 4.1 - Analyze All Portfolio Combinations",
    "text": "Exercise 4.1 - Analyze All Portfolio Combinations\nBean Counter can afford to open exactly 2 new locations. Which pair should they choose for maximum profitability?\n\n# Analyze all possible pairs of locations\n# Get all combinations of 2 locations\nlocation_names = list(locations.keys())\npairs = list(combinations(location_names, 2))\n\n# YOUR CODE BELOW\n\n# Analyze each portfolio\nportfolio_results = []\n\nfor pair in pairs:\n    # Get profits for each location in the pair\n    profits_1 = location_profits[pair[0]]\n    profits_2 = location_profits[pair[1]]\n\n    # Portfolio assumes you open two locations\n    portfolio_profit = # Your task!\n\n    # Calculate metrics\n    result = {\n        'pair': f\"{pair[0]} + {pair[1]}\",\n        'mean': , # Your task!\n        'std': , # Your task!\n        'prob_loss': , # Your task!\n        'var_5': # Your task!\n    }\n    portfolio_results.append(result)\n\n# Convert to DataFrame and sort by mean profit\ndf_portfolios = pd.DataFrame(portfolio_results)\ndf_portfolios = df_portfolios.sort_values('mean', ascending=False)\n\n# Find best portfolio by mean return (include only the variable name and the value!)\nbest_mean_portfolio = # Your task!\nbest_mean_value = # Your task!\n\n\n\nCode\n# Don't modify below\nassert len(portfolio_results) == 6, \"Should have 6 portfolio combinations\"\nassert 'Downtown + Suburb' in best_mean_portfolio or 'Suburb + Downtown' in best_mean_portfolio, \\\n    f\"Best mean portfolio should include Downtown + Suburb, got {best_mean_portfolio}\"\nassert 700 &lt; best_mean_value &lt; 900, f\"Best mean should be ~800, got {best_mean_value:.2f}\"\nprint(\"Portfolio analysis correct!\")\nprint(\"\\nAll Portfolio Combinations:\")\nprint(df_portfolios.to_string(index=False))",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#visualizing-risk-return-tradeoffs",
    "href": "tutorials/nb_04_01_monte_carlo.html#visualizing-risk-return-tradeoffs",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Visualizing Risk-Return Tradeoffs",
    "text": "Visualizing Risk-Return Tradeoffs\n\n# Create risk-return scatter plot for Bean Counter expansion\nplt.figure(figsize=(10, 6))\n\nfor _, row in df_portfolios.iterrows():\n    plt.scatter(row['std'], row['mean'], s=100, alpha=0.7)\n    plt.annotate(row['pair'], (row['std'], row['mean']),\n                fontsize=9, xytext=(5, 5), textcoords='offset points')\n\nplt.xlabel('Risk (Standard Deviation)')\nplt.ylabel('Expected Daily Profit (€)')\nplt.title('Risk-Return Profile of Bean Counter Portfolio Options')\nplt.grid(True, alpha=0.3)\nplt.show()",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#exercise-5.1---final-ceo-recommendation",
    "href": "tutorials/nb_04_01_monte_carlo.html#exercise-5.1---final-ceo-recommendation",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Exercise 5.1 - Final CEO Recommendation",
    "text": "Exercise 5.1 - Final CEO Recommendation\nBased on your analysis, make a strategic expansion recommendation for Bean Counter.\n\n# YOUR CODE BELOW\n# Which portfolio maximizes expected profit? (Only the name)\nmax_profit_portfolio =\n\n# Which portfolio minimizes risk (lowest std)? (Only the name)\nmin_risk_portfolio =\n\n# Your final recommendation (choose one)\nfinal_recommendation = # Choose the portfolio you would recommend\n\n\n\nCode\n# Don't modify below\nassert final_recommendation in df_portfolios['pair'].values, \"Must choose an actual portfolio\"\nprint(f\"\\nYour Recommendation: {final_recommendation}\")",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_04_01_monte_carlo.html#key-differences-for-competition",
    "href": "tutorials/nb_04_01_monte_carlo.html#key-differences-for-competition",
    "title": "Notebook 4.1 - Monte Carlo Simulation Practice",
    "section": "Key Differences for Competition",
    "text": "Key Differences for Competition\nThe competition uses:\n\nInvestment returns instead of daily profits\nDifferent distributions (some normal, one uniform)\nLarger scale (€1M investments vs daily operations)\n\nBut the approach is identical! Apply what you’ve learned here.\n\n\n\n\n\n\nJust as you’ve optimized Bean Counter’s expansion, use scoring functions in the competition to make objective decisions when multiple factors matter. Your journey from Barista Trainee to CEO has prepared you for this!\n\n\n\nGood luck in the TechVenture Investment Challenge, CEO!",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-01 Monte Carlo"
    ]
  },
  {
    "objectID": "tutorials/nb_03_02_pandas.html",
    "href": "tutorials/nb_03_02_pandas.html",
    "title": "Notebook 3.2 - Pandas for CEO Data Management",
    "section": "",
    "text": "Welcome back to the CEO suite at Bean Counter!\nYour Data Challenge as CEO\nNow that you’ve mastered NumPy for numerical analysis, you face a new challenge: Bean Counter’s data comes in spreadsheets, CSVs, and databases. You have:\n\nSales reports from 50+ locations\nProduct catalogs with thousands of items\nCustomer data with demographics and preferences\nSupplier information across multiple regions\n\nThe Problem: This data has labels, categories, dates, and mixed types. NumPy arrays aren’t enough, you need something more powerful!\nYour Tool: Pandas - Think of it as Excel but better, capable of handling millions of rows.\nIn this tutorial, you’ll learn to wrangle business data, turning spreadsheets into actionable insights.\n\n\n\n\n\n\nExcel cannot have more than 1 million rows!\n\n\n\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nFirst import pandas and numpy. Work through exercises marked “YOUR CODE BELOW”.",
    "crumbs": [
      "03 Foundation",
      "NB-03-02 Pandas"
    ]
  },
  {
    "objectID": "tutorials/nb_03_02_pandas.html#exercise-1.1---create-product-catalog-dataframe",
    "href": "tutorials/nb_03_02_pandas.html#exercise-1.1---create-product-catalog-dataframe",
    "title": "Notebook 3.2 - Pandas for CEO Data Management",
    "section": "Exercise 1.1 - Create Product Catalog DataFrame",
    "text": "Exercise 1.1 - Create Product Catalog DataFrame\nBuild a DataFrame for Bean Counter’s top products.\n\nimport pandas as pd\n\n# Create a dictionary with product data\nproduct_data = {\n    'product_name': ['Espresso', 'Latte', 'Cappuccino', 'Americano', 'Mocha'],\n    'price': [2.50, 4.50, 4.00, 3.00, 5.00],\n    'cost': [0.75, 1.50, 1.25, 0.90, 1.80],\n    'units_sold_daily': [450, 320, 280, 210, 190]\n}\n\n# YOUR CODE BELOW\n\n# Create DataFrame\nproducts_df =\n\n\n\nCode\n# Test your DataFrame\nassert products_df.shape == (5, 4), \"Should have 5 products and 4 columns\"\nassert list(products_df.columns) == ['product_name', 'price', 'cost', 'units_sold_daily']\nassert products_df['price'].sum() == 19.00, \"Total price should be 19.00\"\nprint(\"Bean Counter Product Catalog:\")\nprint(products_df)\nprint(\"Perfect! Your product catalog is ready for analysis!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-02 Pandas"
    ]
  },
  {
    "objectID": "tutorials/nb_03_02_pandas.html#exercise-2.1---explore-store-performance",
    "href": "tutorials/nb_03_02_pandas.html#exercise-2.1---explore-store-performance",
    "title": "Notebook 3.2 - Pandas for CEO Data Management",
    "section": "Exercise 2.1 - Explore Store Performance",
    "text": "Exercise 2.1 - Explore Store Performance\nUse pandas exploration methods to understand store performance data.\n\nimport pandas as pd\nimport numpy as np\n\n# Store performance data\nperformance_df = pd.DataFrame({\n    'store': ['Plaza', 'Station', 'Park', 'Beach', 'Airport', 'Mall', 'Downtown', 'University'],\n    'quarterly_revenue': [1250000, 980000, 870000, 650000, 1450000, 1100000, 1350000, 920000],\n    'profit_margin': [32.5, 28.7, 30.1, 25.4, 35.2, 31.8, 33.9, 29.5],\n    'customer_count': [45000, 38000, 34000, 28000, 52000, 41000, 48000, 36000],\n    'satisfaction': [4.7, 4.5, 4.6, 4.8, 4.4, 4.6, 4.8, 4.9]\n})\n\n# YOUR CODE BELOW\n# 1. Display the first 3 rows and store in a variable\nfirst_rows =\n\n# 2. Get the shape (rows, columns) and save it\ndata_shape =\n\n# 3. Get summary statistics for numerical columns and store them\nsummary_stats =\n\n\n\nCode\n# Test your exploration\nassert data_shape == (8, 5), \"Should have 8 stores and 5 columns\"\nassert len(first_rows) == 3, \"first_rows should have 3 stores\"\nassert isinstance(summary_stats, pd.DataFrame), \"summary_stats should be a DataFrame\"\nprint(\"First 3 stores:\")\nprint(first_rows)\nprint(f\"\\nDataFrame shape: {data_shape}\")\nprint(\"Great exploration! You understand your data structure!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-02 Pandas"
    ]
  },
  {
    "objectID": "tutorials/nb_03_02_pandas.html#exercise-3.1---filter-strategic-locations",
    "href": "tutorials/nb_03_02_pandas.html#exercise-3.1---filter-strategic-locations",
    "title": "Notebook 3.2 - Pandas for CEO Data Management",
    "section": "Exercise 3.1 - Filter Strategic Locations",
    "text": "Exercise 3.1 - Filter Strategic Locations\nIdentify stores meeting specific CEO criteria.\n\nimport pandas as pd\n\nstores_df = pd.DataFrame({\n    'location': ['Plaza', 'Station', 'Park', 'Beach', 'Airport', 'Mall', 'Downtown', 'University'],\n    'monthly_revenue': [125000, 98000, 87000, 65000, 145000, 110000, 135000, 92000],\n    'growth_rate': [5.2, -2.1, 3.8, -0.5, 8.7, 4.1, 6.3, 2.9],\n    'staff': [25, 20, 18, 15, 32, 23, 28, 19]\n})\n\n# YOUR CODE BELOW\n# 1. Select only location and monthly_revenue columns\nrevenue_report =\n\n# 2. Filter stores with revenue &gt; 100000\nhigh_revenue_stores =\n\n# 3. Filter stores with positive growth\ngrowing_stores =\n\n\n\nCode\n# Test your filtering\nassert len(high_revenue_stores) == 4, \"Should find 4 high revenue stores\"\nassert all(high_revenue_stores['monthly_revenue'] &gt; 100000), \"All selected stores should have revenue &gt; 100000\"\nassert len(growing_stores) == 6, \"Should find 6 stores with positive growth\"\nassert all(growing_stores['growth_rate'] &gt; 0), \"All selected stores should have positive growth\"\nprint(f\"High revenue stores: {list(high_revenue_stores['location'])}\")\nprint(f\"Growing stores: {list(growing_stores['location'])}\")\nprint(\"Excellent! You've identified your star performers!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-02 Pandas"
    ]
  },
  {
    "objectID": "tutorials/nb_03_02_pandas.html#exercise-4.1---ceo-performance-dashboard",
    "href": "tutorials/nb_03_02_pandas.html#exercise-4.1---ceo-performance-dashboard",
    "title": "Notebook 3.2 - Pandas for CEO Data Management",
    "section": "Exercise 4.1 - CEO Performance Dashboard",
    "text": "Exercise 4.1 - CEO Performance Dashboard\nCreate a comprehensive performance analysis with calculated metrics.\n\nimport pandas as pd\n\n# Store operational data\noperations_df = pd.DataFrame({\n    'store': ['Plaza', 'Airport', 'Beach', 'Mall', 'Downtown'],\n    'revenue': [125000, 145000, 65000, 110000, 135000],\n    'costs': [87500, 94250, 48750, 77000, 87750],\n    'customers': [4500, 5200, 2800, 4100, 4800],\n    'staff': [25, 32, 15, 23, 28]\n})\n\n# YOUR CODE BELOW\n# 1. Calculate profit for each store\noperations_df['profit'] =\n\n# 2. Calculate profit margin percentage\noperations_df['profit_margin'] =\n\n# 3. Calculate revenue per customer\noperations_df['revenue_per_customer'] =\n\n# 4. Calculate customers per staff (efficiency)\noperations_df['efficiency'] =\n\n# 5. Sort by profit (highest to lowest)\ntop_performers =\n\n\n\nCode\n# Test your dashboard\nassert operations_df['profit'].sum() == 184750, \"Total profit should be 184,750\"\nassert operations_df['profit_margin'].max() == 35.0, \"Highest margin should be 35%\"\nassert top_performers.iloc[0]['store'] == 'Airport', \"Airport should be most profitable\"\nprint(\"CEO Dashboard - Top Performers by Profit:\")\nprint(top_performers[['store', 'profit', 'profit_margin', 'efficiency']])\nprint(\"Great CEO dashboard! You have visibility of performance!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-02 Pandas"
    ]
  },
  {
    "objectID": "tutorials/nb_03_02_pandas.html#exercise-5.1---load-and-analyze-sales-data",
    "href": "tutorials/nb_03_02_pandas.html#exercise-5.1---load-and-analyze-sales-data",
    "title": "Notebook 3.2 - Pandas for CEO Data Management",
    "section": "Exercise 5.1 - Load and Analyze Sales Data",
    "text": "Exercise 5.1 - Load and Analyze Sales Data\nProcess a CSV file containing Bean Counter’s sales data.\n\nimport pandas as pd\nimport io\n\n# Simulated CSV data (in practice, you'd read from a file)\ncsv_content = \"\"\"product,category,price,units_sold,customer_rating\nEspresso,Coffee,2.50,4500,4.7\nLatte,Coffee,4.50,3200,4.8\nCappuccino,Coffee,4.00,2800,4.6\nCroissant,Food,3.50,1200,4.5\nMuffin,Food,2.75,1800,4.4\nSandwich,Food,6.50,900,4.7\nMocha,Coffee,5.00,1900,4.5\nAmericano,Coffee,3.00,2100,4.6\"\"\"\n\n# YOUR CODE BELOW\n# 1. Read the CSV data\nsales_df = pd.read_csv(io.StringIO(csv_content))\n\n# 2. Calculate revenue for each product\nsales_df['revenue'] =\n\n# 3. Filter for only Coffee products\ncoffee_df =\n\n# 4. Sort coffee products by units_sold (highest first)\ncoffee_sorted =\n\n# 5. Calculate total coffee revenue\ntotal_coffee_revenue =\n\n\n\nCode\n# Test your data loading and analysis\nassert len(coffee_df) == 5, \"Should have 5 coffee products\"\nassert coffee_sorted.iloc[0]['product'] == 'Espresso', \"Espresso should be top seller\"\nassert total_coffee_revenue == 52650.0, f\"Coffee revenue should be 52,650\"\nprint(\"Top Coffee Products by Volume:\")\nprint(coffee_sorted[['product', 'units_sold', 'revenue']])\nprint(f\"\\nTotal Coffee Revenue: ${total_coffee_revenue:,.2f}\")\nprint(\"Perfect! You can now load and analyze real business data!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-02 Pandas"
    ]
  },
  {
    "objectID": "tutorials/nb_02_04_recap.html",
    "href": "tutorials/nb_02_04_recap.html",
    "title": "Notebook 2.4 - Integration Challenge",
    "section": "",
    "text": "You’ve climbed the ranks:\n\nAssistant Manager → Mastered functions for standardized operations\nRegional Manager → Conquered dictionaries for data management\nOperations Director → Optimized with sorting and selection\n\nNow the CEO wants to see if you can integrate all these skills. This is your chance to make an impression before potentially taking over as CEO of Bean Counter!\nToday’s Challenge: Build an integrated system that uses functions, dictionaries, and sorting together to solve real business problems.\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nThis is a shorter recap session. Each exercise integrates multiple concepts you’ve learned.",
    "crumbs": [
      "02 Advances",
      "NB-02-04 Recap"
    ]
  },
  {
    "objectID": "tutorials/nb_02_04_recap.html#exercise-1.1---performance-calculator",
    "href": "tutorials/nb_02_04_recap.html#exercise-1.1---performance-calculator",
    "title": "Notebook 2.4 - Integration Challenge",
    "section": "Exercise 1.1 - Performance Calculator",
    "text": "Exercise 1.1 - Performance Calculator\nCreate a function evaluate_store that:\n\nTakes a store dictionary as input (see above)\nCalculates if the store is meeting targets\nReturns a tuple: (is_successful, performance_message)\n\nSuccess criteria:\n\nDaily sales &gt; 4000 AND\nCustomer rating &gt;= 4.5 AND\nStaff efficiency &gt; 50 customers/staff\n\n\n\n\n\n\n\nThe returned is_successful is just a boolean (True or False), while the performance message should be a string with feedback for the store.\n\n\n\n\n# YOUR CODE BELOW\ndef evaluate_store(store):\n    \"\"\"Evaluate if a store meets Bean Counter standards\"\"\"\n    # Check all three criteria\n\n    # Return (success_boolean, message)\n\n\n\nCode\n# Test your evaluation function\nstore1 = {\"name\": \"Plaza\", \"daily_sales\": 5000, \"rating\": 4.8, \"customers_per_staff\": 75}\nsuccess1, msg1 = evaluate_store(store1)\nassert success1 == True, \"Plaza should be successful\"\n\nstore2 = {\"name\": \"Beach\", \"daily_sales\": 3500, \"rating\": 4.6, \"customers_per_staff\": 60}\nsuccess2, msg2 = evaluate_store(store2)\nassert success2 == False, \"Beach should not be successful (low sales)\"\n\nprint(\"Great! Your evaluation function works perfectly!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-04 Recap"
    ]
  },
  {
    "objectID": "tutorials/nb_02_04_recap.html#exercise-2.1---complete-store-ranking-system",
    "href": "tutorials/nb_02_04_recap.html#exercise-2.1---complete-store-ranking-system",
    "title": "Notebook 2.4 - Integration Challenge",
    "section": "Exercise 2.1 - Complete Store Ranking System",
    "text": "Exercise 2.1 - Complete Store Ranking System\nBuild a system that:\n\nCalculates a composite score for each store using a function\nAdds this score to each store dictionary\nRanks stores from best to worst\nReturns the name of the best store\n\nComposite score = (revenue/1000) + (rating * 10) - (complaints * 2)\n\ndef calculate_composite_score(store):\n    \"\"\"Calculate composite score for ranking\"\"\"\n    # YOUR CODE BELOW\n\n    return score\n\ndef find_best_store(stores_list):\n    \"\"\"Find the best store based on composite score\"\"\"\n    # YOUR CODE BELOW\n    # 1. Add composite score to each store\n\n    # 2. Sort by composite score (highest first)\n\n    # 3. Return the name of the best store\n\n    return best_store_name\n\n# Test data\nstores = [\n    {\"name\": \"Plaza\", \"revenue\": 45000, \"rating\": 4.7, \"complaints\": 5},\n    {\"name\": \"Station\", \"revenue\": 38000, \"rating\": 4.9, \"complaints\": 2},\n    {\"name\": \"Airport\", \"revenue\": 52000, \"rating\": 4.4, \"complaints\": 12}\n]\n\nbest = find_best_store(stores)\nprint(f\"The best performing store is: {best}\")\n\n\n\nCode\n# Test your ranking system\nassert best == \"Station\", f\"Best store should be Station, got {best}\"\n\n# Verify scores were calculated correctly\nfor store in stores:\n    if store[\"name\"] == \"Plaza\":\n        assert store[\"composite_score\"] == 82.0, \"Plaza score incorrect\"\n    elif store[\"name\"] == \"Station\":\n        assert store[\"composite_score\"] == 83.0, \"Station score incorrect (should be highest)\"\n    elif store[\"name\"] == \"Airport\":\n        assert store[\"composite_score\"] == 72.0, \"Airport score incorrect\"\n\nprint(\"Excellent! Your integrated ranking system works perfectly!\")\nprint(\"Station wins with the best composite score!\")\nprint(\"You're ready to become the CEO of Bean Counter!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-04 Recap"
    ]
  },
  {
    "objectID": "tutorials/nb_02_02_dictionaries.html",
    "href": "tutorials/nb_02_02_dictionaries.html",
    "title": "Notebook 2.2 - Dictionaries at Bean Counter",
    "section": "",
    "text": "Welcome to your new role as Regional Manager at Bean Counter!\nCongratulations on another promotion!\nYour standardized functions from the Assistant Manager role were so successful that the CEO has promoted you to Regional Manager! You’re now responsible for overseeing 10 Bean Counter locations across the city.\nThe Challenge: Managing 10 locations means tracking large amounts of data:\n\nEach location has different inventory levels\nSales vary by neighborhood\nBarista teams have different sizes\nEquipment needs vary by store size\n\nUsing simple variables or lists isn’t enough anymore. You need a better way to organize all this information!\nYour Task: Understand dictionaries - Python’s way of storing structured data with labels. Think of them as digital filing cabinets where everything has a clear label and is easy to find.\nIn this tutorial, we’ll learn how dictionaries help you manage complex business data across all Bean Counter locations.\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nCells marked with “YOUR CODE BELOW” expect you to write your own code. Test blocks will verify your solutions.",
    "crumbs": [
      "02 Advances",
      "NB-02-02 Dictionaries"
    ]
  },
  {
    "objectID": "tutorials/nb_02_02_dictionaries.html#exercise-1.1---create-a-location-profile",
    "href": "tutorials/nb_02_02_dictionaries.html#exercise-1.1---create-a-location-profile",
    "title": "Notebook 2.2 - Dictionaries at Bean Counter",
    "section": "Exercise 1.1 - Create a Location Profile",
    "text": "Exercise 1.1 - Create a Location Profile\nCreate a dictionary called airport_store for the Bean Counter airport location with:\n\nname: “Bean Counter Airport”\nmanager: “James Wilson”\ndaily_sales: 6200.00\nstaff_count: 12\ncoffee_beans_kg: 62.0\n\n\n# YOUR CODE BELOW\nairport_store = {\n    # Add the key-value pairs here\n}\n\n\n\nCode\n# Test your location profile\nassert airport_store[\"name\"] == \"Bean Counter Airport\", \"Store name should be 'Bean Counter Airport'\"\nassert airport_store[\"manager\"] == \"James Wilson\", \"Manager should be 'James Wilson'\"\nassert airport_store[\"daily_sales\"] == 6200.00, \"Daily sales should be 6200.00\"\nassert airport_store[\"staff_count\"] == 12, \"Staff count should be 12\"\nassert airport_store[\"coffee_beans_kg\"] == 62.0, \"Coffee beans should be 62.0 kg\"\nprint(\"Perfect! You've created your first location profile!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-02 Dictionaries"
    ]
  },
  {
    "objectID": "tutorials/nb_02_02_dictionaries.html#exercise-1.2---update-inventory",
    "href": "tutorials/nb_02_02_dictionaries.html#exercise-1.2---update-inventory",
    "title": "Notebook 2.2 - Dictionaries at Bean Counter",
    "section": "Exercise 1.2 - Update Inventory",
    "text": "Exercise 1.2 - Update Inventory\nThe airport store just received a delivery! Update the dictionary:\n\nAdd 25 kg to the current coffee_beans_kg\nUpdate the manager to “Maria Garcia” (James got promoted!)\nAdd a new key “last_inspection” with value “2024-01-15”\n\n\n\n\n\n\n\nTipUpdating Dictionaries\n\n\n\n\nUpdate existing values: dict['key'] = new_value\nAdd new keys: dict['new_key'] = value\nModify values using math: dict['number'] = dict['number'] + 10\n\n\n\n\n# Assuming airport_store exists from previous exercise\nairport_store = {\n    \"name\": \"Bean Counter Airport\",\n    \"manager\": \"James Wilson\",\n    \"daily_sales\": 6200.00,\n    \"staff_count\": 12,\n    \"coffee_beans_kg\": 62.0\n}\n\n# YOUR CODE BELOW\n# Update coffee beans (add 25 kg)\n\n# Update manager\n\n# Add last_inspection\n\n\n\nCode\n# Test your updates\nassert airport_store[\"coffee_beans_kg\"] == 87.0, \"Coffee beans should now be 87.0 kg\"\nassert airport_store[\"manager\"] == \"Maria Garcia\", \"Manager should be Maria Garcia\"\nassert airport_store[\"last_inspection\"] == \"2024-01-15\", \"Should have last_inspection date\"\nprint(\"Excellent inventory management! The airport store is fully updated!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-02 Dictionaries"
    ]
  },
  {
    "objectID": "tutorials/nb_02_02_dictionaries.html#exercise-2.1---build-your-regional-network",
    "href": "tutorials/nb_02_02_dictionaries.html#exercise-2.1---build-your-regional-network",
    "title": "Notebook 2.2 - Dictionaries at Bean Counter",
    "section": "Exercise 2.1 - Build Your Regional Network",
    "text": "Exercise 2.1 - Build Your Regional Network\nCreate a list called regional_stores containing 2 Bean Counter locations. Each store dictionary should have:\n\nlocation_name (string)\nmonthly_revenue (number)\nmanager_name (string)\nflagship (boolean - True for one store, False for others)\n\n\n# YOUR CODE BELOW\nregional_stores = [\n    # Add 2 store dictionaries here\n]\n\n\n\nCode\n# Test your regional network\nassert len(regional_stores) == 2, \"Should have exactly 2 stores\"\nassert all(\"location_name\" in store for store in regional_stores), \"Each store needs location_name\"\nassert all(\"monthly_revenue\" in store for store in regional_stores), \"Each store needs monthly_revenue\"\nassert all(\"manager_name\" in store for store in regional_stores), \"Each store needs manager_name\"\nassert all(\"flagship\" in store for store in regional_stores), \"Each store needs flagship status\"\nassert sum(store[\"flagship\"] for store in regional_stores) &gt;= 1, \"At least one store should be flagship\"\nprint(\"Great work! Your regional network is established!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-02 Dictionaries"
    ]
  },
  {
    "objectID": "tutorials/nb_02_02_dictionaries.html#exercise-3.1---regional-performance-analysis",
    "href": "tutorials/nb_02_02_dictionaries.html#exercise-3.1---regional-performance-analysis",
    "title": "Notebook 2.2 - Dictionaries at Bean Counter",
    "section": "Exercise 3.1 - Regional Performance Analysis",
    "text": "Exercise 3.1 - Regional Performance Analysis\nWrite code to analyze the performance_data list:\n\nCalculate the total customers served across all stores\nFind the average customer satisfaction score\nCount how many stores served over 500 customers\n\n\nperformance_data = [\n    {\"store\": \"Downtown\", \"customers\": 450, \"satisfaction\": 4.7},\n    {\"store\": \"Airport\", \"customers\": 680, \"satisfaction\": 4.4},\n    {\"store\": \"University\", \"customers\": 520, \"satisfaction\": 4.8},\n    {\"store\": \"Mall\", \"customers\": 380, \"satisfaction\": 4.6},\n    {\"store\": \"Station\", \"customers\": 590, \"satisfaction\": 4.5}\n]\n\ntotal_customers = 0\ntotal_satisfaction = 0\nbusy_stores = 0  # Stores with &gt;500 customers\n# YOUR CODE BELOW\nfor store in performance_data:\n    # Add to total customers\n\n    # Add to satisfaction sum\n\n    # Check if this is a busy store\n\n\n# Print your results\n#\n\n\n\nCode\n# Test your analysis\nassert total_customers == 2620, f\"Total customers should be 2620, got {total_customers}\"\nassert round(average_satisfaction, 2) == 4.60, f\"Average satisfaction should be 4.60, got {round(average_satisfaction, 2)}\"\nassert busy_stores == 3, f\"Should have 3 busy stores, got {busy_stores}\"\nprint(f\"Total customers: {total_customers}\")\nprint(f\"Average satisfaction: {average_satisfaction}\")\nprint(f\"Stores serving &gt;500 customers: {busy_stores}\")\nprint(\"Excellent analysis! You have a clear picture of regional performance!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-02 Dictionaries"
    ]
  },
  {
    "objectID": "tutorials/nb_02_02_dictionaries.html#exercise-4.1---identify-priority-stores",
    "href": "tutorials/nb_02_02_dictionaries.html#exercise-4.1---identify-priority-stores",
    "title": "Notebook 2.2 - Dictionaries at Bean Counter",
    "section": "Exercise 4.1 - Identify Priority Stores",
    "text": "Exercise 4.1 - Identify Priority Stores\nFind stores that need immediate attention. Create two lists:\n\nrestock_needed: Store names with inventory below 20 kg\nlow_performers: Store names with daily revenue below 1000\n\n\ninventory_data = [\n    {\"name\": \"Plaza\", \"coffee_kg\": 45, \"milk_liters\": 30, \"daily_revenue\": 1850},\n    {\"name\": \"Station\", \"coffee_kg\": 12, \"milk_liters\": 8, \"daily_revenue\": 920},\n    {\"name\": \"Park\", \"coffee_kg\": 18, \"milk_liters\": 15, \"daily_revenue\": 1100},\n    {\"name\": \"Beach\", \"coffee_kg\": 7, \"milk_liters\": 22, \"daily_revenue\": 780},\n    {\"name\": \"Downtown\", \"coffee_kg\": 35, \"milk_liters\": 18, \"daily_revenue\": 2200}\n]\n\n# YOUR CODE BELOW\nrestock_needed = []\nlow_performers = []\n\nfor store in inventory_data:\n    # Check if coffee inventory is low (below 20 kg)\n\n    # Check if daily revenue is low (below 1000)\n\n\n\nCode\n# Test your filtering\nassert set(restock_needed) == {\"Station\", \"Park\", \"Beach\"}, f\"Restock list should be Station, Park, Beach\"\nassert set(low_performers) == {\"Station\", \"Beach\"}, f\"Low performers should be Station and Beach\"\nprint(f\"Stores needing restock: {restock_needed}\")\nprint(f\"Low performing stores: {low_performers}\")\nprint(\"Perfect! You've identified the stores that need immediate attention!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-02 Dictionaries"
    ]
  },
  {
    "objectID": "tutorials/nb_02_02_dictionaries.html#exercise-5.1---store-performance-report-generator",
    "href": "tutorials/nb_02_02_dictionaries.html#exercise-5.1---store-performance-report-generator",
    "title": "Notebook 2.2 - Dictionaries at Bean Counter",
    "section": "Exercise 5.1 - Store Performance Report Generator",
    "text": "Exercise 5.1 - Store Performance Report Generator\nCreate a function generate_store_report that takes a store dictionary and returns a performance summary string.\nThe function should:\n\nCalculate profit: revenue - costs\nCalculate profit margin: (profit / revenue) * 100\nDetermine status: “Excellent” if margin &gt; 30%, “Good” if &gt; 20%, else “Needs Improvement”\nReturn a formatted string with the store name, margin, and status\n\n\n# YOUR CODE BELOW\ndef generate_store_report(store):\n    # Calculate profit margin\n\n    # Determine performance status\n\n    # Return formatted report string\n\n\n\nCode\n# Test your report generator\ntest_store1 = {\"name\": \"Plaza\", \"revenue\": 50000, \"costs\": 30000}\nreport1 = generate_store_report(test_store1)\nassert \"40.0%\" in report1, \"Plaza should have 40.0% margin\"\nassert \"Excellent\" in report1, \"Plaza should be Excellent\"\n\ntest_store2 = {\"name\": \"Station\", \"revenue\": 40000, \"costs\": 34000}\nreport2 = generate_store_report(test_store2)\nassert \"15.0%\" in report2, \"Station should have 15.0% margin\"\nassert \"Needs Improvement\" in report2, \"Station needs improvement\"\n\nprint(\"Fantastic! Your reporting system gives clear insights into store performance!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-02 Dictionaries"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html",
    "href": "tutorials/nb_01_03_conditionals_while.html",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "",
    "text": "Welcome to your third interactive Python tutorial!\nThe Smart Inventory System Problem\nBean Counter coffee shop is growing! They need a smarter inventory management system that can:\n\nAlert when supplies are running low\nAutomatically reorder items when needed\nTrack which products are selling fastest\nSimulate inventory usage over time\n\nThese tasks require your program to make decisions and repeat processes until certain conditions are met. That’s where conditionals and while loops come in - they’re the brains behind smart automated systems!\nIn this tutorial, we’ll learn how to make decisions with if/elif/else statements and create loops that run until specific conditions are met.\n\n\n\n\n\n\nIf a cell is marked with YOUR CODE BELOW, you are expected to write your code in that cell.",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#exercise-1.1---coffee-bean-quality-check",
    "href": "tutorials/nb_01_03_conditionals_while.html#exercise-1.1---coffee-bean-quality-check",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Exercise 1.1 - Coffee Bean Quality Check",
    "text": "Exercise 1.1 - Coffee Bean Quality Check\nCheck if coffee beans meet quality standards. Beans pass if:\n\nThe moisture level is between 10 and 12 (inclusive)\nAND the defect count is less than 5\n\nCreate a variable passes_quality that is True if both conditions are met.\n\nmoisture_level = 11\ndefect_count = 3\n\n# Check if moisture_level is between 10 and 12 (inclusive) AND defect_count &lt; 5\n# Store the result in passes_quality\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nassert passes_quality == True, \"Beans with moisture=11 and defects=3 should pass\"\nprint(\"Excellent! Your quality check system works correctly!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#exercise-1.2---special-offer-eligibility",
    "href": "tutorials/nb_01_03_conditionals_while.html#exercise-1.2---special-offer-eligibility",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Exercise 1.2 - Special Offer Eligibility",
    "text": "Exercise 1.2 - Special Offer Eligibility\nCustomers get a special offer if they meet ANY of these conditions:\n\nThey’re a member (is_member = True)\nOR they’ve spent more than $100\nOR it’s their birthday (is_birthday = True)\n\nDetermine if the customer is eligible by storing the result in a variable called eligible_for_offer.\n\n# YOUR CODE BELOW\nis_member = False\ntotal_spent = 120\nis_birthday = False\n\n# Check if customer is eligible for special offer using 'or'\n# Store result in eligible_for_offer\n\n\n\nCode\n# Test your answer\nassert eligible_for_offer == True, \"Customer spending $120 should be eligible\"\nprint(\"Perfect! Your special offer system works with OR logic!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#exercise-2.1---simple-stock-alert",
    "href": "tutorials/nb_01_03_conditionals_while.html#exercise-2.1---simple-stock-alert",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Exercise 2.1 - Simple Stock Alert",
    "text": "Exercise 2.1 - Simple Stock Alert\nCreate a stock alert system. You need to:\n\nCheck if milk_liters is less than 10\nIf it is, print “Order more milk!” and set order to True\nOtherwise, print “Milk stock OK”\n\n\n# YOUR CODE BELOW\nmilk_liters = 7\norder = False\n\n\n\nCode\n# Test your answer\nassert order == True, \"'order' should be `True` when milk_liters is 7\"\nprint(\"Great! Your stock alert system works!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#exercise-2.2---multi-level-pricing",
    "href": "tutorials/nb_01_03_conditionals_while.html#exercise-2.2---multi-level-pricing",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Exercise 2.2 - Multi-Level Pricing",
    "text": "Exercise 2.2 - Multi-Level Pricing\nCreate a pricing system with multiple tiers. The rules are:\n\nOrders less than 10 items: $5 per item\nOrders 10-49 items: $4.50 per item\nOrders 50 or more items: $4 per item\n\nCalculate and print the price_per_item and total_cost for the given quantity.\n\n# YOUR CODE BELOW\nquantity = 25\n\n# Use if/elif/else to determine price_per_item\n# Then calculate total_cost = quantity * price_per_item\n# Print both values\n\n\n\nCode\n# Test your answer\nassert price_per_item == 4.50, \"price_per_item should be 4.50 for quantity 25\"\nassert total_cost == 112.50, \"total_cost should be 112.50 (25 * 4.50)\"\nprint(f\"Perfect! Price per item: ${price_per_item}, Total: ${total_cost}\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#introducing-enumerate",
    "href": "tutorials/nb_01_03_conditionals_while.html#introducing-enumerate",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Introducing enumerate()",
    "text": "Introducing enumerate()\nPreviously, you learned to use range(len(list)) to get indices. Python has a more elegant way: enumerate(), which gives you both the index AND the value at the same time!\n\n# The old way - using range() for indexed access\nproducts = [\"Coffee\", \"Milk\", \"Sugar\"]\nprices = [4.50, 2.75, 1.25]\n\nprint(\"Using range() - the way you learned before:\")\nfor i in range(len(products)):\n    print(f\"  Item {i}: {products[i]} costs ${prices[i]}\")\n\nUsing range() - the way you learned before:\n  Item 0: Coffee costs $4.5\n  Item 1: Milk costs $2.75\n  Item 2: Sugar costs $1.25\n\n\n\n# The new way - using enumerate() to get both index and value\nproducts = [\"Coffee\", \"Milk\", \"Sugar\"]\nprices = [4.50, 2.75, 1.25]\n\nprint(\"\\nUsing enumerate() - a cleaner approach:\")\nfor i, product in enumerate(products):\n    print(f\"  Item {i}: {product} costs ${prices[i]}\")\n\n\nUsing enumerate() - a cleaner approach:\n  Item 0: Coffee costs $4.5\n  Item 1: Milk costs $2.75\n  Item 2: Sugar costs $1.25\n\n\n\n\n\n\n\n\nTipWhen to Use enumerate():\n\n\n\nUse enumerate() when you need both the index and the value:\nfor i, item in enumerate(my_list):\n    # i is the index (0, 1, 2, ...)\n    # item is the value at that position\nThis is cleaner than for i in range(len(my_list)) and accessing my_list[i]!",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#filtering-data-with-conditionals-in-loops",
    "href": "tutorials/nb_01_03_conditionals_while.html#filtering-data-with-conditionals-in-loops",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Filtering Data with Conditionals in Loops",
    "text": "Filtering Data with Conditionals in Loops\nNow let’s combine everything - loops, enumerate(), and conditionals - to filter and process data intelligently.\n\n# Process a list with conditions\ndaily_sales = [1250, 1890, 950, 2100, 1650]\ntarget = 1500\n\nprint(\"Sales Analysis:\")\nfor i, sale in enumerate(daily_sales):\n    if sale &gt;= target:\n        print(f\"  Day {i+1}: ${sale} Met target!\")\n    else:\n        shortfall = target - sale\n        print(f\"  Day {i+1}: ${sale} Missed by ${shortfall}\")\n\nSales Analysis:\n  Day 1: $1250 Missed by $250\n  Day 2: $1890 Met target!\n  Day 3: $950 Missed by $550\n  Day 4: $2100 Met target!\n  Day 5: $1650 Met target!\n\n\n\n\n\n\n\n\nInstead of just using range, we can use enumerate as we have seen in the example before to get both index and value in a loop at once. The enumerate function returns the index (here i) and value (here sale) of each element in the list.\n\n\n\n\n\n\n\n\n\nWarningCommon Pattern:\n\n\n\nWhen filtering lists, create an empty list first, then append items that meet your conditions:\nfiltered = []\nfor item in original_list:\n    if condition:\n        filtered.append(item)",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#exercise-3.1---filter-high-value-orders",
    "href": "tutorials/nb_01_03_conditionals_while.html#exercise-3.1---filter-high-value-orders",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Exercise 3.1 - Filter High-Value Orders",
    "text": "Exercise 3.1 - Filter High-Value Orders\nCreate a list containing only orders above $50. Also count how many high-value orders there are.\n\nall_orders = [35.50, 67.25, 45.00, 89.99, 52.10, 23.75, 91.50, 48.00]\n\n# Create empty list for high_value_orders\nhigh_value_orders = []\ncount = 0\n\n# YOUR CODE BELOW\n\n# Loop through all_orders\n# If order &gt; 50, append to high_value_orders and increment count\n\n\n\nCode\n# Test your answer\nassert high_value_orders == [67.25, 89.99, 52.10, 91.50], \"high_value_orders should contain [67.25, 89.99, 52.10, 91.50]\"\nassert count == 4, \"count should be 4\"\nprint(f\"Great! Found {count} high-value orders: {high_value_orders}\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#exercise-3.2---categorize-products",
    "href": "tutorials/nb_01_03_conditionals_while.html#exercise-3.2---categorize-products",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Exercise 3.2 - Categorize Products",
    "text": "Exercise 3.2 - Categorize Products\nCategorize products by stock level and create separate lists for each category:\n\nCritical: stock &lt; 10\nLow: stock &gt;= 10 and stock &lt; 25\nGood: stock &gt;= 25\n\n\nproducts = [\"Coffee\", \"Milk\", \"Sugar\", \"Cups\", \"Lids\", \"Stirrers\"]\nstock_levels = [5, 18, 35, 8, 42, 15]\n\ncritical = []\nlow = []\ngood = []\n\n# YOUR CODE BELOW\n#\n# Loop through products using range(len(products))\n# Check stock_levels[i] and append products[i] to appropriate list\n\n\n\nCode\n# Test your answer\nassert critical == [\"Coffee\", \"Cups\"], \"critical should be ['Coffee', 'Cups']\"\nassert low == [\"Milk\", \"Stirrers\"], \"low should be ['Milk', 'Stirrers']\"\nassert good == [\"Sugar\", \"Lids\"], \"good should be ['Sugar', 'Lids']\"\nprint(\"Perfect! Product categorization complete!\")\nprint(f\"Critical: {critical}\")\nprint(f\"Low: {low}\")\nprint(f\"Good: {good}\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#exercise-4.1---customer-queue-simulation",
    "href": "tutorials/nb_01_03_conditionals_while.html#exercise-4.1---customer-queue-simulation",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Exercise 4.1 - Customer Queue Simulation",
    "text": "Exercise 4.1 - Customer Queue Simulation\nSimulate serving customers in a queue. Each minute you can serve 2 customers, and 3 new customers arrive. The loop should continue running while the queue size is 20 or less.\nTrack:\n\nHow many minutes it takes (until queue exceeds 20)\nThe final queue size\n\n\n\n\n\n\n\nYour while loop condition should be while queue_size &lt;= 20: - this means the loop continues as long as the queue hasn’t exceeded 20 yet.\n\n\n\n\nqueue_size = 5  # Starting queue\nminutes = 0\nserve_rate = 2  # Customers served per minute\narrival_rate = 3  # New customers per minute\n\n# YOUR CODE BELOW\n\n# Use a while loop that continues while queue_size &lt;= 20\n# Each iteration:\n#   1. Update queue_size: add arrivals, subtract served\n#   2. Increment minutes by 1\n\n\n\nCode\n# Test your answer\nassert minutes == 16, \"Should take 16 minutes to exceed 20 customers\"\nassert queue_size == 21, \"Final queue size should be 21\"\nprint(f\"Excellent! After {minutes} minutes, queue size is {queue_size}\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#complex-conditions-with-or-logic",
    "href": "tutorials/nb_01_03_conditionals_while.html#complex-conditions-with-or-logic",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Complex Conditions with OR Logic",
    "text": "Complex Conditions with OR Logic\nSometimes you need to combine multiple conditions with OR logic. When mixing AND and OR, use parentheses to make your logic clear:\n\n# Example: Find items that meet EITHER of two criteria\nitems = [\"Coffee\", \"Tea\", \"Pastry\", \"Juice\", \"Sandwich\"]\nprices = [5.00, 2.50, 4.00, 3.50, 7.00]\nis_hot = [True, True, True, False, True]\n\n# Promotion: Hot items over $4 OR cold items over $3\npromotion_items = []\n\nfor i in range(len(items)):\n    # Use parentheses to group each condition\n    hot_and_expensive = (is_hot[i] == True and prices[i] &gt;= 4)\n    cold_and_pricy = (is_hot[i] == False and prices[i] &gt;= 3)\n\n    if hot_and_expensive or cold_and_pricy:\n        promotion_items.append(items[i])\n        print(f\"  {items[i]}: ${prices[i]} - Eligible!\")\n\nprint(f\"\\nPromotion items: {promotion_items}\")\n\n  Coffee: $5.0 - Eligible!\n  Pastry: $4.0 - Eligible!\n  Juice: $3.5 - Eligible!\n  Sandwich: $7.0 - Eligible!\n\nPromotion items: ['Coffee', 'Pastry', 'Juice', 'Sandwich']\n\n\nYou can also write this more compactly in a single condition:\n\n# Same logic, written in one line\npromotion_items_compact = []\n\nfor i in range(len(items)):\n    if (is_hot[i] and prices[i] &gt;= 4) or (not is_hot[i] and prices[i] &gt;= 3):\n        promotion_items_compact.append(items[i])\n\nprint(f\"Promotion items (compact): {promotion_items_compact}\")\n\nPromotion items (compact): ['Coffee', 'Pastry', 'Juice', 'Sandwich']\n\n\n\n\n\n\n\n\nImportantComplex Boolean Logic:\n\n\n\nWhen combining AND and OR: - Use parentheses to group related conditions - Break complex conditions into smaller parts if needed - Test each part separately first, then combine",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_03_conditionals_while.html#exercise-5.1---smart-promotion-filter",
    "href": "tutorials/nb_01_03_conditionals_while.html#exercise-5.1---smart-promotion-filter",
    "title": "Notebook 1.3 - Conditionals & While Loops",
    "section": "Exercise 5.1 - Smart Promotion Filter",
    "text": "Exercise 5.1 - Smart Promotion Filter\nFind products eligible for promotion. Products qualify if they are:\n\nDrinks priced $4 or more, OR\nFood items priced $3 or more\n\nAlso calculate the total discount if we offer 15% off eligible items.\n\n# YOUR CODE BELOW\nproducts = [\"Coffee\", \"Tea\", \"Muffin\", \"Sandwich\", \"Smoothie\", \"Cookie\"]\nprices = [4.50, 2.75, 3.50, 7.95, 5.25, 2.00]\ncategories = [\"drink\", \"drink\", \"food\", \"food\", \"drink\", \"food\"]\n\neligible_products = []\ntotal_discount = 0\n\n# Loop through all products\n# Check if eligible based on category and price\n# If eligible: add to list and add (price * 0.15) to total_discount\n\n\n\nCode\n# Test your answer\nassert eligible_products == [\"Coffee\", \"Muffin\", \"Sandwich\", \"Smoothie\"], \"Should include Coffee, Muffin, Sandwich, Smoothie\"\nassert abs(total_discount - 3.15) &lt; 0.1, \"Total discount should be approximately 3.15\"\nprint(f\"Excellent! Eligible products: {eligible_products}\")\nprint(f\"Total discount offered: ${total_discount:.2f}\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-03 Conditions"
    ]
  },
  {
    "objectID": "tutorials/nb_01_01_variables_data_types.html",
    "href": "tutorials/nb_01_01_variables_data_types.html",
    "title": "Notebook 1.1 - Variables & Basic Data Types",
    "section": "",
    "text": "Welcome to your first interactive Python tutorial!\nThe Coffee Shop Calculator Problem\nImagine you just started working at a busy coffee shop called “Bean Counter.” On your first day, the manager asks you to help with various calculations: pricing drinks, applying discounts, calculating tips, and formatting receipts. The old calculator is broken, and they need a better system anyway. Lucky for them, you know Python!\nIn this tutorial, we’ll learn about variables and basic data types to build your own coffee shop calculator system. By the end, you’ll be able to handle any calculation the shop throws at you!\n\n\n\n\n\n\nIf a cell is marked with YOUR CODE BELOW, you are expected to write your code in that cell.",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Variables"
    ]
  },
  {
    "objectID": "tutorials/nb_01_01_variables_data_types.html#exercise-1.1---your-first-variables",
    "href": "tutorials/nb_01_01_variables_data_types.html#exercise-1.1---your-first-variables",
    "title": "Notebook 1.1 - Variables & Basic Data Types",
    "section": "Exercise 1.1 - Your First Variables",
    "text": "Exercise 1.1 - Your First Variables\nCreate three variables for a new order:\n\nlatte_price should be 5.25\ncustomer should be “Maria”\nquantity should be 2\nshop_closed = False\n\n\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nassert latte_price == 5.25, \"The latte_price should be 5.25\"\nassert customer == \"Maria\", \"The customer should be 'Maria'\"\nassert quantity == 2, \"The quantity should be 2\"\nassert shop_closed == False, \"The shop should be open\"\nprint(\"Perfect! You've created your first variables for the coffee shop!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Variables"
    ]
  },
  {
    "objectID": "tutorials/nb_01_01_variables_data_types.html#exercise-1.2---updating-variables",
    "href": "tutorials/nb_01_01_variables_data_types.html#exercise-1.2---updating-variables",
    "title": "Notebook 1.1 - Variables & Basic Data Types",
    "section": "Exercise 1.2 - Updating Variables",
    "text": "Exercise 1.2 - Updating Variables\nVariables can change! A customer changed their mind and wants 4 lattes instead of 2. Update the quantity variable to 4 and create a new variable total_order that stores the total price (latte_price multiplied by quantity).\n\n# YOUR CODE BELOW\n# Assume latte_price = 5.25 and quantity = 2 from previous exercise\n# Tip: Just overwrite these old values\n# Then calculate: total_order = latte_price * quantity\n\n\n\nCode\n# Test your answer\nassert quantity == 4, \"The quantity should be updated to 4\"\nassert total_order == 21.0, \"The total_order should be 21.0 (5.25 * 4)\"\nprint(\"Excellent! You can update variables and create new ones from existing values!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Variables"
    ]
  },
  {
    "objectID": "tutorials/nb_01_01_variables_data_types.html#exercise-2.1---identifying-data-types",
    "href": "tutorials/nb_01_01_variables_data_types.html#exercise-2.1---identifying-data-types",
    "title": "Notebook 1.1 - Variables & Basic Data Types",
    "section": "Exercise 2.1 - Identifying Data Types",
    "text": "Exercise 2.1 - Identifying Data Types\nCreate variables of each type for our coffee shop:\n\ndaily_customers (int): 85 customers visited today\naverage_tip (float): 2.50 dollars average tip\nbest_seller (str): “Caramel Macchiato”\n\n\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nassert daily_customers == 85 and type(daily_customers) == int, \"daily_customers should be the integer 85\"\nassert average_tip == 2.50 and type(average_tip) == float, \"average_tip should be the float 2.50\"\nassert best_seller == \"Caramel Macchiato\" and type(best_seller) == str, \"best_seller should be the string 'Caramel Macchiato'\"\nprint(\"Great job! You understand the different data types!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Variables"
    ]
  },
  {
    "objectID": "tutorials/nb_01_01_variables_data_types.html#exercise-2.2---type-conversion",
    "href": "tutorials/nb_01_01_variables_data_types.html#exercise-2.2---type-conversion",
    "title": "Notebook 1.1 - Variables & Basic Data Types",
    "section": "Exercise 2.2 - Type Conversion",
    "text": "Exercise 2.2 - Type Conversion\nSometimes we need to convert between types. A customer’s loyalty card bonus points were entered as text “1234” but we need it as a number to do calculations.\nConvert the string card_points = \"1234\" to an integer and create a new variable new_points that adds 100 bonus points to it.\n\n\n\n\n\n\nYou can use the int() function to convert a string to an integer or use the float() function to convert a string to a float.\n\n\n\n\n# YOUR CODE BELOW\ncard_points = \"1234\"\n\n\n\nCode\n# Test your answer\nassert card_points == 1234, \"card_points should be 1234 as an integer\"\nassert new_points == 1334, \"new_points should be 1334 (1234 + 100)\"\nprint(\"Perfect! You can convert between data types!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Variables"
    ]
  },
  {
    "objectID": "tutorials/nb_01_01_variables_data_types.html#exercise-3.1---calculate-the-bill",
    "href": "tutorials/nb_01_01_variables_data_types.html#exercise-3.1---calculate-the-bill",
    "title": "Notebook 1.1 - Variables & Basic Data Types",
    "section": "Exercise 3.1 - Calculate the Bill",
    "text": "Exercise 3.1 - Calculate the Bill\nA group orders:\n\n3 cappuccinos at $4.75 each\n2 muffins at $3.50 each\n1 sandwich at $8.95\n\nCalculate the subtotal, then add 19% tax to get the total_with_tax.\n\n\n\n\n\n\nTo add 19% tax to a value, you can multiply by 1.19.\n\n\n\n\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nimport math\nassert math.isclose(subtotal, 30.20, rel_tol=0.01), \"Subtotal should be 30.20\"\nassert math.isclose(total_with_tax, 30.20*1.19, rel_tol=0.01), \"Total with tax should be 35.94\"\nprint(\"Excellent calculation! You've mastered basic arithmetic!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Variables"
    ]
  },
  {
    "objectID": "tutorials/nb_01_01_variables_data_types.html#exercise-3.2---splitting-the-bill",
    "href": "tutorials/nb_01_01_variables_data_types.html#exercise-3.2---splitting-the-bill",
    "title": "Notebook 1.1 - Variables & Basic Data Types",
    "section": "Exercise 3.2 - Splitting the Bill",
    "text": "Exercise 3.2 - Splitting the Bill\nThe group wants to split the bill evenly among 4 people. Calculate:\n\nHow much each person pays (per_person)\nIf they pay with exact change, how many dollars (dollars) and cents (cents) each person needs. Provide each as variable.\n\n\n\n\n\n\n\nYou could use // for floor division and % for remainder, but you don’t need to do that as other solutions are possible. If you want to round the cents, you can use the round() function.\n\n\n\n\n# YOUR CODE BELOW\n# Assume total_with_tax = 32.616 from previous exercise\n\n\n\nCode\n# Test your answer\nassert math.isclose(per_person, 8.154, rel_tol=0.01), \"Each person should pay 8.154\"\nassert dollars == 8, \"Each person needs 8 dollars\"\nassert cents == 15, \"Each person needs 15 cents (rounded)\"\nprint(\"Great work! You can split bills and handle money calculations!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Variables"
    ]
  },
  {
    "objectID": "tutorials/nb_01_01_variables_data_types.html#exercise-4.1---create-a-simple-receipt",
    "href": "tutorials/nb_01_01_variables_data_types.html#exercise-4.1---create-a-simple-receipt",
    "title": "Notebook 1.1 - Variables & Basic Data Types",
    "section": "Exercise 4.1 - Create a Simple Receipt",
    "text": "Exercise 4.1 - Create a Simple Receipt\nCreate a formatted receipt for a coffee order with these variables:\n\ncoffee_type = \"Americano\"\nsize = \"Large\"\nprice = 3.75\n\nCreate a variable called receipt with the format: “Order: [size] [coffee_type] - $[price with 2 decimal places]”\n\n\n\n\n\n\nUse an f-string with {price:.2f} to format the price with exactly 2 decimal places.\n\n\n\n\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nassert receipt == \"Order: Large Americano - $3.75\", \"Receipt should be 'Order: Large Americano - $3.75'\"\nprint(\"Perfect! You've created your first formatted string!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Variables"
    ]
  },
  {
    "objectID": "lectures/lec_07_presentation.html#client-briefing-artisan-bakery",
    "href": "lectures/lec_07_presentation.html#client-briefing-artisan-bakery",
    "title": "Better Routing",
    "section": "Client Briefing: Artisan Bakery",
    "text": "Client Briefing: Artisan Bakery\n\nMaster Baker’s Morning Dilemma:\n“Every morning at 5:00, our delivery van leaves with fresh bread for 16 cafés across the city. Our driver currently takes much too long using his ‘intuition’ for the route. The fuel costs are killing us, and worse, some cafés get their bread late.”"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-delivery-challenge",
    "href": "lectures/lec_07_presentation.html#the-delivery-challenge",
    "title": "Better Routing",
    "section": "The Delivery Challenge",
    "text": "The Delivery Challenge\nArtisan Bakery’s daily logistics puzzle:\n\n16 Cafés: Each expecting fresh bread by 8:00\nOne Van: Unlimited capacity, must visit all locations\nTime Windows: 3 cafés open early (6:30) and need priority\nCurrent Problem: Driver uses “gut feeling” for routing\n\n\n\n\n\n\n\n\nThe Stakes: Poor routing costs plus reputation damage from late deliveries!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#quick-recap-greedy-decisions",
    "href": "lectures/lec_07_presentation.html#quick-recap-greedy-decisions",
    "title": "Better Routing",
    "section": "Quick Recap: Greedy Decisions",
    "text": "Quick Recap: Greedy Decisions\nLast week we learned greedy algorithms for scheduling:\n\nSPT: Process shortest jobs first\nEDD: Process by earliest due date\nFast & Simple: Made quick decisions, no looking back\n\n\nQuestion: Can we use the same greedy approach for routing?\n\n\n\n\n\n\n\n\nToday: We’ll start greedy, then learn how to improve solutions with local search!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-traveling-salesman-problem",
    "href": "lectures/lec_07_presentation.html#the-traveling-salesman-problem",
    "title": "Better Routing",
    "section": "The Traveling Salesman Problem",
    "text": "The Traveling Salesman Problem\nVisit all locations exactly once, minimize total distance."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#compute-everything",
    "href": "lectures/lec_07_presentation.html#compute-everything",
    "title": "Better Routing",
    "section": "Compute Everything?",
    "text": "Compute Everything?\nHow many unique tours exist? With depot, n!/2 unique tours.\n\nIf your computer checks 1 million routes per second:\n\n4 cafés: 4!/2 = 12 tours → 0.000012 seconds ✓\n8 cafés: 8!/2 = 20,160 tours → 0.02 seconds ✓\n12 cafés: 12!/2 = 239,500,800 tours → 4 minutes ~\n16 cafés: 16!/2 = 10,461,394,944,000 tours → 4 months! ✗\n20 cafés: 20!/2 → 38,573 years! ✗\n\n\n\n\n\n\n\n\n\nThe Reality: Exact approach would take longer than the universe has existed!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-cost-of-complexity",
    "href": "lectures/lec_07_presentation.html#the-cost-of-complexity",
    "title": "Better Routing",
    "section": "The “Cost” of Complexity",
    "text": "The “Cost” of Complexity\nWhy buying a faster computer won’t help:\n\nP: Tasks that can be solved in polynomial time\n\nLike sorting a spreadsheet or calculating payroll\nThese are safe, predictable, and easy to automate\n\nNP: Easy to check, hard to solve\n\nAnalogy: easy to check if a specific password works\nVery hard to guess a password by trying every combination!\n\n\n\n\n\n\n\n\n\nTSP optimization where we find minimum cost tour → NP-Hard. This means no known algorithm can find the perfect solution quickly for large problems."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#what-is-a-graph",
    "href": "lectures/lec_07_presentation.html#what-is-a-graph",
    "title": "Better Routing",
    "section": "What is a Graph?",
    "text": "What is a Graph?\nA graph \\(G = (V, E)\\) consists of:\n\nVertices (V): The nodes or points (bakery + cafés)\nEdges (E): The connections between vertices (roads)\nWeight Function: \\(w\\) assigns costs to edges (distances)\n\n\nFor our bakery problem:\n\n\\(|V| = 17\\) (1 bakery + 17 cafés)\n\\(|E| = \\binom{17}{2} = 136\\) possible connections\nEach edge \\((i,j)\\) has weight \\(w_{ij}\\) = distance between \\(i\\) and \\(j\\)"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#complete-vs.-sparse-graphs",
    "href": "lectures/lec_07_presentation.html#complete-vs.-sparse-graphs",
    "title": "Better Routing",
    "section": "Complete vs. Sparse Graphs",
    "text": "Complete vs. Sparse Graphs\nDifferent graph structures lead to different complexities:\n\nComplete Graph: All vertices connected to each other\n\nTSP: \\((n-1)!/2\\) unique tours\nReal roads: Usually complete (drive between any two points)\n\nSparse Graph: Limited connections between vertices\n\nFewer edges = fewer possible routes\nExamples: Public transit networks, restricted road access\n\n\n\n\n\n\n\n\n\nDensity dramatically affects both problem difficulty and solution approaches!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#hamiltonian-cycles-and-tours",
    "href": "lectures/lec_07_presentation.html#hamiltonian-cycles-and-tours",
    "title": "Better Routing",
    "section": "Hamiltonian Cycles and Tours",
    "text": "Hamiltonian Cycles and Tours\nMathematical foundation of the TSP:\n\nHamiltonian Path: Visits each vertex exactly once\nHamiltonian Cycle: Hamiltonian path that returns to start vertex\nTSP Tour: Minimum weight Hamiltonian cycle\n\n\nMathematical Definition: A tour \\(T = (v_1, v_2, ..., v_n, v_1)\\) where:\n\nEach \\(v_i \\in V\\) appears exactly once (except start/end)\nTotal weight: \\(w(T) = \\sum_{i=1}^{n} w_{v_i, v_{i+1}}\\) (where \\(v_{n+1} = v_1\\))\n\n\n\nGoal: Find tour \\(T^*\\) such that \\(w(T^*) = \\min_{T \\in \\mathcal{H}} w(T)\\)"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#distance-functions-and-metrics",
    "href": "lectures/lec_07_presentation.html#distance-functions-and-metrics",
    "title": "Better Routing",
    "section": "Distance Functions and Metrics",
    "text": "Distance Functions and Metrics\nThe weight function can have different properties:\n\nIdentity: \\(d(i,i) = 0\\) \\(i \\in V\\)\nSymmetry: \\(d(i,j) = d(j,i)\\) \\(i,j \\in V\\)\nTriangle Inequality: \\(d(i,k) \\leq d(i,j) + d(j,k) \\quad \\forall i,j,k \\in V\\)\n\n\nCommon Distance Functions:\n\nEuclidean: \\(d(i,j) = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}\\)\nManhattan: \\(d(i,j) = |x_i - x_j| + |y_i - y_j|\\)\nReal road distances: Often violate triangle inequality!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#a-bad-start-random-route",
    "href": "lectures/lec_07_presentation.html#a-bad-start-random-route",
    "title": "Better Routing",
    "section": "A Bad Start: Random Route",
    "text": "A Bad Start: Random Route\nWhat happens if we pick cafés randomly?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRandom selection creates routes with many crossings and inefficiencies."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#nearest-neighbor-the-problem",
    "href": "lectures/lec_07_presentation.html#nearest-neighbor-the-problem",
    "title": "Better Routing",
    "section": "Nearest Neighbor: The Problem",
    "text": "Nearest Neighbor: The Problem\nGiven these 8 cafés, which should we visit first?\n\n\n\n\n\n\n\n\n\n\nQuestion: Using nearest neighbor, which café would you visit first?"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#nearest-neighbor-the-algorithm",
    "href": "lectures/lec_07_presentation.html#nearest-neighbor-the-algorithm",
    "title": "Better Routing",
    "section": "Nearest Neighbor: The Algorithm",
    "text": "Nearest Neighbor: The Algorithm\nBuild a route by always visiting the closest unvisited location.\n\nStart at the bakery\nFind the nearest unvisited café\nGo there\nRepeat until all visited\nReturn to bakery\n\n\n\n\n\n\n\n\nIntuition: Like picking low-hanging fruit - grab what’s easiest (nearest) first!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#nearest-neighbor-the-solution",
    "href": "lectures/lec_07_presentation.html#nearest-neighbor-the-solution",
    "title": "Better Routing",
    "section": "Nearest Neighbor: The Solution",
    "text": "Nearest Neighbor: The Solution\nLet’s see how nearest neighbor builds the route step by step:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFarthest insertion builds a more balanced tour by establishing the outer structure first!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#farthest-insertion-the-problem",
    "href": "lectures/lec_07_presentation.html#farthest-insertion-the-problem",
    "title": "Better Routing",
    "section": "Farthest Insertion: The Problem",
    "text": "Farthest Insertion: The Problem\nSame 8 cafés - but now we’ll use a different strategy:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe farthest point is our start!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#farthest-insertion-the-algorithm",
    "href": "lectures/lec_07_presentation.html#farthest-insertion-the-algorithm",
    "title": "Better Routing",
    "section": "Farthest Insertion: The Algorithm",
    "text": "Farthest Insertion: The Algorithm\nBuild a route by starting with distant points and filling in gaps:\n\nStart at the bakery\nFind the farthest café from bakery - add it to tour\nCreate initial tour: Bakery → Farthest → Bakery\nRepeat: Find the café farthest from current tour\nInsert it at the position that minimizes tour increase\nContinue until all cafés are in the tour\n\n\n\n\n\n\n\n\nIntuition: Build the “skeleton” of the route first with distant points, then fill in the gaps."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#farthest-insertion-step-by-step",
    "href": "lectures/lec_07_presentation.html#farthest-insertion-step-by-step",
    "title": "Better Routing",
    "section": "Farthest Insertion: Step-by-Step",
    "text": "Farthest Insertion: Step-by-Step\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice how farthest insertion builds a more balanced tour by establishing the outer structure first, then filling in the gaps!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#comparison",
    "href": "lectures/lec_07_presentation.html#comparison",
    "title": "Better Routing",
    "section": "Comparison",
    "text": "Comparison\nLet’s compare all three construction methods:\n\nRandom: Usually worst - no strategy at all!\nNearest Neighbor: Fast and decent, but can create long returns\nFarthest: Often best initial solution, builds good “skeleton”\n\n\n\n\n\n\n\n\nThe better your starting point, the better your final result after local search!\n\n\n\n\n\n\n\n\n\n\n\nThis is also true for all other problems we are solving! A good initial heuristic to create a solution will help us later."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-problem-with-greedy",
    "href": "lectures/lec_07_presentation.html#the-problem-with-greedy",
    "title": "Better Routing",
    "section": "The Problem with Greedy",
    "text": "The Problem with Greedy\nOften obvious inefficiencies in the resulting routes\n\nCrossing paths: Route crosses over itself\nLong return: Far from bakery at the end\nMyopic decisions: Can’t see the “big picture”\n\n\n\n\n\n\n\n\nCan we improve our greedy solutions?"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-four-pillars-of-local-search",
    "href": "lectures/lec_07_presentation.html#the-four-pillars-of-local-search",
    "title": "Better Routing",
    "section": "The Four Pillars of Local Search",
    "text": "The Four Pillars of Local Search\nAny problem can be solved with local search by defining:\n\nSearch Space: All possible solutions (here 10 trillion routes!)\nInitial Solution: Starting point (our greedy route)\nObjective Function: How we measure quality (total distance)\nNeighborhood: How to create “nearby” solutions (2-opt swaps)\n\n\n\n\n\n\n\n\nThe power of local search: The same “engine” works for routing, scheduling, or any combinatorial problem - just plug in different components!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#solution-space-an-intuitive-view",
    "href": "lectures/lec_07_presentation.html#solution-space-an-intuitive-view",
    "title": "Better Routing",
    "section": "Solution Space: An Intuitive View",
    "text": "Solution Space: An Intuitive View\nThink of the solution space as a landscape:\n\nEach point: A different route through the cafés\nHeight: The total distance of that route (lower is better)\nNeighbors: Routes that differ by small change\nLocal optimum: Best route among nearby alternatives\nGlobal optimum: The absolute best route overall"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#search-strategy",
    "href": "lectures/lec_07_presentation.html#search-strategy",
    "title": "Better Routing",
    "section": "Search Strategy",
    "text": "Search Strategy\nHow can we search this space?\n\nStart somewhere (greedy construction)\nLook around at neighboring solutions\nMove to better neighbors\nStop when no neighbor is better\n\n\n\n\n\n\n\n\nLocal search transforms “quick and dirty” solutions into “pretty good” ones!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-2-opt-algorithm",
    "href": "lectures/lec_07_presentation.html#the-2-opt-algorithm",
    "title": "Better Routing",
    "section": "The 2-Opt Algorithm",
    "text": "The 2-Opt Algorithm\nSystematically improve routes by removing crossing paths.\n\nThe Idea: Take two edges and swap them (to uncross the route)"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#example-step-by-step",
    "href": "lectures/lec_07_presentation.html#example-step-by-step",
    "title": "Better Routing",
    "section": "Example: Step-by-Step",
    "text": "Example: Step-by-Step\nLet’s see exactly how 2-opt fixes a crossing in a real route:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Key Insight: When you reverse a segment between two crossing edges, you automatically eliminate the crossing and create a shorter route!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#how-2-opt-works",
    "href": "lectures/lec_07_presentation.html#how-2-opt-works",
    "title": "Better Routing",
    "section": "How 2-Opt Works",
    "text": "How 2-Opt Works\nimproved = True\nwhile improved:\n    improved = False\n    best_distance = calculate_route_distance(route, distances)\n    for i in range(len(route) - 1):\n        for j in range(i + 2, len(route)):\n            new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]\n            new_distance = calculate_route_distance(new_route, distances)\n            if new_distance &lt; best_distance:\n                route = new_route\n                best_distance = new_distance\n                improved = True\n                break\n        if improved:\n            break\n\n\n\n\n\n\n\nThe [::-1] reverses the segment, eliminating crossings!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#opt-applied",
    "href": "lectures/lec_07_presentation.html#opt-applied",
    "title": "Better Routing",
    "section": "2-Opt Applied",
    "text": "2-Opt Applied\nLet’s see how this changes the route!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice how 2-opt removed the crossing paths from our nearest neighbor solution, creating a more efficient route!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#common-2-opt-bugs",
    "href": "lectures/lec_07_presentation.html#common-2-opt-bugs",
    "title": "Better Routing",
    "section": "Common 2-Opt Bugs",
    "text": "Common 2-Opt Bugs\nDebug these scenarios you’ll encounter:\n\nBug 1: Infinite Loop\n# WRONG: Forgot to update route\nif new_distance &lt; current_distance:\n    improved = True  # But route never changes!\n\n\nBug 2: Missing Return to Start\n# WRONG: Only measures cafe-to-cafe\ntotal = sum(distances between stops)\n\n\nBug 3: Invalid Segment Reversal\n# WRONG: Off-by-one error\nnew_route = route[:i] + route[i:j][::-1] + route[j:]\n\n\nFix: route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#what-about-1-opt",
    "href": "lectures/lec_07_presentation.html#what-about-1-opt",
    "title": "Better Routing",
    "section": "What About 1-Opt?",
    "text": "What About 1-Opt?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhere 1-opt DOES work: In problems like knapsack (swap 1 item), assignment (reassign 1 person), or facility location (relocate 1 facility)."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#or-opt-moving-sequences",
    "href": "lectures/lec_07_presentation.html#or-opt-moving-sequences",
    "title": "Better Routing",
    "section": "Or-Opt: Moving Sequences",
    "text": "Or-Opt: Moving Sequences\nMoves sequence of 1-3 consecutive cities to different position.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMoving a sequence can satisfy time constraints without breaking tour structure!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#beyond-k-opt-neighborhoods",
    "href": "lectures/lec_07_presentation.html#beyond-k-opt-neighborhoods",
    "title": "Better Routing",
    "section": "Beyond: k-Opt Neighborhoods",
    "text": "Beyond: k-Opt Neighborhoods\nThe k-opt family of improvements:\n\n\n2-opt\n\nRemoves 2 edges\n1 way to reconnect\nn² combinations\nFast, good results\n\n\n3-opt\n\nRemoves 3 edges\n7 ways to reconnect\nn³ combinations\nBetter but slower\n\n\nOr-opt\n\nMoves 1-3 nodes\nGood for time windows\nSpecialized variant\n\n\n\n\n\n\n\n\n\nStart with 2-opt (fast), use 3-opt if you have time! As k increases, solutions improve but computation time grows exponentially."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#convergence-and-local-optima",
    "href": "lectures/lec_07_presentation.html#convergence-and-local-optima",
    "title": "Better Routing",
    "section": "Convergence and Local Optima",
    "text": "Convergence and Local Optima\nWhen does local search stop? Why might it get stuck?\n\nConvergence:\n\nAlgorithm stops when no neighboring solution is better\n\n\n\nThe Local Optimum Problem:\n\n\nAlgorithm can only “see” neighboring solutions\nMight miss better solutions that require multiple changes\nLike being stuck on a small hill when there’s a mountain nearby\n\n\n\n\n\n\n\n\n\n\nLocal search for improvement but does not guarantee global optimality."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-local-optimum-trap",
    "href": "lectures/lec_07_presentation.html#the-local-optimum-trap",
    "title": "Better Routing",
    "section": "The Local Optimum Trap",
    "text": "The Local Optimum Trap\nImagine you’re a hiker dropped in foggy mountains at night…\n\nYour Mission: Find the highest peak (global optimum)\nYour Tool: An altimeter (objective function)\nYour Vision: Only the ground at your feet (local neighborhood)\n\n\n\nThe Greedy Strategy: Always step uphill\n\n\n\nQuestion: What happens when you reach the top of a small hill?\n\n\n\n\n\n\n\n\nYou’re stuck! Every step is downhill, but you might be on a tiny hill while a much larger moutain is nearby. This is the local optimum trap!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#visualizing-local-optima",
    "href": "lectures/lec_07_presentation.html#visualizing-local-optima",
    "title": "Better Routing",
    "section": "Visualizing Local Optima",
    "text": "Visualizing Local Optima\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere, the local minimum is already quite good, but we likely won’t reach the global optimum from here."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-reality",
    "href": "lectures/lec_07_presentation.html#the-reality",
    "title": "Better Routing",
    "section": "The Reality",
    "text": "The Reality\nReal problems often have thousands of local optima!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe probability of finding the global optimum with simple local search is nearly zero!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#escaping-local-optima",
    "href": "lectures/lec_07_presentation.html#escaping-local-optima",
    "title": "Better Routing",
    "section": "Escaping Local Optima",
    "text": "Escaping Local Optima\nDepending on the problem: Multi-Start Strategy!\n\nMost local minima are much worse than the global optimum\nThe global minimum is sometimes isolated and hard to reach\nStarting point dramatically affects final solution quality\nThus, start with different random solutions\nUse different initial heuristics\n\n\n\n\n\n\n\n\nNo Free Lunch Theorem: There’s no universal “best” algorithm for all problems. What works great for routing might fail for scheduling. Always match your tool to your problem!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#how-good-is-good-enough",
    "href": "lectures/lec_07_presentation.html#how-good-is-good-enough",
    "title": "Better Routing",
    "section": "How Good is Good Enough?",
    "text": "How Good is Good Enough?\nIndustry usage for delivery optimization\n\n\n\nMethod\nIndustry Use\n\n\n\n\n\nHuman intuition\nStill common!\n\n\n\nStart + 2-opt\nCommon practice\n\n\n\nAdvanced Meta\nSometimes practice\n\n\n\nExact (if possible)\nMostly research\n\n\n\n\n\n\n\n\n\n\n\nA 10% improvement = millions in savings for large logistics companies. Even a 2-opt implementation could literally save a lot of money if not used yet!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#time-windows",
    "href": "lectures/lec_07_presentation.html#time-windows",
    "title": "Better Routing",
    "section": "Time Windows",
    "text": "Time Windows\nRemember our bakery? Some cafés open earlier than others!\n\nArtisan Bakery’s Morning Schedule:\n\nBakery opens: 5:00 (van departs)\nEarly Birds (3 cafés): Must receive by 6:30\n\nCafé Europa, Sunrise Bistro, Morning Glory\n\nStandard (13 cafés): Must receive by 8:00\n\n\n\nQuestion: Can we just find the shortest route?\n\n\n\n\n\n\n\n\nThe shortest route might deliver to early cafés last. Feasibility first, optimization second!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#time-windows-practical-approach",
    "href": "lectures/lec_07_presentation.html#time-windows-practical-approach",
    "title": "Better Routing",
    "section": "Time Windows: Practical Approach",
    "text": "Time Windows: Practical Approach\nEach location has a delivery time window:\nKey Concepts:\n\nEarliest time: When café opens\nLatest time: Delivery deadline\nService time: Time to unload\n\n\nArrival Time = Previous departure + Travel time\n\n\n\nFeasible route: All deadlines met\nInfeasible route: At least one deadline missed (even if shortest!)"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#time-windows-nn-modification",
    "href": "lectures/lec_07_presentation.html#time-windows-nn-modification",
    "title": "Better Routing",
    "section": "Time Windows: NN Modification",
    "text": "Time Windows: NN Modification\nModify greedy construction to prioritize early deadlines:\nunvisited = set(range(len(locations))); route = []; current_time = start_time\nwhile unvisited:\n    # Find feasible neighbors (can reach before deadline)\n    feasible = [i for i in unvisited\n                if current_time + travel_time(current, i)\n                    &lt;= time_windows[i]['latest']]\n    if not feasible:\n        return None  # No feasible route exists!\n    # Among feasible, choose most urgent\n    next_stop = min(feasible, key=lambda i: (time_windows[i]['latest']))\n    # Update state\n    route.append(next_stop)\n    unvisited.remove(next_stop)\n    current_time += travel_time(current, next_stop) + service_time"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#opt-with-time-windows",
    "href": "lectures/lec_07_presentation.html#opt-with-time-windows",
    "title": "Better Routing",
    "section": "2-Opt with Time Windows",
    "text": "2-Opt with Time Windows\nProblem: 2-opt can break time feasibility!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEarly2 now arrives at 7:12 AM. Missed its 6:45 deadline by 27 minutes!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#the-solution",
    "href": "lectures/lec_07_presentation.html#the-solution",
    "title": "Better Routing",
    "section": "The Solution",
    "text": "The Solution\nOnly accept swaps that maintain feasibility!\nimproved = True\nwhile improved:\n    improved = False\n    for i in range(len(route) - 1):\n        for j in range(i + 2, len(route)):\n            new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]\n            # Check feasibility FIRST\n            if not is_feasible(new_route, time_windows, start_time):\n                continue  # Skip infeasible swaps\n            # Among feasible swaps, take if shorter\n            if calculate_distance(new_route) &lt; calculate_distance(route):\n                route = new_route\n                improved = True\n                break\n        if improved:\n            break\n\n\n\n\n\n\n\nFeasibility is a hard constraint, distance is the objective."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#choosing-your-algorithm",
    "href": "lectures/lec_07_presentation.html#choosing-your-algorithm",
    "title": "Better Routing",
    "section": "Choosing Your Algorithm",
    "text": "Choosing Your Algorithm\nDifferent situations call for different approaches:\n\n\n\nSituation\nBest Approach\nWhy\n\n\n\n\nSolution now\nNearest Neighbor\nLightning fast\n\n\nHave seconds\nNN + 2-opt\nGood balance\n\n\nHave minutes\nMulti-start + 2-opt\nExplore more options\n\n\nTime windows\nNN (early) + Or-opt\nPreserves feasibility\n\n\nBenchmark\n3-opt or meta\nBest solutions\n\n\n\n\n\n\n\n\n\n\nCompetition? Choose whatever you are comfortable with."
  },
  {
    "objectID": "lectures/lec_07_presentation.html#implementation-pitfalls-to-avoid",
    "href": "lectures/lec_07_presentation.html#implementation-pitfalls-to-avoid",
    "title": "Better Routing",
    "section": "Implementation Pitfalls to Avoid",
    "text": "Implementation Pitfalls to Avoid\nCommon bugs that cost you time.\n\nForgetting return to bakery:\n# WRONG\ntotal = sum(distances between consecutive stops)\n# RIGHT\ntotal = sum(distances) + distance(last_stop, bakery)\n\n\nIndex confusion in 2-opt:\n# The 2-opt swap reverses route[i+1:j+1], not route[i:j]\n\n\nModifying while iterating:\nnew_route = current_route.copy()  # Don't modify original"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#escaping-local-optima-1",
    "href": "lectures/lec_07_presentation.html#escaping-local-optima-1",
    "title": "Better Routing",
    "section": "Escaping Local Optima",
    "text": "Escaping Local Optima\nWhen local search gets stuck, we need clever escapes:\n\nAdvanced Techniques Coming:\n\nSimulated Annealing: Sometimes accept worse moves\nGenetic Algorithms: Combine good routes to make better ones\nTabu Search: Remember where you’ve been to avoid circles\n\n\n\n\n\n\n\n\n\nToday’s local search foundation makes advanced methods possible!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#summary",
    "href": "lectures/lec_07_presentation.html#summary",
    "title": "Better Routing",
    "section": "Summary",
    "text": "Summary\nKey Takeaways:\n\nTSP is computationally hard (factorial growth)\nLocal search is a universal framework (4 pillars)\nGreedy construction gives fast initial solutions\n2-opt improves solutions iteratively\nMulti-start helps escape local optima\nReal constraints (time windows) add complexity\nTwo-phase approach: Build then improve!"
  },
  {
    "objectID": "lectures/lec_07_presentation.html#break",
    "href": "lectures/lec_07_presentation.html#break",
    "title": "Better Routing",
    "section": "Break!",
    "text": "Break!\nTake 20 minutes, then we start the practice notebook\nNext up: You’ll become Bean Counter’s route planner\nThen: The Bakery competition"
  },
  {
    "objectID": "lectures/lec_07_local_search.html",
    "href": "lectures/lec_07_local_search.html",
    "title": "Better Routing",
    "section": "",
    "text": ". . .\nMaster Baker’s Morning Dilemma:\n“Every morning at 5:00, our delivery van leaves with fresh bread for 16 cafés across the city. Our driver currently takes much too long using his ‘intuition’ for the route. The fuel costs are killing us, and worse, some cafés get their bread late.”\n\n\n\nArtisan Bakery’s daily logistics puzzle:\n\n\n16 Cafés: Each expecting fresh bread by 8:00\nOne Van: Unlimited capacity, must visit all locations\nTime Windows: 3 cafés open early (6:30) and need priority\nCurrent Problem: Driver uses “gut feeling” for routing\n\n\n. . .\n\n\n\n\n\n\nThe Stakes: Poor routing costs plus reputation damage from late deliveries!\n\n\n\n\n\n\nLast week we learned greedy algorithms for scheduling:\n\n\nSPT: Process shortest jobs first\nEDD: Process by earliest due date\nFast & Simple: Made quick decisions, no looking back\n\n\n. . .\nQuestion: Can we use the same greedy approach for routing?\n. . .\n\n\n\n\n\n\nToday: We’ll start greedy, then learn how to improve solutions with local search!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#client-briefing-artisan-bakery",
    "href": "lectures/lec_07_local_search.html#client-briefing-artisan-bakery",
    "title": "Better Routing",
    "section": "",
    "text": ". . .\nMaster Baker’s Morning Dilemma:\n“Every morning at 5:00, our delivery van leaves with fresh bread for 16 cafés across the city. Our driver currently takes much too long using his ‘intuition’ for the route. The fuel costs are killing us, and worse, some cafés get their bread late.”",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-delivery-challenge",
    "href": "lectures/lec_07_local_search.html#the-delivery-challenge",
    "title": "Better Routing",
    "section": "",
    "text": "Artisan Bakery’s daily logistics puzzle:\n\n\n16 Cafés: Each expecting fresh bread by 8:00\nOne Van: Unlimited capacity, must visit all locations\nTime Windows: 3 cafés open early (6:30) and need priority\nCurrent Problem: Driver uses “gut feeling” for routing\n\n\n. . .\n\n\n\n\n\n\nThe Stakes: Poor routing costs plus reputation damage from late deliveries!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#quick-recap-greedy-decisions",
    "href": "lectures/lec_07_local_search.html#quick-recap-greedy-decisions",
    "title": "Better Routing",
    "section": "",
    "text": "Last week we learned greedy algorithms for scheduling:\n\n\nSPT: Process shortest jobs first\nEDD: Process by earliest due date\nFast & Simple: Made quick decisions, no looking back\n\n\n. . .\nQuestion: Can we use the same greedy approach for routing?\n. . .\n\n\n\n\n\n\nToday: We’ll start greedy, then learn how to improve solutions with local search!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-traveling-salesman-problem",
    "href": "lectures/lec_07_local_search.html#the-traveling-salesman-problem",
    "title": "Better Routing",
    "section": "The Traveling Salesman Problem",
    "text": "The Traveling Salesman Problem\nVisit all locations exactly once, minimize total distance.\n. . .",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#compute-everything",
    "href": "lectures/lec_07_local_search.html#compute-everything",
    "title": "Better Routing",
    "section": "Compute Everything?",
    "text": "Compute Everything?\nHow many unique tours exist? With depot, n!/2 unique tours.\n. . .\nIf your computer checks 1 million routes per second:\n\n\n4 cafés: 4!/2 = 12 tours → 0.000012 seconds ✓\n8 cafés: 8!/2 = 20,160 tours → 0.02 seconds ✓\n12 cafés: 12!/2 = 239,500,800 tours → 4 minutes ~\n16 cafés: 16!/2 = 10,461,394,944,000 tours → 4 months! ✗\n20 cafés: 20!/2 → 38,573 years! ✗\n\n\n. . .\n\n\n\n\n\n\nThe Reality: Exact approach would take longer than the universe has existed!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-cost-of-complexity",
    "href": "lectures/lec_07_local_search.html#the-cost-of-complexity",
    "title": "Better Routing",
    "section": "The “Cost” of Complexity",
    "text": "The “Cost” of Complexity\nWhy buying a faster computer won’t help:\n\n\nP: Tasks that can be solved in polynomial time\n\nLike sorting a spreadsheet or calculating payroll\nThese are safe, predictable, and easy to automate\n\nNP: Easy to check, hard to solve\n\nAnalogy: easy to check if a specific password works\nVery hard to guess a password by trying every combination!\n\n\n\n. . .\n\n\n\n\n\n\nTSP optimization where we find minimum cost tour → NP-Hard. This means no known algorithm can find the perfect solution quickly for large problems.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#what-is-a-graph",
    "href": "lectures/lec_07_local_search.html#what-is-a-graph",
    "title": "Better Routing",
    "section": "What is a Graph?",
    "text": "What is a Graph?\nA graph \\(G = (V, E)\\) consists of:\n\n\nVertices (V): The nodes or points (bakery + cafés)\nEdges (E): The connections between vertices (roads)\nWeight Function: \\(w\\) assigns costs to edges (distances)\n\n\n. . .\nFor our bakery problem:\n\n\n\\(|V| = 17\\) (1 bakery + 17 cafés)\n\\(|E| = \\binom{17}{2} = 136\\) possible connections\nEach edge \\((i,j)\\) has weight \\(w_{ij}\\) = distance between \\(i\\) and \\(j\\)",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#complete-vs.-sparse-graphs",
    "href": "lectures/lec_07_local_search.html#complete-vs.-sparse-graphs",
    "title": "Better Routing",
    "section": "Complete vs. Sparse Graphs",
    "text": "Complete vs. Sparse Graphs\nDifferent graph structures lead to different complexities:\n\n\nComplete Graph: All vertices connected to each other\n\nTSP: \\((n-1)!/2\\) unique tours\nReal roads: Usually complete (drive between any two points)\n\nSparse Graph: Limited connections between vertices\n\nFewer edges = fewer possible routes\nExamples: Public transit networks, restricted road access\n\n\n\n. . .\n\n\n\n\n\n\nDensity dramatically affects both problem difficulty and solution approaches!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#hamiltonian-cycles-and-tours",
    "href": "lectures/lec_07_local_search.html#hamiltonian-cycles-and-tours",
    "title": "Better Routing",
    "section": "Hamiltonian Cycles and Tours",
    "text": "Hamiltonian Cycles and Tours\nMathematical foundation of the TSP:\n\n\nHamiltonian Path: Visits each vertex exactly once\nHamiltonian Cycle: Hamiltonian path that returns to start vertex\nTSP Tour: Minimum weight Hamiltonian cycle\n\n\n. . .\nMathematical Definition: A tour \\(T = (v_1, v_2, ..., v_n, v_1)\\) where:\n\nEach \\(v_i \\in V\\) appears exactly once (except start/end)\nTotal weight: \\(w(T) = \\sum_{i=1}^{n} w_{v_i, v_{i+1}}\\) (where \\(v_{n+1} = v_1\\))\n\n. . .\nGoal: Find tour \\(T^*\\) such that \\(w(T^*) = \\min_{T \\in \\mathcal{H}} w(T)\\)",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#distance-functions-and-metrics",
    "href": "lectures/lec_07_local_search.html#distance-functions-and-metrics",
    "title": "Better Routing",
    "section": "Distance Functions and Metrics",
    "text": "Distance Functions and Metrics\nThe weight function can have different properties:\n\nIdentity: \\(d(i,i) = 0\\) \\(i \\in V\\)\nSymmetry: \\(d(i,j) = d(j,i)\\) \\(i,j \\in V\\)\nTriangle Inequality: \\(d(i,k) \\leq d(i,j) + d(j,k) \\quad \\forall i,j,k \\in V\\)\n\n. . .\nCommon Distance Functions:\n\nEuclidean: \\(d(i,j) = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}\\)\nManhattan: \\(d(i,j) = |x_i - x_j| + |y_i - y_j|\\)\nReal road distances: Often violate triangle inequality!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#a-bad-start-random-route",
    "href": "lectures/lec_07_local_search.html#a-bad-start-random-route",
    "title": "Better Routing",
    "section": "A Bad Start: Random Route",
    "text": "A Bad Start: Random Route\nWhat happens if we pick cafés randomly?\n. . .\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nRandom selection creates routes with many crossings and inefficiencies.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#nearest-neighbor-the-problem",
    "href": "lectures/lec_07_local_search.html#nearest-neighbor-the-problem",
    "title": "Better Routing",
    "section": "Nearest Neighbor: The Problem",
    "text": "Nearest Neighbor: The Problem\nGiven these 8 cafés, which should we visit first?\n\n\n\n\n\n\n\n\n\n. . .\nQuestion: Using nearest neighbor, which café would you visit first?",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#nearest-neighbor-the-algorithm",
    "href": "lectures/lec_07_local_search.html#nearest-neighbor-the-algorithm",
    "title": "Better Routing",
    "section": "Nearest Neighbor: The Algorithm",
    "text": "Nearest Neighbor: The Algorithm\nBuild a route by always visiting the closest unvisited location.\n\nStart at the bakery\nFind the nearest unvisited café\nGo there\nRepeat until all visited\nReturn to bakery\n\n. . .\n\n\n\n\n\n\nIntuition: Like picking low-hanging fruit - grab what’s easiest (nearest) first!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#nearest-neighbor-the-solution",
    "href": "lectures/lec_07_local_search.html#nearest-neighbor-the-solution",
    "title": "Better Routing",
    "section": "Nearest Neighbor: The Solution",
    "text": "Nearest Neighbor: The Solution\nLet’s see how nearest neighbor builds the route step by step:\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nFarthest insertion builds a more balanced tour by establishing the outer structure first!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#farthest-insertion-the-problem",
    "href": "lectures/lec_07_local_search.html#farthest-insertion-the-problem",
    "title": "Better Routing",
    "section": "Farthest Insertion: The Problem",
    "text": "Farthest Insertion: The Problem\nSame 8 cafés - but now we’ll use a different strategy:\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nThe farthest point is our start!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#farthest-insertion-the-algorithm",
    "href": "lectures/lec_07_local_search.html#farthest-insertion-the-algorithm",
    "title": "Better Routing",
    "section": "Farthest Insertion: The Algorithm",
    "text": "Farthest Insertion: The Algorithm\nBuild a route by starting with distant points and filling in gaps:\n\nStart at the bakery\nFind the farthest café from bakery - add it to tour\nCreate initial tour: Bakery → Farthest → Bakery\nRepeat: Find the café farthest from current tour\nInsert it at the position that minimizes tour increase\nContinue until all cafés are in the tour\n\n. . .\n\n\n\n\n\n\nIntuition: Build the “skeleton” of the route first with distant points, then fill in the gaps.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#farthest-insertion-step-by-step",
    "href": "lectures/lec_07_local_search.html#farthest-insertion-step-by-step",
    "title": "Better Routing",
    "section": "Farthest Insertion: Step-by-Step",
    "text": "Farthest Insertion: Step-by-Step\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nNotice how farthest insertion builds a more balanced tour by establishing the outer structure first, then filling in the gaps!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#comparison",
    "href": "lectures/lec_07_local_search.html#comparison",
    "title": "Better Routing",
    "section": "Comparison",
    "text": "Comparison\nLet’s compare all three construction methods:\n\n\nRandom: Usually worst - no strategy at all!\nNearest Neighbor: Fast and decent, but can create long returns\nFarthest: Often best initial solution, builds good “skeleton”\n\n\n. . .\n\n\n\n\n\n\nThe better your starting point, the better your final result after local search!\n\n\n\n. . .\n\n\n\n\n\n\nThis is also true for all other problems we are solving! A good initial heuristic to create a solution will help us later.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-problem-with-greedy",
    "href": "lectures/lec_07_local_search.html#the-problem-with-greedy",
    "title": "Better Routing",
    "section": "The Problem with Greedy",
    "text": "The Problem with Greedy\nOften obvious inefficiencies in the resulting routes\n\n\nCrossing paths: Route crosses over itself\nLong return: Far from bakery at the end\nMyopic decisions: Can’t see the “big picture”\n\n\n. . .\n\n\n\n\n\n\nCan we improve our greedy solutions?",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-four-pillars-of-local-search",
    "href": "lectures/lec_07_local_search.html#the-four-pillars-of-local-search",
    "title": "Better Routing",
    "section": "The Four Pillars of Local Search",
    "text": "The Four Pillars of Local Search\nAny problem can be solved with local search by defining:\n\n\nSearch Space: All possible solutions (here 10 trillion routes!)\nInitial Solution: Starting point (our greedy route)\nObjective Function: How we measure quality (total distance)\nNeighborhood: How to create “nearby” solutions (2-opt swaps)\n\n\n. . .\n\n\n\n\n\n\nThe power of local search: The same “engine” works for routing, scheduling, or any combinatorial problem - just plug in different components!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#solution-space-an-intuitive-view",
    "href": "lectures/lec_07_local_search.html#solution-space-an-intuitive-view",
    "title": "Better Routing",
    "section": "Solution Space: An Intuitive View",
    "text": "Solution Space: An Intuitive View\nThink of the solution space as a landscape:\n\n\nEach point: A different route through the cafés\nHeight: The total distance of that route (lower is better)\nNeighbors: Routes that differ by small change\nLocal optimum: Best route among nearby alternatives\nGlobal optimum: The absolute best route overall",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#search-strategy",
    "href": "lectures/lec_07_local_search.html#search-strategy",
    "title": "Better Routing",
    "section": "Search Strategy",
    "text": "Search Strategy\nHow can we search this space?\n\n\nStart somewhere (greedy construction)\nLook around at neighboring solutions\nMove to better neighbors\nStop when no neighbor is better\n\n\n. . .\n\n\n\n\n\n\nLocal search transforms “quick and dirty” solutions into “pretty good” ones!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-2-opt-algorithm",
    "href": "lectures/lec_07_local_search.html#the-2-opt-algorithm",
    "title": "Better Routing",
    "section": "The 2-Opt Algorithm",
    "text": "The 2-Opt Algorithm\nSystematically improve routes by removing crossing paths.\n. . .\nThe Idea: Take two edges and swap them (to uncross the route)\n. . .",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#example-step-by-step",
    "href": "lectures/lec_07_local_search.html#example-step-by-step",
    "title": "Better Routing",
    "section": "Example: Step-by-Step",
    "text": "Example: Step-by-Step\nLet’s see exactly how 2-opt fixes a crossing in a real route:\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nThe Key Insight: When you reverse a segment between two crossing edges, you automatically eliminate the crossing and create a shorter route!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#how-2-opt-works",
    "href": "lectures/lec_07_local_search.html#how-2-opt-works",
    "title": "Better Routing",
    "section": "How 2-Opt Works",
    "text": "How 2-Opt Works\nimproved = True\nwhile improved:\n    improved = False\n    best_distance = calculate_route_distance(route, distances)\n    for i in range(len(route) - 1):\n        for j in range(i + 2, len(route)):\n            new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]\n            new_distance = calculate_route_distance(new_route, distances)\n            if new_distance &lt; best_distance:\n                route = new_route\n                best_distance = new_distance\n                improved = True\n                break\n        if improved:\n            break\n. . .\n\n\n\n\n\n\nThe [::-1] reverses the segment, eliminating crossings!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#opt-applied",
    "href": "lectures/lec_07_local_search.html#opt-applied",
    "title": "Better Routing",
    "section": "2-Opt Applied",
    "text": "2-Opt Applied\nLet’s see how this changes the route!\n. . .\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nNotice how 2-opt removed the crossing paths from our nearest neighbor solution, creating a more efficient route!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#common-2-opt-bugs",
    "href": "lectures/lec_07_local_search.html#common-2-opt-bugs",
    "title": "Better Routing",
    "section": "Common 2-Opt Bugs",
    "text": "Common 2-Opt Bugs\nDebug these scenarios you’ll encounter:\n. . .\nBug 1: Infinite Loop\n# WRONG: Forgot to update route\nif new_distance &lt; current_distance:\n    improved = True  # But route never changes!\n. . .\nBug 2: Missing Return to Start\n# WRONG: Only measures cafe-to-cafe\ntotal = sum(distances between stops)\n. . .\nBug 3: Invalid Segment Reversal\n# WRONG: Off-by-one error\nnew_route = route[:i] + route[i:j][::-1] + route[j:]\n. . .\nFix: route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#what-about-1-opt",
    "href": "lectures/lec_07_local_search.html#what-about-1-opt",
    "title": "Better Routing",
    "section": "What About 1-Opt?",
    "text": "What About 1-Opt?\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nWhere 1-opt DOES work: In problems like knapsack (swap 1 item), assignment (reassign 1 person), or facility location (relocate 1 facility).",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#or-opt-moving-sequences",
    "href": "lectures/lec_07_local_search.html#or-opt-moving-sequences",
    "title": "Better Routing",
    "section": "Or-Opt: Moving Sequences",
    "text": "Or-Opt: Moving Sequences\nMoves sequence of 1-3 consecutive cities to different position.\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nMoving a sequence can satisfy time constraints without breaking tour structure!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#beyond-k-opt-neighborhoods",
    "href": "lectures/lec_07_local_search.html#beyond-k-opt-neighborhoods",
    "title": "Better Routing",
    "section": "Beyond: k-Opt Neighborhoods",
    "text": "Beyond: k-Opt Neighborhoods\nThe k-opt family of improvements:\n\n\n2-opt\n\nRemoves 2 edges\n1 way to reconnect\nn² combinations\nFast, good results\n\n\n3-opt\n\nRemoves 3 edges\n7 ways to reconnect\nn³ combinations\nBetter but slower\n\n\nOr-opt\n\nMoves 1-3 nodes\nGood for time windows\nSpecialized variant\n\n\n\n. . .\n\n\n\n\n\n\nStart with 2-opt (fast), use 3-opt if you have time! As k increases, solutions improve but computation time grows exponentially.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#convergence-and-local-optima",
    "href": "lectures/lec_07_local_search.html#convergence-and-local-optima",
    "title": "Better Routing",
    "section": "Convergence and Local Optima",
    "text": "Convergence and Local Optima\nWhen does local search stop? Why might it get stuck?\n. . .\nConvergence:\n\nAlgorithm stops when no neighboring solution is better\n\n. . .\nThe Local Optimum Problem:\n\n\nAlgorithm can only “see” neighboring solutions\nMight miss better solutions that require multiple changes\nLike being stuck on a small hill when there’s a mountain nearby\n\n\n. . .\n\n\n\n\n\n\nLocal search for improvement but does not guarantee global optimality.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-local-optimum-trap",
    "href": "lectures/lec_07_local_search.html#the-local-optimum-trap",
    "title": "Better Routing",
    "section": "The Local Optimum Trap",
    "text": "The Local Optimum Trap\nImagine you’re a hiker dropped in foggy mountains at night…\n\n\nYour Mission: Find the highest peak (global optimum)\nYour Tool: An altimeter (objective function)\nYour Vision: Only the ground at your feet (local neighborhood)\n\n\n. . .\n\nThe Greedy Strategy: Always step uphill\n\n. . .\nQuestion: What happens when you reach the top of a small hill?\n. . .\n\n\n\n\n\n\nYou’re stuck! Every step is downhill, but you might be on a tiny hill while a much larger moutain is nearby. This is the local optimum trap!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#visualizing-local-optima",
    "href": "lectures/lec_07_local_search.html#visualizing-local-optima",
    "title": "Better Routing",
    "section": "Visualizing Local Optima",
    "text": "Visualizing Local Optima\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere, the local minimum is already quite good, but we likely won’t reach the global optimum from here.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-reality",
    "href": "lectures/lec_07_local_search.html#the-reality",
    "title": "Better Routing",
    "section": "The Reality",
    "text": "The Reality\nReal problems often have thousands of local optima!\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nThe probability of finding the global optimum with simple local search is nearly zero!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#escaping-local-optima",
    "href": "lectures/lec_07_local_search.html#escaping-local-optima",
    "title": "Better Routing",
    "section": "Escaping Local Optima",
    "text": "Escaping Local Optima\nDepending on the problem: Multi-Start Strategy!\n\n\nMost local minima are much worse than the global optimum\nThe global minimum is sometimes isolated and hard to reach\nStarting point dramatically affects final solution quality\nThus, start with different random solutions\nUse different initial heuristics\n\n\n. . .\n\n\n\n\n\n\nNo Free Lunch Theorem: There’s no universal “best” algorithm for all problems. What works great for routing might fail for scheduling. Always match your tool to your problem!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#how-good-is-good-enough",
    "href": "lectures/lec_07_local_search.html#how-good-is-good-enough",
    "title": "Better Routing",
    "section": "How Good is Good Enough?",
    "text": "How Good is Good Enough?\nIndustry usage for delivery optimization\n\n\n\nMethod\nIndustry Use\n\n\n\n\n\nHuman intuition\nStill common!\n\n\n\nStart + 2-opt\nCommon practice\n\n\n\nAdvanced Meta\nSometimes practice\n\n\n\nExact (if possible)\nMostly research\n\n\n\n\n. . .\n\n\n\n\n\n\nA 10% improvement = millions in savings for large logistics companies. Even a 2-opt implementation could literally save a lot of money if not used yet!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#time-windows",
    "href": "lectures/lec_07_local_search.html#time-windows",
    "title": "Better Routing",
    "section": "Time Windows",
    "text": "Time Windows\nRemember our bakery? Some cafés open earlier than others!\n. . .\nArtisan Bakery’s Morning Schedule:\n\nBakery opens: 5:00 (van departs)\nEarly Birds (3 cafés): Must receive by 6:30\n\nCafé Europa, Sunrise Bistro, Morning Glory\n\nStandard (13 cafés): Must receive by 8:00\n\n. . .\nQuestion: Can we just find the shortest route?\n. . .\n\n\n\n\n\n\nThe shortest route might deliver to early cafés last. Feasibility first, optimization second!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#time-windows-practical-approach",
    "href": "lectures/lec_07_local_search.html#time-windows-practical-approach",
    "title": "Better Routing",
    "section": "Time Windows: Practical Approach",
    "text": "Time Windows: Practical Approach\nEach location has a delivery time window:\nKey Concepts:\n\nEarliest time: When café opens\nLatest time: Delivery deadline\nService time: Time to unload\n\n. . .\nArrival Time = Previous departure + Travel time\n. . .\n\nFeasible route: All deadlines met\nInfeasible route: At least one deadline missed (even if shortest!)",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#time-windows-nn-modification",
    "href": "lectures/lec_07_local_search.html#time-windows-nn-modification",
    "title": "Better Routing",
    "section": "Time Windows: NN Modification",
    "text": "Time Windows: NN Modification\nModify greedy construction to prioritize early deadlines:\nunvisited = set(range(len(locations))); route = []; current_time = start_time\nwhile unvisited:\n    # Find feasible neighbors (can reach before deadline)\n    feasible = [i for i in unvisited\n                if current_time + travel_time(current, i)\n                    &lt;= time_windows[i]['latest']]\n    if not feasible:\n        return None  # No feasible route exists!\n    # Among feasible, choose most urgent\n    next_stop = min(feasible, key=lambda i: (time_windows[i]['latest']))\n    # Update state\n    route.append(next_stop)\n    unvisited.remove(next_stop)\n    current_time += travel_time(current, next_stop) + service_time",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#opt-with-time-windows",
    "href": "lectures/lec_07_local_search.html#opt-with-time-windows",
    "title": "Better Routing",
    "section": "2-Opt with Time Windows",
    "text": "2-Opt with Time Windows\nProblem: 2-opt can break time feasibility!\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nEarly2 now arrives at 7:12 AM. Missed its 6:45 deadline by 27 minutes!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#the-solution",
    "href": "lectures/lec_07_local_search.html#the-solution",
    "title": "Better Routing",
    "section": "The Solution",
    "text": "The Solution\nOnly accept swaps that maintain feasibility!\nimproved = True\nwhile improved:\n    improved = False\n    for i in range(len(route) - 1):\n        for j in range(i + 2, len(route)):\n            new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]\n            # Check feasibility FIRST\n            if not is_feasible(new_route, time_windows, start_time):\n                continue  # Skip infeasible swaps\n            # Among feasible swaps, take if shorter\n            if calculate_distance(new_route) &lt; calculate_distance(route):\n                route = new_route\n                improved = True\n                break\n        if improved:\n            break\n. . .\n\n\n\n\n\n\nFeasibility is a hard constraint, distance is the objective.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#choosing-your-algorithm",
    "href": "lectures/lec_07_local_search.html#choosing-your-algorithm",
    "title": "Better Routing",
    "section": "Choosing Your Algorithm",
    "text": "Choosing Your Algorithm\nDifferent situations call for different approaches:\n\n\n\nSituation\nBest Approach\nWhy\n\n\n\n\nSolution now\nNearest Neighbor\nLightning fast\n\n\nHave seconds\nNN + 2-opt\nGood balance\n\n\nHave minutes\nMulti-start + 2-opt\nExplore more options\n\n\nTime windows\nNN (early) + Or-opt\nPreserves feasibility\n\n\nBenchmark\n3-opt or meta\nBest solutions\n\n\n\n. . .\n\n\n\n\n\n\nCompetition? Choose whatever you are comfortable with.",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#implementation-pitfalls-to-avoid",
    "href": "lectures/lec_07_local_search.html#implementation-pitfalls-to-avoid",
    "title": "Better Routing",
    "section": "Implementation Pitfalls to Avoid",
    "text": "Implementation Pitfalls to Avoid\nCommon bugs that cost you time.\n. . .\nForgetting return to bakery:\n# WRONG\ntotal = sum(distances between consecutive stops)\n# RIGHT\ntotal = sum(distances) + distance(last_stop, bakery)\n. . .\nIndex confusion in 2-opt:\n# The 2-opt swap reverses route[i+1:j+1], not route[i:j]\n. . .\nModifying while iterating:\nnew_route = current_route.copy()  # Don't modify original",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#escaping-local-optima-1",
    "href": "lectures/lec_07_local_search.html#escaping-local-optima-1",
    "title": "Better Routing",
    "section": "Escaping Local Optima",
    "text": "Escaping Local Optima\nWhen local search gets stuck, we need clever escapes:\n. . .\nAdvanced Techniques Coming:\n\nSimulated Annealing: Sometimes accept worse moves\nGenetic Algorithms: Combine good routes to make better ones\nTabu Search: Remember where you’ve been to avoid circles\n\n. . .\n\n\n\n\n\n\nToday’s local search foundation makes advanced methods possible!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#summary",
    "href": "lectures/lec_07_local_search.html#summary",
    "title": "Better Routing",
    "section": "Summary",
    "text": "Summary\nKey Takeaways:\n\n\nTSP is computationally hard (factorial growth)\nLocal search is a universal framework (4 pillars)\nGreedy construction gives fast initial solutions\n2-opt improves solutions iteratively\nMulti-start helps escape local optima\nReal constraints (time windows) add complexity\nTwo-phase approach: Build then improve!",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_07_local_search.html#break",
    "href": "lectures/lec_07_local_search.html#break",
    "title": "Better Routing",
    "section": "Break!",
    "text": "Break!\nTake 20 minutes, then we start the practice notebook\nNext up: You’ll become Bean Counter’s route planner\nThen: The Bakery competition",
    "crumbs": [
      "07 Local Search",
      "07 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_presentation.html#client-briefing-megamart-retail-chain",
    "href": "lectures/lec_05_presentation.html#client-briefing-megamart-retail-chain",
    "title": "Forecasting the Future",
    "section": "Client Briefing: MegaMart Retail Chain",
    "text": "Client Briefing: MegaMart Retail Chain\n\nOperations Director’s Crisis:\n“Last Christmas, we ran out of PlayStation 5s but had 500 unsold fitness trackers. We lost €2M in missed sales and clearance losses. How do we predict what customers will actually buy?”"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#business-the-unknown-future",
    "href": "lectures/lec_05_presentation.html#business-the-unknown-future",
    "title": "Forecasting the Future",
    "section": "Business: The Unknown Future",
    "text": "Business: The Unknown Future\nQuestion: Why can’t we just order the same as last year?\n\nMarket: New products, competition\nSeasonal Shifts: Weather, holidays, economic conditions\nTrend Changes: Changing preferences, new technologies\nRandomness: Viral TikToks, supply chain disruptions, pandemics\n\n\n\n\n\n\n\n\nReality: Large retailers process several thousand orders per hour. Each stockout basically means lost revenue + unhappy customers."
  },
  {
    "objectID": "lectures/lec_05_presentation.html#hidden-patterns-in-data",
    "href": "lectures/lec_05_presentation.html#hidden-patterns-in-data",
    "title": "Forecasting the Future",
    "section": "Hidden Patterns in Data",
    "text": "Hidden Patterns in Data\nLook at this daily sales data. What patterns do you see?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#decomposing-time-series",
    "href": "lectures/lec_05_presentation.html#decomposing-time-series",
    "title": "Forecasting the Future",
    "section": "Decomposing Time Series",
    "text": "Decomposing Time Series\nTime series can often be decomposed:\n\n\\[Y_t = T_t + S_t + R_t\\]\n\n\nWhere:\n\n\\(Y_t\\) = Observed value at time t\n\\(T_t\\) = Trend component\n\\(S_t\\) = Seasonal component\n\\(R_t\\) = Random/Residual component"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#additive-vs-multiplicative-models",
    "href": "lectures/lec_05_presentation.html#additive-vs-multiplicative-models",
    "title": "Forecasting the Future",
    "section": "Additive vs Multiplicative Models",
    "text": "Additive vs Multiplicative Models\nHow do the components combine?\n\n\n\nAdditive Model \\[Y_t = T_t + S_t + R_t\\]\n\nSeasonal fluctuations are constant\n“We always sell 200 extra in December”\nGood: Stable, mature products\n\n\nMultiplicative Model \\[Y_t = T_t \\times S_t \\times R_t\\]\n\nSeasonal fluctuations scale with trend\n“December sales are 40% higher”\nGood: Growing businesses"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#visual-decomposition",
    "href": "lectures/lec_05_presentation.html#visual-decomposition",
    "title": "Forecasting the Future",
    "section": "Visual Decomposition",
    "text": "Visual Decomposition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere: Sales = Trend + Seasonality + Random Noise"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#moving-average",
    "href": "lectures/lec_05_presentation.html#moving-average",
    "title": "Forecasting the Future",
    "section": "Moving Average",
    "text": "Moving Average\nQuestion: How do we separate signal from noise?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#simple-vs-weighted-averages",
    "href": "lectures/lec_05_presentation.html#simple-vs-weighted-averages",
    "title": "Forecasting the Future",
    "section": "Simple vs Weighted Averages",
    "text": "Simple vs Weighted Averages\nWhich forecast would you trust more?\n\n\n\nSimple Moving Average\n\nAll days equally important\nWe just take the average\n[14, 15, 16, 14, 15, 16, 17]\nForecast: 15.3\n\n\nWeighted Moving Average\n\nRecent days matter more\nDays closer are weighted more\n[0.05, 0.05, 0.1, 0.1, 0.2, 0.2, 0.3]\nForecast: 15.9\n\n\n\n\n\n\n\n\n\n\nRecent data often predicts the future better than old data!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#simple-exponential-smoothing",
    "href": "lectures/lec_05_presentation.html#simple-exponential-smoothing",
    "title": "Forecasting the Future",
    "section": "Simple Exponential Smoothing",
    "text": "Simple Exponential Smoothing\nNot too simple, not too complex\n\n\\[\\text{Forecast}_{t+1} = \\alpha \\times \\text{Actual}_t + (1-\\alpha) \\times \\text{Forecast}_t\\]\n\n\n\nα (alpha) = smoothing parameter (0 to 1)\nα = 0.9: Trust recent data (reactive)\nα = 0.1: Trust historical patterns (stable)\nα = 0.3: Balanced approach (common default)\n\n\n\n\n\n\n\n\n\nThink of \\(\\alpha\\) like: How much do you trust the latest data point?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#when-simple-smoothing-fails",
    "href": "lectures/lec_05_presentation.html#when-simple-smoothing-fails",
    "title": "Forecasting the Future",
    "section": "When Simple Smoothing Fails",
    "text": "When Simple Smoothing Fails\nSimple smoothing assumes the data is flat. What if it’s not?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holts-method-the-idea",
    "href": "lectures/lec_05_presentation.html#holts-method-the-idea",
    "title": "Forecasting the Future",
    "section": "Holt’s Method: The Idea",
    "text": "Holt’s Method: The Idea\nTrack TWO things separately: Level and Trend\n\nLevel (L): Where are we right now? (like simple ES)\nTrend (b): How fast are we growing/declining per period?\nForecast: Combine both: Level + (Trend × periods ahead)\n\n\nWhy This Works:\n\nSimple ES only tracks level (current position)\nHolt’s also tracks the slope (direction and speed)\n\n\n\n\n\n\n\n\n\nThink of driving a car: Simple ES only knows your position. Holt’s also knows your speed!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holts-method-the-math-i",
    "href": "lectures/lec_05_presentation.html#holts-method-the-math-i",
    "title": "Forecasting the Future",
    "section": "Holt’s Method: The Math I",
    "text": "Holt’s Method: The Math I\nThe formulas (simplified for intuition):\n\nLevel Equation: \\[L_t = \\alpha \\times Y_t + (1-\\alpha) \\times (L_{t-1} + b_{t-1})\\]\nTrend Equation: \\[b_t = \\beta \\times (L_t - L_{t-1}) + (1-\\beta) \\times b_{t-1}\\]\nForecast Equation: \\[\\hat{Y}_{t+h} = L_t + h \\times b_t\\]"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holts-method-the-math-ii",
    "href": "lectures/lec_05_presentation.html#holts-method-the-math-ii",
    "title": "Forecasting the Future",
    "section": "Holt’s Method: The Math II",
    "text": "Holt’s Method: The Math II\nIn plain English\n\nLevel: “Smooth current observation with previous forecast”\nTrend: “Smooth the change in level with our previous trend”\nForecast: “Start at current, add trend for each period ahead”\n\n\n\n\n\n\n\n\nNot too complicated, right?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#step-by-step-i",
    "href": "lectures/lec_05_presentation.html#step-by-step-i",
    "title": "Forecasting the Future",
    "section": "Step-by-Step I",
    "text": "Step-by-Step I\nLet’s walk through 6 periods manually to build intuition\n\n# Sample data with clear upward trend\nsales_data = np.array([100, 105, 112, 118, 124, 130])\n\n# Parameters\nalpha = 0.3  # Level smoothing\nbeta = 0.2   # Trend smoothing\n\n# Initialize\nlevel = sales_data[0]  # Start at first observation\ntrend = sales_data[1] - sales_data[0]  # Initial trend estimate\n\nprint(f\"Period 1: Level={level:.1f}, Trend={trend:.1f}\")\n\n# Store level and trend history for visualization\nlevel_history = [level]\ntrend_history = [trend]\n\n\n\nPeriod 1: Level=100.0, Trend=5.0"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#step-by-step-ii",
    "href": "lectures/lec_05_presentation.html#step-by-step-ii",
    "title": "Forecasting the Future",
    "section": "Step-by-Step II",
    "text": "Step-by-Step II\n\n# Apply Holt's method for periods 2-6\nfor t in range(1, len(sales_data)):\n    # Update level\n    prev_level = level\n    level = alpha * sales_data[t] + (1 - alpha) * (prev_level + trend)\n\n    # Update trend\n    trend = beta * (level - prev_level) + (1 - beta) * trend\n\n    # Store for visualization\n    level_history.append(level)\n    trend_history.append(trend)\n\n    print(f\"Period {t+1}: Sales={sales_data[t]}, Level={level:.1f}, Trend={trend:.1f}\")\n\n\n\nPeriod 2: Sales=105, Level=105.0, Trend=5.0\nPeriod 3: Sales=112, Level=110.6, Trend=5.1\nPeriod 4: Sales=118, Level=116.4, Trend=5.3\nPeriod 5: Sales=124, Level=122.4, Trend=5.4\nPeriod 6: Sales=130, Level=128.4, Trend=5.5"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#step-by-step-iii",
    "href": "lectures/lec_05_presentation.html#step-by-step-iii",
    "title": "Forecasting the Future",
    "section": "Step-by-Step III",
    "text": "Step-by-Step III\n\n# Forecast next 3 periods\nprint(f\"\\nForecasts:\")\nforecast_values = []\nfor h in range(1, 4):\n    forecast = level + h * trend\n    forecast_values.append(forecast)\n    print(f\"  Period {len(sales_data)+h}: {forecast:.1f} units\")\n\n\n\n\nForecasts:\n  Period 7: 134.0 units\n  Period 8: 139.5 units\n  Period 9: 145.0 units"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holts-method-visual-comparison",
    "href": "lectures/lec_05_presentation.html#holts-method-visual-comparison",
    "title": "Forecasting the Future",
    "section": "Holt’s Method: Visual Comparison",
    "text": "Holt’s Method: Visual Comparison"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#choosing-alpha-and-beta",
    "href": "lectures/lec_05_presentation.html#choosing-alpha-and-beta",
    "title": "Forecasting the Future",
    "section": "Choosing Alpha and Beta",
    "text": "Choosing Alpha and Beta\nHow do you pick the right smoothing parameters?\n\n\n\nAlpha (Level Smoothing)\n\nHigh α (0.7-0.9): Responsive\n\nUse: Volatile markets\n\nLow α (0.1-0.3): Stable\n\nUse: Steady business\n\n\n\nBeta (Trend Smoothing)\n\nHigh β (0.5-0.8): Quickly\n\nUse: Dynamic growth/decline\n\nLow β (0.1-0.3): Stable trend\n\nUse: Consistent growth\n\n\n\n\n\nBest Practice: Let the algorithm optimize parameters automatically!\n\n\n\n\n\n\n\n\nYou can implement Holt’s method using Python’s statsmodels library!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#when-to-use",
    "href": "lectures/lec_05_presentation.html#when-to-use",
    "title": "Forecasting the Future",
    "section": "When to Use",
    "text": "When to Use\nQuestion: When should you use Holt’s method?\n\n\nClear upward or downward trend\nNo seasonal patterns\n\n\n\nQuestion: When should you use NOT Holt’s method?\n\nData is flat (use simple ES instead)\nStrong seasonality present\nTrend direction changes frequently"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#the-problem-trend-seasonality",
    "href": "lectures/lec_05_presentation.html#the-problem-trend-seasonality",
    "title": "Forecasting the Future",
    "section": "The Problem: Trend + Seasonality",
    "text": "The Problem: Trend + Seasonality\nWhat if your data has BOTH trend AND seasonality?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holt-winters-three-components",
    "href": "lectures/lec_05_presentation.html#holt-winters-three-components",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: Three Components",
    "text": "Holt-Winters: Three Components\nTrack THREE things separately: Level, Trend, AND Seasonality\n\nLevel (L): Current baseline demand (deseasonalized)\nTrend (b): Growth rate per period\nSeasonal Indices (s): Multipliers for each season"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holt-winters-visualized",
    "href": "lectures/lec_05_presentation.html#holt-winters-visualized",
    "title": "Forecasting the Future",
    "section": "Holt-Winters Visualized",
    "text": "Holt-Winters Visualized"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#seasonality",
    "href": "lectures/lec_05_presentation.html#seasonality",
    "title": "Forecasting the Future",
    "section": "Seasonality",
    "text": "Seasonality\nHow does seasonality combine with the level?\n\n\n\nAdditive Model \\[Y_t = L_t + b_t + s_t\\]\n\nSeasonal variation is constant\n“We sell +50 units every December”\nPattern: ±constant amount\n\n\nMultiplicative Model \\[Y_t = L_t \\times b_t \\times s_t\\]\n\nSeasonal variation scales with level\n“December is 1.5× normal sales”\nPattern: ×percentage change"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holt-winters-the-math-i",
    "href": "lectures/lec_05_presentation.html#holt-winters-the-math-i",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: The Math I",
    "text": "Holt-Winters: The Math I\nThe formulas (don’t panic - Python does this for you!)\n\nAdditive Model:\n\\[L_t = \\alpha(Y_t - s_{t-m}) + (1-\\alpha)(L_{t-1} + b_{t-1})\\] \\[b_t = \\beta(L_t - L_{t-1}) + (1-\\beta)b_{t-1}\\] \\[s_t = \\gamma(Y_t - L_t) + (1-\\gamma)s_{t-m}\\] \\[\\hat{Y}_{t+h} = L_t + hb_t + s_{t+h-m}\\]"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holt-winters-the-math-ii",
    "href": "lectures/lec_05_presentation.html#holt-winters-the-math-ii",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: The Math II",
    "text": "Holt-Winters: The Math II\nIn plain English\n\nLevel: Remove seasonality from observation, then smooth\nTrend: Same as Holt’s method\nSeasonal: Update the seasonal index for this period\nForecast: Level + trend + seasonal adjustment\n\n\nParameters:\n\\(\\alpha\\) (level), \\(\\beta\\) (trend), \\(\\gamma\\) (seasonal), m (seasonal period length)"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holt-winters-intuition-i",
    "href": "lectures/lec_05_presentation.html#holt-winters-intuition-i",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: Intuition I",
    "text": "Holt-Winters: Intuition I\nUnderstanding seasonal patterns with quarterly sales\n\nQuarterly Sales Pattern:\n\nQ1: Low season (after holidays) → Factor: 0.85\nQ2: Spring pickup → Factor: 0.95\nQ3: Summer growth → Factor: 1.05\nQ4: Holiday peak! → Factor: 1.15"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holt-winters-intuition-i-1",
    "href": "lectures/lec_05_presentation.html#holt-winters-intuition-i-1",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: Intuition I",
    "text": "Holt-Winters: Intuition I\nHow Holt-Winters Works\n\nDeseasonalize the data (remove seasonal effect)\nCalculate trend from deseasonalized data\nUpdate seasonal indices based on actual vs. expected\nForecast by combining level + trend + seasonal pattern\n\n\n\n\n\n\n\n\nQ4 is typically 35% higher than Q1 in retail! Holt-Winters captures this automatically."
  },
  {
    "objectID": "lectures/lec_05_presentation.html#holt-winters-visual",
    "href": "lectures/lec_05_presentation.html#holt-winters-visual",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: Visual",
    "text": "Holt-Winters: Visual\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice how the forecast continues the seasonal pattern while following the trend!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#when-to-use-holt-winters",
    "href": "lectures/lec_05_presentation.html#when-to-use-holt-winters",
    "title": "Forecasting the Future",
    "section": "When to Use Holt-Winters",
    "text": "When to Use Holt-Winters\nQuestion: When should you use Holt-Winters method?\n\n\nData with trend AND seasonality\nAt least 1 full seasonal cycle (2 are better!)\nRegular, repeating patterns\n\n\n\nQuestion: When should you AVOID Holt-Winters method?\n\n\n\nIrregular or changing seasonal patterns\nFlat data with no trend\nSeasonal pattern length unknown"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#measuring-forecast-accuracy",
    "href": "lectures/lec_05_presentation.html#measuring-forecast-accuracy",
    "title": "Forecasting the Future",
    "section": "Measuring Forecast Accuracy",
    "text": "Measuring Forecast Accuracy\nHow wrong were we?\n\nMean Absolute Error (MAE): Average size of mistakes \\[\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |Actual_i - Forecast_i|\\]\n\n\nRoot Mean Squared Error (RMSE): Penalizes large errors more \\[\\text{RMSE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (Actual_i - Forecast_i)^2}\\]"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#forecast-accuracy",
    "href": "lectures/lec_05_presentation.html#forecast-accuracy",
    "title": "Forecasting the Future",
    "section": "Forecast Accuracy",
    "text": "Forecast Accuracy\nEasy with Python\n\n# Example: Compare two forecasting methods\nactual = np.array([100, 105, 110, 108, 112])\nforecast_a = np.array([98, 107, 109, 110, 111])\nforecast_b = np.array([102, 103, 112, 106, 113])\n\nmae_a = np.mean(np.abs(actual - forecast_a))\nmae_b = np.mean(np.abs(actual - forecast_b))\n\nprint(f\"Method A - MAE: {mae_a:.2f} units\")\nprint(f\"Method B - MAE: {mae_b:.2f} units\")\nprint(f\"\\nBetter method: {'A' if mae_a &lt; mae_b else 'B'}\")\n\n\n\nMethod A - MAE: 1.60 units\nMethod B - MAE: 1.80 units\n\nBetter method: A"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#when-to-use-which-method",
    "href": "lectures/lec_05_presentation.html#when-to-use-which-method",
    "title": "Forecasting the Future",
    "section": "When to Use Which Method?",
    "text": "When to Use Which Method?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStart simple: Try moving average first as baseline, then add complexity only if needed!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#the-real-cost-of-being-wrong",
    "href": "lectures/lec_05_presentation.html#the-real-cost-of-being-wrong",
    "title": "Forecasting the Future",
    "section": "The Real Cost of Being Wrong",
    "text": "The Real Cost of Being Wrong\nNot all forecast errors are equal!\n\nExample: Winter Coats\n\nCost: €50, Selling Price: €150, Margin: €100\nStorage cost: €5/month\nClearance markdown: 70% off\n\n\n\nQuestion: What is your intuition here?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#under-and-overforecasting",
    "href": "lectures/lec_05_presentation.html#under-and-overforecasting",
    "title": "Forecasting the Future",
    "section": "Under and Overforecasting",
    "text": "Under and Overforecasting\nSometimes it’s cheaper to overstock than to miss sales!\n\n\n\nUnderforecast by 100 units:\n\nLost profit: 100 × €100\n\n€10,000\n\nCustomer disappointment\nCompetitor gains market share\n\n\nOverforecast by 100 units:\n\nStorage: 100 × €5 × 3 months\n\n€1,500\n\nClearance loss: 100 × €70\n\n€7,000\n\n\n\n\n\n\n\n\n\n\n\nThe “best” forecast depends on your business context."
  },
  {
    "objectID": "lectures/lec_05_presentation.html#your-python-practice-notebook",
    "href": "lectures/lec_05_presentation.html#your-python-practice-notebook",
    "title": "Forecasting the Future",
    "section": "Your Python Practice Notebook",
    "text": "Your Python Practice Notebook\nAll the hands-on coding happens in the interactive tutorial!\n\n\nWorking with dates in Pandas\nImplementing moving averages\nBuilding forecast functions\nApplying Holt’s method\nUsing Holt-Winters\nMeasuring accuracy\n\n\n\n\n\n\n\n\n\nThe notebook guides you step-by-step through Bean Counter’s seasonal demand forecasting challenge!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#the-promise-of-ai",
    "href": "lectures/lec_05_presentation.html#the-promise-of-ai",
    "title": "Forecasting the Future",
    "section": "The Promise of AI",
    "text": "The Promise of AI\nCan machines predict better than classical methods?\nWhat AI/ML brings to forecasting:\n\nHandle hundreds of variables simultaneously\nDetect complex non-linear patterns\nLearn from massive datasets\nAdapt automatically to changes\n\n\n\n\n\n\n\n\nAI doesn’t replace human judgment, it augments it when you have enough data!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#common-aiml-forecasting",
    "href": "lectures/lec_05_presentation.html#common-aiml-forecasting",
    "title": "Forecasting the Future",
    "section": "Common AI/ML Forecasting",
    "text": "Common AI/ML Forecasting\nOverview of popular techniques\n\n\n\nTraditional ML:\n\nRandom Forest: Ensemble of decision trees\nXGBoost: Gradient boosting (very popular)\nSupport Vector Machines: Pattern recognition\n\n\nDeep Learning:\n\nLSTM (Long Short-Term Memory): For sequences\nProphet (Facebook): Automated forecasting\nNeural Networks: Complex patterns\n\n\n\n\n\n\n\n\n\n\nMore complex ≠ Better! Simple methods often win in forecasting."
  },
  {
    "objectID": "lectures/lec_05_presentation.html#the-issue-overfitting",
    "href": "lectures/lec_05_presentation.html#the-issue-overfitting",
    "title": "Forecasting the Future",
    "section": "The Issue: Overfitting",
    "text": "The Issue: Overfitting\nQuestion: What happens when we train an AI on all our data and use it to predict… the same data?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#training-vs-test-data",
    "href": "lectures/lec_05_presentation.html#training-vs-test-data",
    "title": "Forecasting the Future",
    "section": "Training vs Test Data",
    "text": "Training vs Test Data\nNever judge a complex model on the data it learned from!\n\n\n\n\n\n\n\n\n\n\nTraining Data: Where the model learns patterns (70-80%)\nValidation Data: Where you tune hyperparameters (10-15%)\nTest Data: The “future”, only once for final evaluation (10-15%)"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#data-leakage-the-silent-problem",
    "href": "lectures/lec_05_presentation.html#data-leakage-the-silent-problem",
    "title": "Forecasting the Future",
    "section": "Data Leakage: The Silent Problem",
    "text": "Data Leakage: The Silent Problem\nWhen future information sneaks into your training data\n\n\nTarget leakage\n\nWrong: Including “total_sales” when predicting “monthly_sales”\nRight: Only use information available at prediction time\n\nTemporal leakage\n\nWrong: Random split for time series (mixes past and future)\nRight: Always split chronologically\n\n\n\n\n\n\n\n\n\n\nData leakage can make a terrible model look amazing… until it fails in production!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#time-series-cross-validation",
    "href": "lectures/lec_05_presentation.html#time-series-cross-validation",
    "title": "Forecasting the Future",
    "section": "Time Series Cross-Validation",
    "text": "Time Series Cross-Validation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnlike regular cross-validation, we NEVER use future data to predict the past!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#when-to-use-aiml-forecasting-i",
    "href": "lectures/lec_05_presentation.html#when-to-use-aiml-forecasting-i",
    "title": "Forecasting the Future",
    "section": "When to Use AI/ML Forecasting I",
    "text": "When to Use AI/ML Forecasting I\nUse AI when you have:\n\n\nSufficient historical data (2+ years)\nRich feature data (weather, promotions, events)\nNon-linear patterns\nResources for training/maintenance\n\n\n\nExamples:\n\nLarge retailers (Amazon, Walmart)\nDemand forecasting with many variables"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#when-to-use-aiml-forecasting-ii",
    "href": "lectures/lec_05_presentation.html#when-to-use-aiml-forecasting-ii",
    "title": "Forecasting the Future",
    "section": "When to Use AI/ML Forecasting II",
    "text": "When to Use AI/ML Forecasting II\nDon’t use AI when you have:\n\n\nLimited historical data\nHigh noise, low signal\nNeed explainable forecasts\nLimited expertise\n\n\n\nExamples:\n\nNew products (no history)\nRegulatory environments"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#forecast-horizons",
    "href": "lectures/lec_05_presentation.html#forecast-horizons",
    "title": "Forecasting the Future",
    "section": "Forecast Horizons",
    "text": "Forecast Horizons\nHow far into the future can we predict?"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#confidence-intervals",
    "href": "lectures/lec_05_presentation.html#confidence-intervals",
    "title": "Forecasting the Future",
    "section": "Confidence Intervals",
    "text": "Confidence Intervals\nA forecast without confidence intervals is incomplete!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#forecast-combination",
    "href": "lectures/lec_05_presentation.html#forecast-combination",
    "title": "Forecasting the Future",
    "section": "Forecast Combination",
    "text": "Forecast Combination\nWhy choose one method when you can combine several?\n\n\n# Example: Combining multiple forecasts\nma_forecast = 120      # Moving average prediction\nexp_forecast = 125     # Exponential smoothing prediction\nseasonal_forecast = 135 # Seasonal model prediction\n\n# Simple average (equal weights)\nsimple_combo = (ma_forecast + exp_forecast + seasonal_forecast) / 3\nprint(f\"Simple combination: {simple_combo:.0f} units\")\n\n# Weighted average (based on historical accuracy)\nweights = [0.3, 0.5, 0.2]  # Exp smoothing was most accurate historically\nweighted_combo = (ma_forecast * weights[0] +\n                  exp_forecast * weights[1] +\n                  seasonal_forecast * weights[2])\nprint(f\"Weighted combination: {weighted_combo:.0f} units\")\n\n\n\nSimple combination: 127 units\nWeighted combination: 126 units"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#lead-times-and-safety-stock",
    "href": "lectures/lec_05_presentation.html#lead-times-and-safety-stock",
    "title": "Forecasting the Future",
    "section": "Lead Times and Safety Stock",
    "text": "Lead Times and Safety Stock\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLong lead times = Forecasting further out = Less accuracy = More safety stock!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#safety-stock-calculation",
    "href": "lectures/lec_05_presentation.html#safety-stock-calculation",
    "title": "Forecasting the Future",
    "section": "Safety Stock Calculation",
    "text": "Safety Stock Calculation\nHow much buffer do you need?\n\n\n# Safety stock formula\nimport scipy.stats as stats\n\navg_weekly_demand = 300; std_weekly_demand = 40; lead_time_weeks = 3\nservice_level = 0.95  # Want 95% availability\n\n# Z-score for 95% service level\nz_score = stats.norm.ppf(service_level)\n\n# Safety stock calculation\nsafety_stock = z_score * std_weekly_demand * np.sqrt(lead_time_weeks)\nreorder_point = (avg_weekly_demand * lead_time_weeks) + safety_stock\n\nprint(f\"Average demand during lead time: {avg_weekly_demand * lead_time_weeks} units\")\nprint(f\"Safety stock needed: {safety_stock:.0f} units\")\nprint(f\"Reorder point: {reorder_point:.0f} units\")\n\n\n\nAverage demand during lead time: 900 units\nSafety stock needed: 114 units\nReorder point: 1014 units"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#today",
    "href": "lectures/lec_05_presentation.html#today",
    "title": "Forecasting the Future",
    "section": "Today",
    "text": "Today\n\n\nHour 2: This Lecture\n\nPatterns & decomposition\nSimple ES, Holt’s, Holt-Winters\nMethod selection\nPractical pandas\n\n\nHour 3: Notebook\n\nBean Counter CEO\nDaily and weekly aggregation\nImplement methods\nCompare accuracy\n\n\nHour 4: Competition\n\nMegaMart challenge\n3 real products\n4-week forecast\n€10K per error unit!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#the-competition-challenge",
    "href": "lectures/lec_05_presentation.html#the-competition-challenge",
    "title": "Forecasting the Future",
    "section": "The Competition Challenge",
    "text": "The Competition Challenge\n“The Christmas Predictor”\n\n\nAnalyze 2 years of weekly sales for 3 products\nIdentify patterns (trend, seasonality, volatility)\nForecast 4 December weeks for each product\nMinimize Mean Absolute Error across all 12 predictions"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#remember-this",
    "href": "lectures/lec_05_presentation.html#remember-this",
    "title": "Forecasting the Future",
    "section": "Remember This!",
    "text": "Remember This!\nThe Rules of Forecasting\n\nAlways plot first - Your eyes catch patterns algorithms miss\nStart simple - Complexity is not your friend\nRecent matters more - Weight recent data higher\nMatch method to pattern - Trend? Seasonality? Match!\nValidate on holdout - Never test on training data\nAdd confidence intervals - Uncertainty is information\nConsider business context - Cost of errors matters"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#final-thought",
    "href": "lectures/lec_05_presentation.html#final-thought",
    "title": "Forecasting the Future",
    "section": "Final Thought",
    "text": "Final Thought\nForecasting is both art and science\n\n\n\nThe Science:\n\nStatistical methods\nAI based forecasting\nError metrics (MAE, RMSE)\nConfidence intervals\nSystematic validation\n\n\nThe Art:\n\nChoosing the right method\nBalancing complexity vs simplicity\nInterpreting context\nCommunicating uncertainty\n\n\n\n\n\n\n\n\n\n\nMake better decisions, not perfect predictions!"
  },
  {
    "objectID": "lectures/lec_05_presentation.html#break",
    "href": "lectures/lec_05_presentation.html#break",
    "title": "Forecasting the Future",
    "section": "Break!",
    "text": "Break!\nTake 20 minutes, then we start the practice notebook\nNext up: You’ll become Bean Counter’s forecasting expert, preparing for seasonal demand!\nThen: The MegaMart Christmas Challenge!"
  },
  {
    "objectID": "lectures/lec_05_forecasting.html",
    "href": "lectures/lec_05_forecasting.html",
    "title": "Forecasting the Future",
    "section": "",
    "text": ". . .\nOperations Director’s Crisis:\n“Last Christmas, we ran out of PlayStation 5s but had 500 unsold fitness trackers. We lost €2M in missed sales and clearance losses. How do we predict what customers will actually buy?”\n\n\n\nQuestion: Why can’t we just order the same as last year?\n\n\nMarket: New products, competition\nSeasonal Shifts: Weather, holidays, economic conditions\nTrend Changes: Changing preferences, new technologies\nRandomness: Viral TikToks, supply chain disruptions, pandemics\n\n\n. . .\n\n\n\n\n\n\nReality: Large retailers process several thousand orders per hour. Each stockout basically means lost revenue + unhappy customers.\n\n\n\n\n\n\nLook at this daily sales data. What patterns do you see?",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#client-briefing-megamart-retail-chain",
    "href": "lectures/lec_05_forecasting.html#client-briefing-megamart-retail-chain",
    "title": "Forecasting the Future",
    "section": "",
    "text": ". . .\nOperations Director’s Crisis:\n“Last Christmas, we ran out of PlayStation 5s but had 500 unsold fitness trackers. We lost €2M in missed sales and clearance losses. How do we predict what customers will actually buy?”",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#business-the-unknown-future",
    "href": "lectures/lec_05_forecasting.html#business-the-unknown-future",
    "title": "Forecasting the Future",
    "section": "",
    "text": "Question: Why can’t we just order the same as last year?\n\n\nMarket: New products, competition\nSeasonal Shifts: Weather, holidays, economic conditions\nTrend Changes: Changing preferences, new technologies\nRandomness: Viral TikToks, supply chain disruptions, pandemics\n\n\n. . .\n\n\n\n\n\n\nReality: Large retailers process several thousand orders per hour. Each stockout basically means lost revenue + unhappy customers.",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#hidden-patterns-in-data",
    "href": "lectures/lec_05_forecasting.html#hidden-patterns-in-data",
    "title": "Forecasting the Future",
    "section": "",
    "text": "Look at this daily sales data. What patterns do you see?",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#decomposing-time-series",
    "href": "lectures/lec_05_forecasting.html#decomposing-time-series",
    "title": "Forecasting the Future",
    "section": "Decomposing Time Series",
    "text": "Decomposing Time Series\nTime series can often be decomposed:\n. . .\n\\[Y_t = T_t + S_t + R_t\\]\n. . .\nWhere:\n\n\\(Y_t\\) = Observed value at time t\n\\(T_t\\) = Trend component\n\\(S_t\\) = Seasonal component\n\\(R_t\\) = Random/Residual component",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#additive-vs-multiplicative-models",
    "href": "lectures/lec_05_forecasting.html#additive-vs-multiplicative-models",
    "title": "Forecasting the Future",
    "section": "Additive vs Multiplicative Models",
    "text": "Additive vs Multiplicative Models\nHow do the components combine?\n. . .\n\n\nAdditive Model \\[Y_t = T_t + S_t + R_t\\]\n\nSeasonal fluctuations are constant\n“We always sell 200 extra in December”\nGood: Stable, mature products\n\n\nMultiplicative Model \\[Y_t = T_t \\times S_t \\times R_t\\]\n\nSeasonal fluctuations scale with trend\n“December sales are 40% higher”\nGood: Growing businesses",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#visual-decomposition",
    "href": "lectures/lec_05_forecasting.html#visual-decomposition",
    "title": "Forecasting the Future",
    "section": "Visual Decomposition",
    "text": "Visual Decomposition\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nHere: Sales = Trend + Seasonality + Random Noise",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#moving-average",
    "href": "lectures/lec_05_forecasting.html#moving-average",
    "title": "Forecasting the Future",
    "section": "Moving Average",
    "text": "Moving Average\nQuestion: How do we separate signal from noise?\n. . .",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#simple-vs-weighted-averages",
    "href": "lectures/lec_05_forecasting.html#simple-vs-weighted-averages",
    "title": "Forecasting the Future",
    "section": "Simple vs Weighted Averages",
    "text": "Simple vs Weighted Averages\nWhich forecast would you trust more?\n. . .\n\n\nSimple Moving Average\n\nAll days equally important\nWe just take the average\n[14, 15, 16, 14, 15, 16, 17]\nForecast: 15.3\n\n\nWeighted Moving Average\n\nRecent days matter more\nDays closer are weighted more\n[0.05, 0.05, 0.1, 0.1, 0.2, 0.2, 0.3]\nForecast: 15.9\n\n\n\n. . .\n\n\n\n\n\n\nRecent data often predicts the future better than old data!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#simple-exponential-smoothing",
    "href": "lectures/lec_05_forecasting.html#simple-exponential-smoothing",
    "title": "Forecasting the Future",
    "section": "Simple Exponential Smoothing",
    "text": "Simple Exponential Smoothing\nNot too simple, not too complex\n. . .\n\\[\\text{Forecast}_{t+1} = \\alpha \\times \\text{Actual}_t + (1-\\alpha) \\times \\text{Forecast}_t\\]\n. . .\n\n\nα (alpha) = smoothing parameter (0 to 1)\nα = 0.9: Trust recent data (reactive)\nα = 0.1: Trust historical patterns (stable)\nα = 0.3: Balanced approach (common default)\n\n\n. . .\n\n\n\n\n\n\nThink of \\(\\alpha\\) like: How much do you trust the latest data point?",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#when-simple-smoothing-fails",
    "href": "lectures/lec_05_forecasting.html#when-simple-smoothing-fails",
    "title": "Forecasting the Future",
    "section": "When Simple Smoothing Fails",
    "text": "When Simple Smoothing Fails\nSimple smoothing assumes the data is flat. What if it’s not?",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holts-method-the-idea",
    "href": "lectures/lec_05_forecasting.html#holts-method-the-idea",
    "title": "Forecasting the Future",
    "section": "Holt’s Method: The Idea",
    "text": "Holt’s Method: The Idea\nTrack TWO things separately: Level and Trend\n\n\nLevel (L): Where are we right now? (like simple ES)\nTrend (b): How fast are we growing/declining per period?\nForecast: Combine both: Level + (Trend × periods ahead)\n\n\n. . .\nWhy This Works:\n\nSimple ES only tracks level (current position)\nHolt’s also tracks the slope (direction and speed)\n\n. . .\n\n\n\n\n\n\nThink of driving a car: Simple ES only knows your position. Holt’s also knows your speed!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holts-method-the-math-i",
    "href": "lectures/lec_05_forecasting.html#holts-method-the-math-i",
    "title": "Forecasting the Future",
    "section": "Holt’s Method: The Math I",
    "text": "Holt’s Method: The Math I\nThe formulas (simplified for intuition):\n. . .\nLevel Equation: \\[L_t = \\alpha \\times Y_t + (1-\\alpha) \\times (L_{t-1} + b_{t-1})\\]\nTrend Equation: \\[b_t = \\beta \\times (L_t - L_{t-1}) + (1-\\beta) \\times b_{t-1}\\]\nForecast Equation: \\[\\hat{Y}_{t+h} = L_t + h \\times b_t\\]",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holts-method-the-math-ii",
    "href": "lectures/lec_05_forecasting.html#holts-method-the-math-ii",
    "title": "Forecasting the Future",
    "section": "Holt’s Method: The Math II",
    "text": "Holt’s Method: The Math II\nIn plain English\n\nLevel: “Smooth current observation with previous forecast”\nTrend: “Smooth the change in level with our previous trend”\nForecast: “Start at current, add trend for each period ahead”\n\n. . .\n\n\n\n\n\n\nNot too complicated, right?",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#step-by-step-i",
    "href": "lectures/lec_05_forecasting.html#step-by-step-i",
    "title": "Forecasting the Future",
    "section": "Step-by-Step I",
    "text": "Step-by-Step I\nLet’s walk through 6 periods manually to build intuition\n\n# Sample data with clear upward trend\nsales_data = np.array([100, 105, 112, 118, 124, 130])\n\n# Parameters\nalpha = 0.3  # Level smoothing\nbeta = 0.2   # Trend smoothing\n\n# Initialize\nlevel = sales_data[0]  # Start at first observation\ntrend = sales_data[1] - sales_data[0]  # Initial trend estimate\n\nprint(f\"Period 1: Level={level:.1f}, Trend={trend:.1f}\")\n\n# Store level and trend history for visualization\nlevel_history = [level]\ntrend_history = [trend]\n\nPeriod 1: Level=100.0, Trend=5.0",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#step-by-step-ii",
    "href": "lectures/lec_05_forecasting.html#step-by-step-ii",
    "title": "Forecasting the Future",
    "section": "Step-by-Step II",
    "text": "Step-by-Step II\n\n# Apply Holt's method for periods 2-6\nfor t in range(1, len(sales_data)):\n    # Update level\n    prev_level = level\n    level = alpha * sales_data[t] + (1 - alpha) * (prev_level + trend)\n\n    # Update trend\n    trend = beta * (level - prev_level) + (1 - beta) * trend\n\n    # Store for visualization\n    level_history.append(level)\n    trend_history.append(trend)\n\n    print(f\"Period {t+1}: Sales={sales_data[t]}, Level={level:.1f}, Trend={trend:.1f}\")\n\nPeriod 2: Sales=105, Level=105.0, Trend=5.0\nPeriod 3: Sales=112, Level=110.6, Trend=5.1\nPeriod 4: Sales=118, Level=116.4, Trend=5.3\nPeriod 5: Sales=124, Level=122.4, Trend=5.4\nPeriod 6: Sales=130, Level=128.4, Trend=5.5",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#step-by-step-iii",
    "href": "lectures/lec_05_forecasting.html#step-by-step-iii",
    "title": "Forecasting the Future",
    "section": "Step-by-Step III",
    "text": "Step-by-Step III\n\n# Forecast next 3 periods\nprint(f\"\\nForecasts:\")\nforecast_values = []\nfor h in range(1, 4):\n    forecast = level + h * trend\n    forecast_values.append(forecast)\n    print(f\"  Period {len(sales_data)+h}: {forecast:.1f} units\")\n\n\nForecasts:\n  Period 7: 134.0 units\n  Period 8: 139.5 units\n  Period 9: 145.0 units",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holts-method-visual-comparison",
    "href": "lectures/lec_05_forecasting.html#holts-method-visual-comparison",
    "title": "Forecasting the Future",
    "section": "Holt’s Method: Visual Comparison",
    "text": "Holt’s Method: Visual Comparison",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#choosing-alpha-and-beta",
    "href": "lectures/lec_05_forecasting.html#choosing-alpha-and-beta",
    "title": "Forecasting the Future",
    "section": "Choosing Alpha and Beta",
    "text": "Choosing Alpha and Beta\nHow do you pick the right smoothing parameters?\n. . .\n\n\nAlpha (Level Smoothing)\n\nHigh α (0.7-0.9): Responsive\n\nUse: Volatile markets\n\nLow α (0.1-0.3): Stable\n\nUse: Steady business\n\n\n\nBeta (Trend Smoothing)\n\nHigh β (0.5-0.8): Quickly\n\nUse: Dynamic growth/decline\n\nLow β (0.1-0.3): Stable trend\n\nUse: Consistent growth\n\n\n\n\n. . .\nBest Practice: Let the algorithm optimize parameters automatically!\n. . .\n\n\n\n\n\n\nYou can implement Holt’s method using Python’s statsmodels library!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#when-to-use",
    "href": "lectures/lec_05_forecasting.html#when-to-use",
    "title": "Forecasting the Future",
    "section": "When to Use",
    "text": "When to Use\nQuestion: When should you use Holt’s method?\n. . .\n\nClear upward or downward trend\nNo seasonal patterns\n\n. . .\nQuestion: When should you use NOT Holt’s method?\n\nData is flat (use simple ES instead)\nStrong seasonality present\nTrend direction changes frequently",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#the-problem-trend-seasonality",
    "href": "lectures/lec_05_forecasting.html#the-problem-trend-seasonality",
    "title": "Forecasting the Future",
    "section": "The Problem: Trend + Seasonality",
    "text": "The Problem: Trend + Seasonality\nWhat if your data has BOTH trend AND seasonality?\n. . .",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holt-winters-three-components",
    "href": "lectures/lec_05_forecasting.html#holt-winters-three-components",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: Three Components",
    "text": "Holt-Winters: Three Components\nTrack THREE things separately: Level, Trend, AND Seasonality\n\n\nLevel (L): Current baseline demand (deseasonalized)\nTrend (b): Growth rate per period\nSeasonal Indices (s): Multipliers for each season",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holt-winters-visualized",
    "href": "lectures/lec_05_forecasting.html#holt-winters-visualized",
    "title": "Forecasting the Future",
    "section": "Holt-Winters Visualized",
    "text": "Holt-Winters Visualized",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#seasonality",
    "href": "lectures/lec_05_forecasting.html#seasonality",
    "title": "Forecasting the Future",
    "section": "Seasonality",
    "text": "Seasonality\nHow does seasonality combine with the level?\n. . .\n\n\nAdditive Model \\[Y_t = L_t + b_t + s_t\\]\n\nSeasonal variation is constant\n“We sell +50 units every December”\nPattern: ±constant amount\n\n\nMultiplicative Model \\[Y_t = L_t \\times b_t \\times s_t\\]\n\nSeasonal variation scales with level\n“December is 1.5× normal sales”\nPattern: ×percentage change",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holt-winters-the-math-i",
    "href": "lectures/lec_05_forecasting.html#holt-winters-the-math-i",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: The Math I",
    "text": "Holt-Winters: The Math I\nThe formulas (don’t panic - Python does this for you!)\n. . .\nAdditive Model:\n\\[L_t = \\alpha(Y_t - s_{t-m}) + (1-\\alpha)(L_{t-1} + b_{t-1})\\] \\[b_t = \\beta(L_t - L_{t-1}) + (1-\\beta)b_{t-1}\\] \\[s_t = \\gamma(Y_t - L_t) + (1-\\gamma)s_{t-m}\\] \\[\\hat{Y}_{t+h} = L_t + hb_t + s_{t+h-m}\\]",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holt-winters-the-math-ii",
    "href": "lectures/lec_05_forecasting.html#holt-winters-the-math-ii",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: The Math II",
    "text": "Holt-Winters: The Math II\nIn plain English\n\nLevel: Remove seasonality from observation, then smooth\nTrend: Same as Holt’s method\nSeasonal: Update the seasonal index for this period\nForecast: Level + trend + seasonal adjustment\n\n. . .\nParameters:\n\\(\\alpha\\) (level), \\(\\beta\\) (trend), \\(\\gamma\\) (seasonal), m (seasonal period length)",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holt-winters-intuition-i",
    "href": "lectures/lec_05_forecasting.html#holt-winters-intuition-i",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: Intuition I",
    "text": "Holt-Winters: Intuition I\nUnderstanding seasonal patterns with quarterly sales\n. . .\nQuarterly Sales Pattern:\n\nQ1: Low season (after holidays) → Factor: 0.85\nQ2: Spring pickup → Factor: 0.95\nQ3: Summer growth → Factor: 1.05\nQ4: Holiday peak! → Factor: 1.15",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holt-winters-intuition-i-1",
    "href": "lectures/lec_05_forecasting.html#holt-winters-intuition-i-1",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: Intuition I",
    "text": "Holt-Winters: Intuition I\nHow Holt-Winters Works\n\nDeseasonalize the data (remove seasonal effect)\nCalculate trend from deseasonalized data\nUpdate seasonal indices based on actual vs. expected\nForecast by combining level + trend + seasonal pattern\n\n. . .\n\n\n\n\n\n\nQ4 is typically 35% higher than Q1 in retail! Holt-Winters captures this automatically.",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#holt-winters-visual",
    "href": "lectures/lec_05_forecasting.html#holt-winters-visual",
    "title": "Forecasting the Future",
    "section": "Holt-Winters: Visual",
    "text": "Holt-Winters: Visual\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nNotice how the forecast continues the seasonal pattern while following the trend!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#when-to-use-holt-winters",
    "href": "lectures/lec_05_forecasting.html#when-to-use-holt-winters",
    "title": "Forecasting the Future",
    "section": "When to Use Holt-Winters",
    "text": "When to Use Holt-Winters\nQuestion: When should you use Holt-Winters method?\n. . .\n\nData with trend AND seasonality\nAt least 1 full seasonal cycle (2 are better!)\nRegular, repeating patterns\n\n. . .\nQuestion: When should you AVOID Holt-Winters method?\n. . .\n\nIrregular or changing seasonal patterns\nFlat data with no trend\nSeasonal pattern length unknown",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#measuring-forecast-accuracy",
    "href": "lectures/lec_05_forecasting.html#measuring-forecast-accuracy",
    "title": "Forecasting the Future",
    "section": "Measuring Forecast Accuracy",
    "text": "Measuring Forecast Accuracy\nHow wrong were we?\n. . .\nMean Absolute Error (MAE): Average size of mistakes \\[\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |Actual_i - Forecast_i|\\]\n. . .\nRoot Mean Squared Error (RMSE): Penalizes large errors more \\[\\text{RMSE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (Actual_i - Forecast_i)^2}\\]",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#forecast-accuracy",
    "href": "lectures/lec_05_forecasting.html#forecast-accuracy",
    "title": "Forecasting the Future",
    "section": "Forecast Accuracy",
    "text": "Forecast Accuracy\nEasy with Python\n\n# Example: Compare two forecasting methods\nactual = np.array([100, 105, 110, 108, 112])\nforecast_a = np.array([98, 107, 109, 110, 111])\nforecast_b = np.array([102, 103, 112, 106, 113])\n\nmae_a = np.mean(np.abs(actual - forecast_a))\nmae_b = np.mean(np.abs(actual - forecast_b))\n\nprint(f\"Method A - MAE: {mae_a:.2f} units\")\nprint(f\"Method B - MAE: {mae_b:.2f} units\")\nprint(f\"\\nBetter method: {'A' if mae_a &lt; mae_b else 'B'}\")\n\nMethod A - MAE: 1.60 units\nMethod B - MAE: 1.80 units\n\nBetter method: A",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#when-to-use-which-method",
    "href": "lectures/lec_05_forecasting.html#when-to-use-which-method",
    "title": "Forecasting the Future",
    "section": "When to Use Which Method?",
    "text": "When to Use Which Method?\n. . .\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nStart simple: Try moving average first as baseline, then add complexity only if needed!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#the-real-cost-of-being-wrong",
    "href": "lectures/lec_05_forecasting.html#the-real-cost-of-being-wrong",
    "title": "Forecasting the Future",
    "section": "The Real Cost of Being Wrong",
    "text": "The Real Cost of Being Wrong\nNot all forecast errors are equal!\n. . .\nExample: Winter Coats\n\nCost: €50, Selling Price: €150, Margin: €100\nStorage cost: €5/month\nClearance markdown: 70% off\n\n. . .\nQuestion: What is your intuition here?",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#under-and-overforecasting",
    "href": "lectures/lec_05_forecasting.html#under-and-overforecasting",
    "title": "Forecasting the Future",
    "section": "Under and Overforecasting",
    "text": "Under and Overforecasting\nSometimes it’s cheaper to overstock than to miss sales!\n. . .\n\n\nUnderforecast by 100 units:\n\nLost profit: 100 × €100\n\n€10,000\n\nCustomer disappointment\nCompetitor gains market share\n\n\nOverforecast by 100 units:\n\nStorage: 100 × €5 × 3 months\n\n€1,500\n\nClearance loss: 100 × €70\n\n€7,000\n\n\n\n\n. . .\n\n\n\n\n\n\nThe “best” forecast depends on your business context.",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#your-python-practice-notebook",
    "href": "lectures/lec_05_forecasting.html#your-python-practice-notebook",
    "title": "Forecasting the Future",
    "section": "Your Python Practice Notebook",
    "text": "Your Python Practice Notebook\nAll the hands-on coding happens in the interactive tutorial!\n. . .\n\n\nWorking with dates in Pandas\nImplementing moving averages\nBuilding forecast functions\nApplying Holt’s method\nUsing Holt-Winters\nMeasuring accuracy\n\n\n. . .\n\n\n\n\n\n\nThe notebook guides you step-by-step through Bean Counter’s seasonal demand forecasting challenge!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#the-promise-of-ai",
    "href": "lectures/lec_05_forecasting.html#the-promise-of-ai",
    "title": "Forecasting the Future",
    "section": "The Promise of AI",
    "text": "The Promise of AI\nCan machines predict better than classical methods?\nWhat AI/ML brings to forecasting:\n\n\nHandle hundreds of variables simultaneously\nDetect complex non-linear patterns\nLearn from massive datasets\nAdapt automatically to changes\n\n\n. . .\n\n\n\n\n\n\nAI doesn’t replace human judgment, it augments it when you have enough data!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#common-aiml-forecasting",
    "href": "lectures/lec_05_forecasting.html#common-aiml-forecasting",
    "title": "Forecasting the Future",
    "section": "Common AI/ML Forecasting",
    "text": "Common AI/ML Forecasting\nOverview of popular techniques\n. . .\n\n\nTraditional ML:\n\nRandom Forest: Ensemble of decision trees\nXGBoost: Gradient boosting (very popular)\nSupport Vector Machines: Pattern recognition\n\n\nDeep Learning:\n\nLSTM (Long Short-Term Memory): For sequences\nProphet (Facebook): Automated forecasting\nNeural Networks: Complex patterns\n\n\n\n. . .\n\n\n\n\n\n\nMore complex ≠ Better! Simple methods often win in forecasting.",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#the-issue-overfitting",
    "href": "lectures/lec_05_forecasting.html#the-issue-overfitting",
    "title": "Forecasting the Future",
    "section": "The Issue: Overfitting",
    "text": "The Issue: Overfitting\nQuestion: What happens when we train an AI on all our data and use it to predict… the same data?\n. . .",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#training-vs-test-data",
    "href": "lectures/lec_05_forecasting.html#training-vs-test-data",
    "title": "Forecasting the Future",
    "section": "Training vs Test Data",
    "text": "Training vs Test Data\nNever judge a complex model on the data it learned from!\n\n\n\n\n\n\n\n\n\n\n\nTraining Data: Where the model learns patterns (70-80%)\nValidation Data: Where you tune hyperparameters (10-15%)\nTest Data: The “future”, only once for final evaluation (10-15%)",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#data-leakage-the-silent-problem",
    "href": "lectures/lec_05_forecasting.html#data-leakage-the-silent-problem",
    "title": "Forecasting the Future",
    "section": "Data Leakage: The Silent Problem",
    "text": "Data Leakage: The Silent Problem\nWhen future information sneaks into your training data\n. . .\n\n\nTarget leakage\n\nWrong: Including “total_sales” when predicting “monthly_sales”\nRight: Only use information available at prediction time\n\nTemporal leakage\n\nWrong: Random split for time series (mixes past and future)\nRight: Always split chronologically\n\n\n\n. . .\n\n\n\n\n\n\nData leakage can make a terrible model look amazing… until it fails in production!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#time-series-cross-validation",
    "href": "lectures/lec_05_forecasting.html#time-series-cross-validation",
    "title": "Forecasting the Future",
    "section": "Time Series Cross-Validation",
    "text": "Time Series Cross-Validation\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nUnlike regular cross-validation, we NEVER use future data to predict the past!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#when-to-use-aiml-forecasting-i",
    "href": "lectures/lec_05_forecasting.html#when-to-use-aiml-forecasting-i",
    "title": "Forecasting the Future",
    "section": "When to Use AI/ML Forecasting I",
    "text": "When to Use AI/ML Forecasting I\nUse AI when you have:\n. . .\n\nSufficient historical data (2+ years)\nRich feature data (weather, promotions, events)\nNon-linear patterns\nResources for training/maintenance\n\n. . .\nExamples:\n\nLarge retailers (Amazon, Walmart)\nDemand forecasting with many variables",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#when-to-use-aiml-forecasting-ii",
    "href": "lectures/lec_05_forecasting.html#when-to-use-aiml-forecasting-ii",
    "title": "Forecasting the Future",
    "section": "When to Use AI/ML Forecasting II",
    "text": "When to Use AI/ML Forecasting II\nDon’t use AI when you have:\n. . .\n\nLimited historical data\nHigh noise, low signal\nNeed explainable forecasts\nLimited expertise\n\n. . .\nExamples:\n\nNew products (no history)\nRegulatory environments",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#forecast-horizons",
    "href": "lectures/lec_05_forecasting.html#forecast-horizons",
    "title": "Forecasting the Future",
    "section": "Forecast Horizons",
    "text": "Forecast Horizons\nHow far into the future can we predict?",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#confidence-intervals",
    "href": "lectures/lec_05_forecasting.html#confidence-intervals",
    "title": "Forecasting the Future",
    "section": "Confidence Intervals",
    "text": "Confidence Intervals\nA forecast without confidence intervals is incomplete!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#forecast-combination",
    "href": "lectures/lec_05_forecasting.html#forecast-combination",
    "title": "Forecasting the Future",
    "section": "Forecast Combination",
    "text": "Forecast Combination\nWhy choose one method when you can combine several?\n. . .\n\n# Example: Combining multiple forecasts\nma_forecast = 120      # Moving average prediction\nexp_forecast = 125     # Exponential smoothing prediction\nseasonal_forecast = 135 # Seasonal model prediction\n\n# Simple average (equal weights)\nsimple_combo = (ma_forecast + exp_forecast + seasonal_forecast) / 3\nprint(f\"Simple combination: {simple_combo:.0f} units\")\n\n# Weighted average (based on historical accuracy)\nweights = [0.3, 0.5, 0.2]  # Exp smoothing was most accurate historically\nweighted_combo = (ma_forecast * weights[0] +\n                  exp_forecast * weights[1] +\n                  seasonal_forecast * weights[2])\nprint(f\"Weighted combination: {weighted_combo:.0f} units\")\n\nSimple combination: 127 units\nWeighted combination: 126 units",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#lead-times-and-safety-stock",
    "href": "lectures/lec_05_forecasting.html#lead-times-and-safety-stock",
    "title": "Forecasting the Future",
    "section": "Lead Times and Safety Stock",
    "text": "Lead Times and Safety Stock\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nLong lead times = Forecasting further out = Less accuracy = More safety stock!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#safety-stock-calculation",
    "href": "lectures/lec_05_forecasting.html#safety-stock-calculation",
    "title": "Forecasting the Future",
    "section": "Safety Stock Calculation",
    "text": "Safety Stock Calculation\nHow much buffer do you need?\n. . .\n\n# Safety stock formula\nimport scipy.stats as stats\n\navg_weekly_demand = 300; std_weekly_demand = 40; lead_time_weeks = 3\nservice_level = 0.95  # Want 95% availability\n\n# Z-score for 95% service level\nz_score = stats.norm.ppf(service_level)\n\n# Safety stock calculation\nsafety_stock = z_score * std_weekly_demand * np.sqrt(lead_time_weeks)\nreorder_point = (avg_weekly_demand * lead_time_weeks) + safety_stock\n\nprint(f\"Average demand during lead time: {avg_weekly_demand * lead_time_weeks} units\")\nprint(f\"Safety stock needed: {safety_stock:.0f} units\")\nprint(f\"Reorder point: {reorder_point:.0f} units\")\n\nAverage demand during lead time: 900 units\nSafety stock needed: 114 units\nReorder point: 1014 units",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#today",
    "href": "lectures/lec_05_forecasting.html#today",
    "title": "Forecasting the Future",
    "section": "Today",
    "text": "Today\n\n\nHour 2: This Lecture\n\nPatterns & decomposition\nSimple ES, Holt’s, Holt-Winters\nMethod selection\nPractical pandas\n\n\nHour 3: Notebook\n\nBean Counter CEO\nDaily and weekly aggregation\nImplement methods\nCompare accuracy\n\n\nHour 4: Competition\n\nMegaMart challenge\n3 real products\n4-week forecast\n€10K per error unit!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#the-competition-challenge",
    "href": "lectures/lec_05_forecasting.html#the-competition-challenge",
    "title": "Forecasting the Future",
    "section": "The Competition Challenge",
    "text": "The Competition Challenge\n“The Christmas Predictor”\n. . .\n\nAnalyze 2 years of weekly sales for 3 products\nIdentify patterns (trend, seasonality, volatility)\nForecast 4 December weeks for each product\nMinimize Mean Absolute Error across all 12 predictions",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#remember-this",
    "href": "lectures/lec_05_forecasting.html#remember-this",
    "title": "Forecasting the Future",
    "section": "Remember This!",
    "text": "Remember This!\nThe Rules of Forecasting\n\n\nAlways plot first - Your eyes catch patterns algorithms miss\nStart simple - Complexity is not your friend\nRecent matters more - Weight recent data higher\nMatch method to pattern - Trend? Seasonality? Match!\nValidate on holdout - Never test on training data\nAdd confidence intervals - Uncertainty is information\nConsider business context - Cost of errors matters",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#final-thought",
    "href": "lectures/lec_05_forecasting.html#final-thought",
    "title": "Forecasting the Future",
    "section": "Final Thought",
    "text": "Final Thought\nForecasting is both art and science\n. . .\n\n\nThe Science:\n\nStatistical methods\nAI based forecasting\nError metrics (MAE, RMSE)\nConfidence intervals\nSystematic validation\n\n\nThe Art:\n\nChoosing the right method\nBalancing complexity vs simplicity\nInterpreting context\nCommunicating uncertainty\n\n\n\n. . .\n\n\n\n\n\n\nMake better decisions, not perfect predictions!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_05_forecasting.html#break",
    "href": "lectures/lec_05_forecasting.html#break",
    "title": "Forecasting the Future",
    "section": "Break!",
    "text": "Break!\nTake 20 minutes, then we start the practice notebook\nNext up: You’ll become Bean Counter’s forecasting expert, preparing for seasonal demand!\nThen: The MegaMart Christmas Challenge!",
    "crumbs": [
      "05 Forecasting",
      "05 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_03_presentation.html#context-engineering",
    "href": "lectures/lec_03_presentation.html#context-engineering",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Context Engineering",
    "text": "Context Engineering\nWrite clear descriptions of what you want:\n# Create subplot with 2 rows, 1 column\n# Top: line plot of revenue over time\n# Bottom: bar chart of profit by quarter\n\n\n\n\n\n\n\n\nBe specific in your instructions\nReview generated code\nTest the code as it might use old syntax\nIterate for better results\nForce To-Tos so everything is completed"
  },
  {
    "objectID": "lectures/lec_03_presentation.html#watch-out-for",
    "href": "lectures/lec_03_presentation.html#watch-out-for",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Watch Out For",
    "text": "Watch Out For\n\nDeprecated methods: plt.subplot() vs plt.subplots()\nMissing imports: Always verify imports are included\nWrong assumptions: Might guess your data structure incorrectly\nOver-complexity: Very often suggests unnecessary features\n\n\nRemember: Generative AI is stochastic!"
  },
  {
    "objectID": "lectures/lec_03_presentation.html#foundation-complete",
    "href": "lectures/lec_03_presentation.html#foundation-complete",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Foundation Complete!",
    "text": "Foundation Complete!\nWhy This Matters?\n\nYou now have a good foundation for data-driven decisions!"
  },
  {
    "objectID": "lectures/lec_03_presentation.html#preview-4---monte-carlo",
    "href": "lectures/lec_03_presentation.html#preview-4---monte-carlo",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Preview: 4 - Monte Carlo",
    "text": "Preview: 4 - Monte Carlo\nNext Session: Modeling Business Uncertainty\n\nWe’ll combine everything you’ve learned:\n\nNumPy for random number generation\nVisualization for showing probability distributions\n\n\n\nReal applications:\n\nPredict project completion times\nEstimate financial risks\nMake decisions under uncertainty"
  },
  {
    "objectID": "lectures/lec_03_presentation.html#the-end",
    "href": "lectures/lec_03_presentation.html#the-end",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "The End",
    "text": "The End\nThat’s it for today! Make sure you:\n\nHave completed all the notebooks\nCheck whether you could follow so far\nSet up Copilot\n\n\n\n\n\n\n\n\nEvery line of code you write makes you a better programmer. Every concept you understand makes you a better decision-maker. Keep practicing and keep learning!"
  },
  {
    "objectID": "lectures/lec_03_presentation.html#interesting-literature-on-algorithms",
    "href": "lectures/lec_03_presentation.html#interesting-literature-on-algorithms",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Interesting Literature on Algorithms",
    "text": "Interesting Literature on Algorithms\n\nChristian, B., & Griffiths, T. (2016). Algorithms to live by: the computer science of human decisions. First international edition. New York, Henry Holt and Company.1\nFerguson, T.S. (1989) ‘Who solved the secretary problem?’, Statistical Science, 4(3). doi:10.1214/ss/1177012493.\n\nA great inspiration to learn more about Algorithms!"
  },
  {
    "objectID": "lectures/lec_03_presentation.html#books-on-programming",
    "href": "lectures/lec_03_presentation.html#books-on-programming",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Books on Programming",
    "text": "Books on Programming\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly. Here\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\n\n\n\n\n\n\n\nThink Python is a great book to start with. It’s available online for free. Schrödinger Programmiert Python is a great alternative for German students, as it is a very playful introduction to programming with lots of examples."
  },
  {
    "objectID": "lectures/lec_03_presentation.html#more-literature",
    "href": "lectures/lec_03_presentation.html#more-literature",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "More Literature",
    "text": "More Literature\nFor more interesting literature, take a look at the literature list of this course."
  },
  {
    "objectID": "lectures/lec_03_closing.html",
    "href": "lectures/lec_03_closing.html",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "",
    "text": "Write clear descriptions of what you want:\n# Create subplot with 2 rows, 1 column\n# Top: line plot of revenue over time\n# Bottom: bar chart of profit by quarter\n. . .\n\n\n\n\n\n\n\nBe specific in your instructions\nReview generated code\nTest the code as it might use old syntax\nIterate for better results\nForce To-Tos so everything is completed\n\n\n\n\n\n\n\n\nDeprecated methods: plt.subplot() vs plt.subplots()\nMissing imports: Always verify imports are included\nWrong assumptions: Might guess your data structure incorrectly\nOver-complexity: Very often suggests unnecessary features\n\n. . .\nRemember: Generative AI is stochastic!",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#context-engineering",
    "href": "lectures/lec_03_closing.html#context-engineering",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "",
    "text": "Write clear descriptions of what you want:\n# Create subplot with 2 rows, 1 column\n# Top: line plot of revenue over time\n# Bottom: bar chart of profit by quarter\n. . .\n\n\n\n\n\n\n\nBe specific in your instructions\nReview generated code\nTest the code as it might use old syntax\nIterate for better results\nForce To-Tos so everything is completed",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#watch-out-for",
    "href": "lectures/lec_03_closing.html#watch-out-for",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "",
    "text": "Deprecated methods: plt.subplot() vs plt.subplots()\nMissing imports: Always verify imports are included\nWrong assumptions: Might guess your data structure incorrectly\nOver-complexity: Very often suggests unnecessary features\n\n. . .\nRemember: Generative AI is stochastic!",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#foundation-complete",
    "href": "lectures/lec_03_closing.html#foundation-complete",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Foundation Complete!",
    "text": "Foundation Complete!\nWhy This Matters?\n. . .\nYou now have a good foundation for data-driven decisions!",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#preview-4---monte-carlo",
    "href": "lectures/lec_03_closing.html#preview-4---monte-carlo",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Preview: 4 - Monte Carlo",
    "text": "Preview: 4 - Monte Carlo\nNext Session: Modeling Business Uncertainty\n. . .\nWe’ll combine everything you’ve learned:\n\nNumPy for random number generation\nVisualization for showing probability distributions\n\n. . .\nReal applications:\n\nPredict project completion times\nEstimate financial risks\nMake decisions under uncertainty",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#the-end",
    "href": "lectures/lec_03_closing.html#the-end",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "The End",
    "text": "The End\nThat’s it for today! Make sure you:\n\nHave completed all the notebooks\nCheck whether you could follow so far\nSet up Copilot\n\n. . .\n\n\n\n\n\n\nEvery line of code you write makes you a better programmer. Every concept you understand makes you a better decision-maker. Keep practicing and keep learning!",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#interesting-literature-on-algorithms",
    "href": "lectures/lec_03_closing.html#interesting-literature-on-algorithms",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Interesting Literature on Algorithms",
    "text": "Interesting Literature on Algorithms\n\nChristian, B., & Griffiths, T. (2016). Algorithms to live by: the computer science of human decisions. First international edition. New York, Henry Holt and Company.1\nFerguson, T.S. (1989) ‘Who solved the secretary problem?’, Statistical Science, 4(3). doi:10.1214/ss/1177012493.",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#books-on-programming",
    "href": "lectures/lec_03_closing.html#books-on-programming",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Books on Programming",
    "text": "Books on Programming\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly. Here\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\n. . .\n\n\n\n\n\n\nThink Python is a great book to start with. It’s available online for free. Schrödinger Programmiert Python is a great alternative for German students, as it is a very playful introduction to programming with lots of examples.",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#more-literature",
    "href": "lectures/lec_03_closing.html#more-literature",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "More Literature",
    "text": "More Literature\nFor more interesting literature, take a look at the literature list of this course.",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_03_closing.html#footnotes",
    "href": "lectures/lec_03_closing.html#footnotes",
    "title": "Lecture 3 - Recap & Copilot Strategy",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nA great inspiration to learn more about Algorithms!↩︎",
    "crumbs": [
      "03 Foundation",
      "03 Closing"
    ]
  },
  {
    "objectID": "lectures/lec_01_presentation.html#about-me",
    "href": "lectures/lec_01_presentation.html#about-me",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "About me",
    "text": "About me\n\nField: Optimizing and simulating complex systems\nLanguages: of choice: Julia, Python and Rust\nInterest: Modelling, Simulations, Machine Learning\nTeaching: OR, Algorithms, and Programming\nContact: vlcek@beyondsimulations.com\n\n\n\n\n\n\n\n\nI really appreciate active participation and interaction!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#section",
    "href": "lectures/lec_01_presentation.html#section",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "What is\nManagement\nScience?\n\n\nPhoto by Patrick Konior on Unsplash"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#management-science",
    "href": "lectures/lec_01_presentation.html#management-science",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Management Science",
    "text": "Management Science\nManagement science is an interdisciplinary field that applies research-based methods, such as modeling, statistics, and algorithms, to solve complex organizational problems and guide strategic decisions, seeking optimal or near‑optimal outcomes across institutions, corporations, and governments.1\n\nIt is not the science of management!\n\nAn Introduction to Management Science: Quantitative Approaches to Decision Making (15 ed.). Boston: Cengage Learning, Inc. 2019. ISBN 978-1-337-40652-9."
  },
  {
    "objectID": "lectures/lec_01_presentation.html#course-outline",
    "href": "lectures/lec_01_presentation.html#course-outline",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Course Outline",
    "text": "Course Outline\n\nPart I: Python Foundation (Lectures 1-3)\n\nVariables, loops, functions, data science tools\n\nPart II: Management Science Tools (Lectures 4-9)\n\nMonte Carlo, Scheduling, Routing, Metaheuristics\n\nPart III: Consulting Competition (Lectures 10-12)\n\nClient briefings, development, final presentations\n\n\n\n\n\n\n\n\n\nYou’re now consultants learning to solve real business problems!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#from-amazon-to-hospitals",
    "href": "lectures/lec_01_presentation.html#from-amazon-to-hospitals",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "From Amazon to Hospitals",
    "text": "From Amazon to Hospitals\nWhere Algorithms Make Millions\n\nAmazon: Routing algorithms save millions in delivery costs\nUber: Real-time matching algorithms connect drivers and riders\nHospitals: Scheduling algorithms optimize shifts and OR usage\nAirlines: Revenue algorithms price tickets dynamically\nManufacturing: Production scheduling reduces waste and delays\n\n\nManagement Science is everywhere!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#this-course-approach",
    "href": "lectures/lec_01_presentation.html#this-course-approach",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "This Course Approach",
    "text": "This Course Approach\nThe Consultant Mindset\n\nYou’ll work on business problems\nLearn to communicate solutions to non-technical clients\nBuild practical tools that solve actual challenges\nCompete in a consulting competition with real scenarios\n\n\n\n\n\n\n\n\nThink like a consultant: What value does my solution bring to the business?"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#course-structure",
    "href": "lectures/lec_01_presentation.html#course-structure",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Course Structure",
    "text": "Course Structure\n\n12 lectures of intensive learning\n3 hours per lecture (with breaks!)\nInteractive format:\n\nConcepts & Setup\nHands-on Python notebooks\nConsulting Competition\n\nFinal competition: Apply everything you’ve learned\n\n\nEach lecture builds on the previous - attendance is important!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#grading",
    "href": "lectures/lec_01_presentation.html#grading",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Grading",
    "text": "Grading\nGrade Composition:\n\nCourse has 100 points, 50 needed to pass\n2 Assignments: 30 points each\nFinal Consulting Project: 40 points\n\n\n\n\n\n\n\n\nWe will have several competitions including our final competition, where you will have the chance to earn bonus points!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#assignments",
    "href": "lectures/lec_01_presentation.html#assignments",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Assignments",
    "text": "Assignments\nAssignment Strategy:\n\nStart with easy warm-ups in tutorials\nProgress to real-world problems\nAll assignments have clear rubrics\nBonus points for creative solutions!\n\n\n\n\n\n\n\n\nLate submissions: -10% per day (max 3 days)"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#learning-python",
    "href": "lectures/lec_01_presentation.html#learning-python",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Learning Python",
    "text": "Learning Python\n\nIn my experience, the best way to learn is by doing!\nHere, we will focus on decision algorithms\nYou will start to learn Python by doing the tutorials\n\n\n\n\n\n\n\n\nDon’t worry, I will help you out if you have any questions!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#what-to-expect",
    "href": "lectures/lec_01_presentation.html#what-to-expect",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "What to Expect",
    "text": "What to Expect\n\nNo prior programming required - we start from zero!\nBut experience is helpful!\nFast-paced but with lots of support\nPractical focus - less theory, more doing\nMistakes are welcome - they’re how we learn\n\n\n\n\n\n\n\n\nThe course gets easier after week 3 - the hardest part is getting started!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#course-goals",
    "href": "lectures/lec_01_presentation.html#course-goals",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Course Goals",
    "text": "Course Goals\nBy the end, you will be able to:\n\nWrite Python code to solve business problems\nApply algorithms for scheduling, routing, and optimization\nSimulate uncertainty using Monte Carlo methods\nPresent solutions like a management consultant\nBuild tools that create business value\n\n\nYou’ll leave with a portfolio of ideas to work on real solutions!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#why-python",
    "href": "lectures/lec_01_presentation.html#why-python",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Why Python?",
    "text": "Why Python?\n\nOrigins: Conceived in late 1980s as a teaching and scripting language\nSimple Syntax: Python’s syntax is mostly straightforward and very easy to learn\nVersatility: Used in web development, data analysis, artificial intelligence, and more\nCommunity Support: A large community of users worldwide and extensive documentation"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#help-from-ai",
    "href": "lectures/lec_01_presentation.html#help-from-ai",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Help from AI",
    "text": "Help from AI\n\nYou are allowed to use AI in the course\nI use it as well (e.g., Claude, ChatGPT, Gemini, …)\nThese tools are great for learning Python!\nCan help you a lot to get started with programming\nI will also teach you how to use it effectively\n\n\n\n\n\n\n\n\nBut you should not simply use them to replace your learning."
  },
  {
    "objectID": "lectures/lec_01_presentation.html#my-recommendation",
    "href": "lectures/lec_01_presentation.html#my-recommendation",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "My Recommendation",
    "text": "My Recommendation\n\nBe present: Attend the lecture and solve the tutorials\nPut in work: Repeat code and try to understand it\nDo coding: Run code, play around, modify, and solve\nCompete: Participate in the competitions to learn\n\n\n\n\n\n\n\n\nGreat resources to start are books and small challenges. You can find a list of recommendations in the literature recommendations."
  },
  {
    "objectID": "lectures/lec_01_presentation.html#dont-give-up",
    "href": "lectures/lec_01_presentation.html#dont-give-up",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Don’t give up!",
    "text": "Don’t give up!\nProgramming is like learning to ride a bike\n\n\nYou’ll fall a few times\nIt feels impossible at first\nThen suddenly… it clicks!\n\n\n\n\n\n\n\n\n\nLectures 1-3 are the hardest. Push through and it gets much easier!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#what-is-an-ide",
    "href": "lectures/lec_01_presentation.html#what-is-an-ide",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "What is an IDE?",
    "text": "What is an IDE?\n\nIntegrated Development Environment = application\nIt allows you to write, run and debug code scripts\nOther IDEs include for example:\n\nPyCharm from JetBrains\nZed"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#install-vs-code",
    "href": "lectures/lec_01_presentation.html#install-vs-code",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Install VS Code",
    "text": "Install VS Code\n\nDownload and install from the website\nBuilt for Windows, Linux and Mac\nInstall the Python and Jupyter extension\nGreat! First steps are done\n\n\n\n\n\n\n\n\nUnsure on how to work with VS Code and notebooks? Ask me! I’m happy to help you out!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#installation-of-python-with-uv",
    "href": "lectures/lec_01_presentation.html#installation-of-python-with-uv",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Installation of Python with uv",
    "text": "Installation of Python with uv\n\nWe will use uv to install and manage Python versions\nIt works on Windows, Mac and Linux\nIt helps us to manage packages and virtual environments\nNow, we all go here and install uv and Python\n\n\n\n\n\n\n\n\nIf the installation does not work, let me know!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#quick-check",
    "href": "lectures/lec_01_presentation.html#quick-check",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Quick Check",
    "text": "Quick Check\n\nHave you installed uv and initialized the project?\nGreat! Before we continue, check the following:\n\nYou have a folder for the course\nYou have initialized uv with uv init inside the folder\nYou can see a file called pyproject.toml in the folder\n\n\n\n\n\n\n\n\n\nSomething not working yet? Ask me!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#using-notebooks",
    "href": "lectures/lec_01_presentation.html#using-notebooks",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Using Notebooks",
    "text": "Using Notebooks\n\nNow we need to add a kernel to our project\nRun uv add --dev ipykernel from your terminal\nNow run uv add jupyter in the terminal\nThis allows us to use uv Python in notebooks\nDone? Perfect. Now we can start!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#working-with-notebooks",
    "href": "lectures/lec_01_presentation.html#working-with-notebooks",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Working with Notebooks",
    "text": "Working with Notebooks\n\nNow you can download the files from the website\nJust click on one of the sessions and open it\nSelect Jupyter on the right side\nDownload and save the files to your course folder\nOpen them and select “Open with Jupyter Notebook”\n\n\n\n\n\n\n\n\nThat was the hardest part today!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#section-1",
    "href": "lectures/lec_01_presentation.html#section-1",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Any questions\nso far?"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#whats-next",
    "href": "lectures/lec_01_presentation.html#whats-next",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "What’s Next?",
    "text": "What’s Next?\nAfter the break, we’ll dive into:\n\nTutorial 1: Variables and basic data types\nTutorial 2: Lists and loops\nTutorial 3: Conditionals and control flow\n\n\n\n\n\n\n\n\nReady for the tutorials? Make sure your Jupyter notebook is working before we continue!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#the-end",
    "href": "lectures/lec_01_presentation.html#the-end",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "The End",
    "text": "The End\nThat’s it for our introduction!\nMake sure you have:\n\nVS Code installed and running\nPython environment set up with uv\nJupyter notebooks working\nThe tutorial files downloaded\n\n\n\n\n\n\n\n\nTake a 10-minute break, then we’ll start with the interactive notebooks."
  },
  {
    "objectID": "lectures/lec_01_presentation.html#interesting-literature-on-algorithms",
    "href": "lectures/lec_01_presentation.html#interesting-literature-on-algorithms",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Interesting Literature on Algorithms",
    "text": "Interesting Literature on Algorithms\n\nChristian, B., & Griffiths, T. (2016). Algorithms to live by: the computer science of human decisions. First international edition. New York, Henry Holt and Company.1\nFerguson, T.S. (1989) ‘Who solved the secretary problem?’, Statistical Science, 4(3). doi:10.1214/ss/1177012493.\n\nA great inspiration to learn more about Algorithms!"
  },
  {
    "objectID": "lectures/lec_01_presentation.html#books-on-programming",
    "href": "lectures/lec_01_presentation.html#books-on-programming",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Books on Programming",
    "text": "Books on Programming\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly. Here\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\n\n\n\n\n\n\n\nThink Python is a great book to start with. It’s available online for free. Schrödinger Programmiert Python is a great alternative for German students, as it is a very playful introduction to programming with lots of examples."
  },
  {
    "objectID": "lectures/lec_01_presentation.html#more-literature",
    "href": "lectures/lec_01_presentation.html#more-literature",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "More Literature",
    "text": "More Literature\nFor more interesting literature, take a look at the literature list of this course."
  },
  {
    "objectID": "lectures/lec_01_introduction.html",
    "href": "lectures/lec_01_introduction.html",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Field: Optimizing and simulating complex systems\nLanguages: of choice: Julia, Python and Rust\nInterest: Modelling, Simulations, Machine Learning\nTeaching: OR, Algorithms, and Programming\nContact: vlcek@beyondsimulations.com\n\n\n. . .\n\n\n\n\n\n\nI really appreciate active participation and interaction!\n\n\n\n\n\n\n\nWhat is\nManagement\nScience?\n\n\nPhoto by Patrick Konior on Unsplash\n\n\n\n\nManagement science is an interdisciplinary field that applies research-based methods, such as modeling, statistics, and algorithms, to solve complex organizational problems and guide strategic decisions, seeking optimal or near‑optimal outcomes across institutions, corporations, and governments.1\n. . .\nIt is not the science of management!\n\n\n\n\n\nPart I: Python Foundation (Lectures 1-3)\n\nVariables, loops, functions, data science tools\n\nPart II: Management Science Tools (Lectures 4-9)\n\nMonte Carlo, Scheduling, Routing, Metaheuristics\n\nPart III: Consulting Competition (Lectures 10-12)\n\nClient briefings, development, final presentations\n\n\n\n. . .\n\n\n\n\n\n\nYou’re now consultants learning to solve real business problems!\n\n\n\n\n\n\nWhere Algorithms Make Millions\n\n\nAmazon: Routing algorithms save millions in delivery costs\nUber: Real-time matching algorithms connect drivers and riders\nHospitals: Scheduling algorithms optimize shifts and OR usage\nAirlines: Revenue algorithms price tickets dynamically\nManufacturing: Production scheduling reduces waste and delays\n\n\n. . .\nManagement Science is everywhere!\n\n\n\nThe Consultant Mindset\n\n\nYou’ll work on business problems\nLearn to communicate solutions to non-technical clients\nBuild practical tools that solve actual challenges\nCompete in a consulting competition with real scenarios\n\n\n. . .\n\n\n\n\n\n\nThink like a consultant: What value does my solution bring to the business?\n\n\n\n\n\n\n\n\n12 lectures of intensive learning\n3 hours per lecture (with breaks!)\nInteractive format:\n\nConcepts & Setup\nHands-on Python notebooks\nConsulting Competition\n\nFinal competition: Apply everything you’ve learned\n\n\n. . .\nEach lecture builds on the previous - attendance is important!\n\n\n\nGrade Composition:\n\nCourse has 100 points, 50 needed to pass\n2 Assignments: 30 points each\nFinal Consulting Project: 40 points\n\n. . .\n\n\n\n\n\n\nWe will have several competitions including our final competition, where you will have the chance to earn bonus points!\n\n\n\n\n\n\nAssignment Strategy:\n\nStart with easy warm-ups in tutorials\nProgress to real-world problems\nAll assignments have clear rubrics\nBonus points for creative solutions!\n\n. . .\n\n\n\n\n\n\nLate submissions: -10% per day (max 3 days)\n\n\n\n\n\n\n\nIn my experience, the best way to learn is by doing!\nHere, we will focus on decision algorithms\nYou will start to learn Python by doing the tutorials\n\n. . .\n\n\n\n\n\n\nDon’t worry, I will help you out if you have any questions!\n\n\n\n\n\n\n\n\nNo prior programming required - we start from zero!\nBut experience is helpful!\nFast-paced but with lots of support\nPractical focus - less theory, more doing\nMistakes are welcome - they’re how we learn\n\n\n. . .\n\n\n\n\n\n\nThe course gets easier after week 3 - the hardest part is getting started!\n\n\n\n\n\n\nBy the end, you will be able to:\n\n\nWrite Python code to solve business problems\nApply algorithms for scheduling, routing, and optimization\nSimulate uncertainty using Monte Carlo methods\nPresent solutions like a management consultant\nBuild tools that create business value\n\n\n. . .\nYou’ll leave with a portfolio of ideas to work on real solutions!\n\n\n\n\nOrigins: Conceived in late 1980s as a teaching and scripting language\nSimple Syntax: Python’s syntax is mostly straightforward and very easy to learn\nVersatility: Used in web development, data analysis, artificial intelligence, and more\nCommunity Support: A large community of users worldwide and extensive documentation\n\n\n\n\n\nYou are allowed to use AI in the course\nI use it as well (e.g., Claude, ChatGPT, Gemini, …)\nThese tools are great for learning Python!\nCan help you a lot to get started with programming\nI will also teach you how to use it effectively\n\n. . .\n\n\n\n\n\n\nBut you should not simply use them to replace your learning.",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#about-me",
    "href": "lectures/lec_01_introduction.html#about-me",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Field: Optimizing and simulating complex systems\nLanguages: of choice: Julia, Python and Rust\nInterest: Modelling, Simulations, Machine Learning\nTeaching: OR, Algorithms, and Programming\nContact: vlcek@beyondsimulations.com\n\n\n. . .\n\n\n\n\n\n\nI really appreciate active participation and interaction!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#section",
    "href": "lectures/lec_01_introduction.html#section",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "What is\nManagement\nScience?\n\n\nPhoto by Patrick Konior on Unsplash",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#management-science",
    "href": "lectures/lec_01_introduction.html#management-science",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Management science is an interdisciplinary field that applies research-based methods, such as modeling, statistics, and algorithms, to solve complex organizational problems and guide strategic decisions, seeking optimal or near‑optimal outcomes across institutions, corporations, and governments.1\n. . .\nIt is not the science of management!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#course-outline",
    "href": "lectures/lec_01_introduction.html#course-outline",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Part I: Python Foundation (Lectures 1-3)\n\nVariables, loops, functions, data science tools\n\nPart II: Management Science Tools (Lectures 4-9)\n\nMonte Carlo, Scheduling, Routing, Metaheuristics\n\nPart III: Consulting Competition (Lectures 10-12)\n\nClient briefings, development, final presentations\n\n\n\n. . .\n\n\n\n\n\n\nYou’re now consultants learning to solve real business problems!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#from-amazon-to-hospitals",
    "href": "lectures/lec_01_introduction.html#from-amazon-to-hospitals",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Where Algorithms Make Millions\n\n\nAmazon: Routing algorithms save millions in delivery costs\nUber: Real-time matching algorithms connect drivers and riders\nHospitals: Scheduling algorithms optimize shifts and OR usage\nAirlines: Revenue algorithms price tickets dynamically\nManufacturing: Production scheduling reduces waste and delays\n\n\n. . .\nManagement Science is everywhere!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#this-course-approach",
    "href": "lectures/lec_01_introduction.html#this-course-approach",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "The Consultant Mindset\n\n\nYou’ll work on business problems\nLearn to communicate solutions to non-technical clients\nBuild practical tools that solve actual challenges\nCompete in a consulting competition with real scenarios\n\n\n. . .\n\n\n\n\n\n\nThink like a consultant: What value does my solution bring to the business?",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#course-structure",
    "href": "lectures/lec_01_introduction.html#course-structure",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "12 lectures of intensive learning\n3 hours per lecture (with breaks!)\nInteractive format:\n\nConcepts & Setup\nHands-on Python notebooks\nConsulting Competition\n\nFinal competition: Apply everything you’ve learned\n\n\n. . .\nEach lecture builds on the previous - attendance is important!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#grading",
    "href": "lectures/lec_01_introduction.html#grading",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Grade Composition:\n\nCourse has 100 points, 50 needed to pass\n2 Assignments: 30 points each\nFinal Consulting Project: 40 points\n\n. . .\n\n\n\n\n\n\nWe will have several competitions including our final competition, where you will have the chance to earn bonus points!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#assignments",
    "href": "lectures/lec_01_introduction.html#assignments",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Assignment Strategy:\n\nStart with easy warm-ups in tutorials\nProgress to real-world problems\nAll assignments have clear rubrics\nBonus points for creative solutions!\n\n. . .\n\n\n\n\n\n\nLate submissions: -10% per day (max 3 days)",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#learning-python",
    "href": "lectures/lec_01_introduction.html#learning-python",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "In my experience, the best way to learn is by doing!\nHere, we will focus on decision algorithms\nYou will start to learn Python by doing the tutorials\n\n. . .\n\n\n\n\n\n\nDon’t worry, I will help you out if you have any questions!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#what-to-expect",
    "href": "lectures/lec_01_introduction.html#what-to-expect",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "No prior programming required - we start from zero!\nBut experience is helpful!\nFast-paced but with lots of support\nPractical focus - less theory, more doing\nMistakes are welcome - they’re how we learn\n\n\n. . .\n\n\n\n\n\n\nThe course gets easier after week 3 - the hardest part is getting started!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#course-goals",
    "href": "lectures/lec_01_introduction.html#course-goals",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "By the end, you will be able to:\n\n\nWrite Python code to solve business problems\nApply algorithms for scheduling, routing, and optimization\nSimulate uncertainty using Monte Carlo methods\nPresent solutions like a management consultant\nBuild tools that create business value\n\n\n. . .\nYou’ll leave with a portfolio of ideas to work on real solutions!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#why-python",
    "href": "lectures/lec_01_introduction.html#why-python",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Origins: Conceived in late 1980s as a teaching and scripting language\nSimple Syntax: Python’s syntax is mostly straightforward and very easy to learn\nVersatility: Used in web development, data analysis, artificial intelligence, and more\nCommunity Support: A large community of users worldwide and extensive documentation",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#help-from-ai",
    "href": "lectures/lec_01_introduction.html#help-from-ai",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "You are allowed to use AI in the course\nI use it as well (e.g., Claude, ChatGPT, Gemini, …)\nThese tools are great for learning Python!\nCan help you a lot to get started with programming\nI will also teach you how to use it effectively\n\n. . .\n\n\n\n\n\n\nBut you should not simply use them to replace your learning.",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#my-recommendation",
    "href": "lectures/lec_01_introduction.html#my-recommendation",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "My Recommendation",
    "text": "My Recommendation\n\nBe present: Attend the lecture and solve the tutorials\nPut in work: Repeat code and try to understand it\nDo coding: Run code, play around, modify, and solve\nCompete: Participate in the competitions to learn\n\n. . .\n\n\n\n\n\n\nGreat resources to start are books and small challenges. You can find a list of recommendations in the literature recommendations.",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#dont-give-up",
    "href": "lectures/lec_01_introduction.html#dont-give-up",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Don’t give up!",
    "text": "Don’t give up!\nProgramming is like learning to ride a bike\n. . .\n\nYou’ll fall a few times\nIt feels impossible at first\nThen suddenly… it clicks!\n\n. . .\n\n\n\n\n\n\nLectures 1-3 are the hardest. Push through and it gets much easier!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#what-is-an-ide",
    "href": "lectures/lec_01_introduction.html#what-is-an-ide",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "What is an IDE?",
    "text": "What is an IDE?\n\nIntegrated Development Environment = application\nIt allows you to write, run and debug code scripts\nOther IDEs include for example:\n\nPyCharm from JetBrains\nZed",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#install-vs-code",
    "href": "lectures/lec_01_introduction.html#install-vs-code",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Install VS Code",
    "text": "Install VS Code\n\nDownload and install from the website\nBuilt for Windows, Linux and Mac\nInstall the Python and Jupyter extension\nGreat! First steps are done\n\n. . .\n\n\n\n\n\n\nUnsure on how to work with VS Code and notebooks? Ask me! I’m happy to help you out!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#installation-of-python-with-uv",
    "href": "lectures/lec_01_introduction.html#installation-of-python-with-uv",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Installation of Python with uv",
    "text": "Installation of Python with uv\n\nWe will use uv to install and manage Python versions\nIt works on Windows, Mac and Linux\nIt helps us to manage packages and virtual environments\nNow, we all go here and install uv and Python\n\n. . .\n\n\n\n\n\n\nIf the installation does not work, let me know!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#quick-check",
    "href": "lectures/lec_01_introduction.html#quick-check",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Quick Check",
    "text": "Quick Check\n\nHave you installed uv and initialized the project?\nGreat! Before we continue, check the following:\n\nYou have a folder for the course\nYou have initialized uv with uv init inside the folder\nYou can see a file called pyproject.toml in the folder\n\n\n. . .\n\n\n\n\n\n\nSomething not working yet? Ask me!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#using-notebooks",
    "href": "lectures/lec_01_introduction.html#using-notebooks",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Using Notebooks",
    "text": "Using Notebooks\n\n\nNow we need to add a kernel to our project\nRun uv add --dev ipykernel from your terminal\nNow run uv add jupyter in the terminal\nThis allows us to use uv Python in notebooks\nDone? Perfect. Now we can start!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#working-with-notebooks",
    "href": "lectures/lec_01_introduction.html#working-with-notebooks",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Working with Notebooks",
    "text": "Working with Notebooks\n\nNow you can download the files from the website\nJust click on one of the sessions and open it\nSelect Jupyter on the right side\nDownload and save the files to your course folder\nOpen them and select “Open with Jupyter Notebook”\n\n. . .\n\n\n\n\n\n\nThat was the hardest part today!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#section-1",
    "href": "lectures/lec_01_introduction.html#section-1",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "",
    "text": "Any questions\nso far?",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#whats-next",
    "href": "lectures/lec_01_introduction.html#whats-next",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "What’s Next?",
    "text": "What’s Next?\nAfter the break, we’ll dive into:\n\nTutorial 1: Variables and basic data types\nTutorial 2: Lists and loops\nTutorial 3: Conditionals and control flow\n\n. . .\n\n\n\n\n\n\nReady for the tutorials? Make sure your Jupyter notebook is working before we continue!",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#the-end",
    "href": "lectures/lec_01_introduction.html#the-end",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "The End",
    "text": "The End\nThat’s it for our introduction!\nMake sure you have:\n\nVS Code installed and running\nPython environment set up with uv\nJupyter notebooks working\nThe tutorial files downloaded\n\n. . .\n\n\n\n\n\n\nTake a 10-minute break, then we’ll start with the interactive notebooks.",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#interesting-literature-on-algorithms",
    "href": "lectures/lec_01_introduction.html#interesting-literature-on-algorithms",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Interesting Literature on Algorithms",
    "text": "Interesting Literature on Algorithms\n\nChristian, B., & Griffiths, T. (2016). Algorithms to live by: the computer science of human decisions. First international edition. New York, Henry Holt and Company.2\nFerguson, T.S. (1989) ‘Who solved the secretary problem?’, Statistical Science, 4(3). doi:10.1214/ss/1177012493.",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#books-on-programming",
    "href": "lectures/lec_01_introduction.html#books-on-programming",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Books on Programming",
    "text": "Books on Programming\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly. Here\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\n. . .\n\n\n\n\n\n\nThink Python is a great book to start with. It’s available online for free. Schrödinger Programmiert Python is a great alternative for German students, as it is a very playful introduction to programming with lots of examples.",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#more-literature",
    "href": "lectures/lec_01_introduction.html#more-literature",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "More Literature",
    "text": "More Literature\nFor more interesting literature, take a look at the literature list of this course.",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "lectures/lec_01_introduction.html#footnotes",
    "href": "lectures/lec_01_introduction.html#footnotes",
    "title": "Lecture 1 - Introduction & Python Setup",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAn Introduction to Management Science: Quantitative Approaches to Decision Making (15 ed.). Boston: Cengage Learning, Inc. 2019. ISBN 978-1-337-40652-9.↩︎\nA great inspiration to learn more about Algorithms!↩︎",
    "crumbs": [
      "01 Let's Start",
      "01 Introduction"
    ]
  },
  {
    "objectID": "general/uv.html",
    "href": "general/uv.html",
    "title": "Installing Python",
    "section": "",
    "text": "uv is a new (and very fast) Python tool written in Rust. It:\n\nInstalls Python for you (no manual downloads).\nCreates isolated virtual environments (safe sandboxes per project).\nInstalls and updates packages quickly.\n\n\n\n\n\n\n\nWHAT is a virtual environment? Think of each project as its own coffee shop with its own supplies. One shop changing its menu does not affect the others. WHY it matters: You avoid random breakage when different projects need different versions of the same package.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#why-we-use-uv-for-this-course",
    "href": "general/uv.html#why-we-use-uv-for-this-course",
    "title": "Installing Python",
    "section": "",
    "text": "uv is a new (and very fast) Python tool written in Rust. It:\n\nInstalls Python for you (no manual downloads).\nCreates isolated virtual environments (safe sandboxes per project).\nInstalls and updates packages quickly.\n\n\n\n\n\n\n\nWHAT is a virtual environment? Think of each project as its own coffee shop with its own supplies. One shop changing its menu does not affect the others. WHY it matters: You avoid random breakage when different projects need different versions of the same package.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#install-uv",
    "href": "general/uv.html#install-uv",
    "title": "Installing Python",
    "section": "Install uv",
    "text": "Install uv\nChoose the instructions for your operating system. To these, you need to work in your terminal.\n\n\n\n\n\n\nOpen the terminal in VS Code by selecting (Terminal → New Terminal).\n\n\n\n\nmacOS or Linux (Terminal)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nIf curl is missing:\nwget -qO- https://astral.sh/uv/install.sh | sh\nAfter installation: close and reopen your terminal (so your PATH updates).\n\n\nWindows (PowerShell)\nOpen PowerShell and run:\npowershell -ExecutionPolicy Bypass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\nIf you see a script execution warning, you can alternatively first run:\nSet-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process\nThen re-run the install line.\n\n\nVerify installation\nRun (macOS / Linux / Windows):\nuv --version\nIf you see a version number: great!\n\n\n\n\n\n\nIf you get “command not found” or “‘uv’ is not recognized”:\n\nClose and reopen the terminal (important).\nOn Windows: make sure you used PowerShell (not Command Prompt).\nStill broken? Ask for help, no need of guessing the error.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#installpython",
    "href": "general/uv.html#installpython",
    "title": "Installing Python",
    "section": "InstallPython",
    "text": "InstallPython\nWe want everyone on the same Python version for consistency. Thus, we’ll use Python 3.12 for the course this year.\nInstall (you only need to do this once):\nuv python install 3.12\nCheck the installation:\nuv run python --version\nExpected output starts with:\nPython 3.12.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#create-your-first-project",
    "href": "general/uv.html#create-your-first-project",
    "title": "Installing Python",
    "section": "Create your first project",
    "text": "Create your first project\nPick a folder where you keep course work. If you do not have one, make sure to create one! Open the course folder in your IDE and then run the following from the terminal:\nuv init\nuv init creates:\n\nmain.py (starter script)\npyproject.toml (project + dependencies config)\n.python-version (records the Python version we chose)\n.gitignore (useful if you ever use Git)\nREADME.md (you can jot notes here)\n(A .venv folder will appear later once packages are added or synced.)\n\n\n\n\n\n\n\nYou do not need to edit any of these (except maybe README.md for your notes and main.py if you want to run something different).",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#run-the-starter-script",
    "href": "general/uv.html#run-the-starter-script",
    "title": "Installing Python",
    "section": "Run the starter script",
    "text": "Run the starter script\nInside the project folder in your terminal:\nuv run python main.py\nYou should see something like:\nHello World!\n(If you want, you can open main.py and change the message, then re-run.)\n\nWhat does that code mean?\ndef main():\n    print(\"Hello, World!\")\n\nif __name__ == \"__main__\":\n    main()\n\ndef main(): defines a function (a reusable block of code).\nprint(...) shows text in the terminal.\nThe line if __name__ == \"__main__\": ensures this only auto-runs when the file is executed directly.\n\nDon’t worry about this yet, we’ll gradually build up to it.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#adding-packages-later-in-the-course",
    "href": "general/uv.html#adding-packages-later-in-the-course",
    "title": "Installing Python",
    "section": "Adding packages (later in the course)",
    "text": "Adding packages (later in the course)\nIf/when you need a package (example: pandas):\nuv add pandas\nIf you added the wrong one:\nuv remove pandas\nIf your pyproject.toml changed (e.g. you pulled code from someone else):\nuv sync\n\n\n\n\n\n\nIf something seems “off”, just close the terminal and reopen in the project folder. Fresh starts fix many early mistakes.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#updating-uv",
    "href": "general/uv.html#updating-uv",
    "title": "Installing Python",
    "section": "Updating uv",
    "text": "Updating uv\nOccasionally:\nuv self update\n\n\n\n\n\n\nIf it ever errors, you can just reinstall using the same one-liner from earlier.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#best-practices-for-this-course",
    "href": "general/uv.html#best-practices-for-this-course",
    "title": "Installing Python",
    "section": "Best practices for this course",
    "text": "Best practices for this course\n\nOne folder for the course keeps everything tidy.\nNever install packages “globally” outside a project.\nKeep a short personal log in each project’s README.md (What did I do? What still confuses me?).\nAsk early for help, guessing usually takes much more time than asking.\n\nYou can always see available commands:\nuv --help",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/uv.html#recap",
    "href": "general/uv.html#recap",
    "title": "Installing Python",
    "section": "Recap",
    "text": "Recap\nYou can now:\n\nInstall uv.\nCreate a project.\nRun a script.\nAdd/remove/sync packages.\n\nNow, you’re set to continue the course.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "general/privacy.html",
    "href": "general/privacy.html",
    "title": "Privacy Policy",
    "section": "",
    "text": "Welcome! This Privacy Policy explains how we collect, use, shares, and protects information in relation to our AI Chatbot service (the “Chatbot”) provided on this website. All other services do not use data that is covered by this policy!\nWe are committed to protecting your privacy. This policy outlines our practices concerning the data processed when you interact with our Chatbot. By using the Chatbot, you agree to the collection and use of information in accordance with this policy."
  },
  {
    "objectID": "general/privacy.html#introduction",
    "href": "general/privacy.html#introduction",
    "title": "Privacy Policy",
    "section": "",
    "text": "Welcome! This Privacy Policy explains how we collect, use, shares, and protects information in relation to our AI Chatbot service (the “Chatbot”) provided on this website. All other services do not use data that is covered by this policy!\nWe are committed to protecting your privacy. This policy outlines our practices concerning the data processed when you interact with our Chatbot. By using the Chatbot, you agree to the collection and use of information in accordance with this policy."
  },
  {
    "objectID": "general/privacy.html#data-controller",
    "href": "general/privacy.html#data-controller",
    "title": "Privacy Policy",
    "section": "2. Data Controller",
    "text": "2. Data Controller\nThe data controller responsible for your personal data is:\nBeyond Simulations GmbH\nAm Eich 9d\n22113 Oststeinbek\nGermany\nEmail: info@beyond-simulations.com"
  },
  {
    "objectID": "general/privacy.html#information-we-collect",
    "href": "general/privacy.html#information-we-collect",
    "title": "Privacy Policy",
    "section": "3. Information We Collect",
    "text": "3. Information We Collect\nWhen you interact with our Chatbot, we collect and process the following types of information:\n\nChat Interactions: This includes the questions, prompts, and text you submit to the Chatbot (“Prompts”) and the responses generated by the Chatbot (“Responses”). We do not store any personal data and all prompts are anonymized.\nTechnical Data: We may automatically collect technical information associated with your interaction, such as timestamps, session identifiers for service functionality. This data is processed on our self-hosted server at Hetzner in Germany.\nUsage Data: We may collect aggregated and anonymized data about how the Chatbot is used to monitor performance and improve the service."
  },
  {
    "objectID": "general/privacy.html#how-we-use-your-information",
    "href": "general/privacy.html#how-we-use-your-information",
    "title": "Privacy Policy",
    "section": "4. How We Use Your Information",
    "text": "4. How We Use Your Information\nWe use the collected information for the following purposes:\n\nTo Provide and Operate the Chatbot: To receive your Prompts, process them using AI models, and deliver Responses back to you.\nTo Route Requests: To manage communication between our Chatbot interface and the underlying AI models via intermediary services.\nFor Safety and Content Moderation: To analyze Prompts and/or potential Responses for harmful, inappropriate, or policy-violating content using designated services by Mistral AI acting as guardrails, aiming to ensure safer interactions.\nFor Service Improvement: To analyze usage patterns to understand user needs, troubleshoot issues, and enhance the Chatbot’s performance and capabilities.\nFor Security and Monitoring: To maintain the security of our service, prevent fraud, and monitor for potential misuse.\nTo Comply with Legal Obligations: To meet any applicable legal or regulatory requirements."
  },
  {
    "objectID": "general/privacy.html#legal-basis-for-processing",
    "href": "general/privacy.html#legal-basis-for-processing",
    "title": "Privacy Policy",
    "section": "5. Legal Basis for Processing",
    "text": "5. Legal Basis for Processing\nWe process your personal data based on the following legal grounds:\n\nLegitimate Interests: Processing is necessary for our legitimate interests in operating and improving the Chatbot service and maintaining its security, provided these interests are not overridden by your data protection rights.\nConsent: In some cases, we might ask for your explicit consent for specific processing activities (e.g., using conversation data for fine-tuning models beyond basic service provision).\nLegal Obligation: Processing is necessary to comply with a legal obligation to which we are subject."
  },
  {
    "objectID": "general/privacy.html#data-sharing-and-third-parties",
    "href": "general/privacy.html#data-sharing-and-third-parties",
    "title": "Privacy Policy",
    "section": "6. Data Sharing and Third Parties",
    "text": "6. Data Sharing and Third Parties\nTo provide the Chatbot service, your Prompts are processed by and shared with the following third-party services and infrastructure providers:\n\nChatbot Interface: The user interface for the Chatbot runs directly in your web browser.\nRAG-Backend: The RAG backend runs on a self-hosted server on Hetzner in Germany.\nLLM Observation (Langfuse): We use Langfuse to observe the usage of the LLM models we use. Your Prompts (and generated responses) pass through Langfuse to reach the selected LLM provider or guardrail service. The data is stored on our self-hosted server at Hetzner in Germany.\nHosting Provider (Hetzner): Our instance of Langfuse is self-hosted on servers provided by Hetzner Online GmbH. Hetzner acts as a data processor providing the infrastructure. We store application data and interaction logs on these servers, located within Germany.\nMistral AI: We use Mistral AI for two primary purposes: (1) as one of the LLM options to generate Responses to your Prompts, and (2) as a guardrail service to check Prompts and/or potential Responses (which may have been generated by Mistral AI itself) for safety, appropriateness, and compliance with content policies before a final response is delivered to you. When Mistral is used for either generation or guardrail checking, your data (relevant Prompts and/or potential Responses) is processed according to Mistral’s terms and privacy policy. The data ist not used or saved for training purposes by the model providers.\n\nImportant Note on Third-Party Processing: These LLM and guardrail providers process your data to generate Responses or perform safety checks. They may use data according to their own policies, potentially including service improvement, subject to their terms. We encourage you to review their respective privacy policies. We do not explicitly share personal identifiers like your name or email through the Chatbot interaction unless you voluntarily include such information in your Prompts."
  },
  {
    "objectID": "general/privacy.html#data-storage-security-and-retention",
    "href": "general/privacy.html#data-storage-security-and-retention",
    "title": "Privacy Policy",
    "section": "7. Data Storage, Security, and Retention",
    "text": "7. Data Storage, Security, and Retention\n\nStorage: Chat interaction data (Prompts, Responses) and technical logs may be stored temporarily or persistently (depending on configuration) on our Langfuse instance hosted on Hetzner servers in Germany.\nSecurity: We implement reasonable technical and organizational measures to protect your data from unauthorized access, disclosure, alteration, or destruction. This includes using HTTPS encryption for data transmitted between your browser, our server, and the LLM providers. Access to the backend systems is restricted.\nRetention: We retain chat interaction data and technical logs only for as long as necessary to fulfill the purposes outlined in this policy, for troubleshooting, security logging, service improvement, or as required by law. Retention periods vary depending on the type of data and our operational needs."
  },
  {
    "objectID": "general/privacy.html#your-data-protection-rights",
    "href": "general/privacy.html#your-data-protection-rights",
    "title": "Privacy Policy",
    "section": "8. Your Data Protection Rights",
    "text": "8. Your Data Protection Rights\nDepending on your location and applicable data protection laws, you may have the following rights regarding your personal data:\n\nRight to Access: You can request copies of your personal data that we hold.\nRight to Rectification: You can request correction of inaccurate or incomplete data.\nRight to Erasure (‘Right to be Forgotten’): You can request the deletion of your personal data under certain conditions.\nRight to Restrict Processing: You can request the limitation of how we process your data under certain conditions.\nRight to Data Portability: You can request that we transfer the data we have collected to another organization, or directly to you, under certain conditions.\nRight to Object: You can object to our processing of your personal data based on legitimate interests.\nRight to Withdraw Consent: If processing is based on consent, you can withdraw it at any time.\n\nTo exercise any of these rights, please contact us using the details provided in Section 2 (Data Controller). We may need to verify your identity before processing your request."
  },
  {
    "objectID": "general/privacy.html#changes-to-this-privacy-policy",
    "href": "general/privacy.html#changes-to-this-privacy-policy",
    "title": "Privacy Policy",
    "section": "9. Changes to This Privacy Policy",
    "text": "9. Changes to This Privacy Policy\nWe may update this Privacy Policy from time to time. We will notify you of any significant changes by posting the new policy on this page and updating the “Last Updated” date at the top. We encourage you to review this policy periodically for any changes."
  },
  {
    "objectID": "general/faq.html",
    "href": "general/faq.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "If you have a question that is not answered here, please let me know by sending me an e-mail to vlcek@beyondsimulations.com.",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "general/faq.html#unanswered-questions",
    "href": "general/faq.html#unanswered-questions",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "If you have a question that is not answered here, please let me know by sending me an e-mail to vlcek@beyondsimulations.com.",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "general/faq.html#contribution-and-mistakes",
    "href": "general/faq.html#contribution-and-mistakes",
    "title": "Frequently Asked Questions",
    "section": "Contribution and Mistakes",
    "text": "Contribution and Mistakes\nIf you have found a mistake in the course material or if you have any suggestion on how to improve the course, please let me know by sending me an e-mail to vlcek@beyondsimulations.com.",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "general/faq.html#faqs",
    "href": "general/faq.html#faqs",
    "title": "Frequently Asked Questions",
    "section": "FAQs",
    "text": "FAQs\n\nHow can I download PDF slides from the lecture?\n\nFirst, open the lecture you want to download the slides from.\nThen, click on the RevealJS button in the top right corner.\nNow, click on the three stacked bars in the lower left corner.\nThen, click on Tools in the upper left corner.\nNow you can select PDF Export Mode and then save the slides as a PDF.\n\n\n\n\n\n\n\nUnfortunately, this method does not work perfectly on all browsers. If you have a Chrome based browser, you should be fine.",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "general/faq.html#how-does-the-chatbot-work",
    "href": "general/faq.html#how-does-the-chatbot-work",
    "title": "Frequently Asked Questions",
    "section": "How does the chatbot work?",
    "text": "How does the chatbot work?\nThe course AI is a chatbot that uses the Mistral and some custom code hosted on Hetzner in Germany. If you have any questions about the course, feel free to ask the AI. Note, that the AI is not perfect and sometimes the answers might be incorrect. For more information about how the data is processed, please refer to the privacy policy.",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "general/faq.html#is-using-copilot-cheating",
    "href": "general/faq.html#is-using-copilot-cheating",
    "title": "Frequently Asked Questions",
    "section": "Is using Copilot cheating?",
    "text": "Is using Copilot cheating?\nNo! Think of it more like using a calculator. It is allowed and encouraged, but you must understand what it does in the background to check the results.",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "general/faq.html#will-copilot-make-me-a-worse-programmer",
    "href": "general/faq.html#will-copilot-make-me-a-worse-programmer",
    "title": "Frequently Asked Questions",
    "section": "Will Copilot make me a worse programmer?",
    "text": "Will Copilot make me a worse programmer?\nIf you don’t learn the basics first by yourself and try to come up with the solution structure, most likely yes. But it is still better then just copying everything into ChatGPT and if used wisely, it can also accelerate learning by showing you patterns.",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "general/faq.html#what-if-copilot-suggests-wrong-code",
    "href": "general/faq.html#what-if-copilot-suggests-wrong-code",
    "title": "Frequently Asked Questions",
    "section": "What if Copilot suggests wrong code?",
    "text": "What if Copilot suggests wrong code?\nCopilot (and all Large Mondels) are far from perfect. They work based on statistics and there will always be lots of mistakes and hallucinations, which most likely never can be fixed.1 That’s why humans are still very important in the loop.",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "general/faq.html#footnotes",
    "href": "general/faq.html#footnotes",
    "title": "Frequently Asked Questions",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://machinelearning.apple.com/research/illusion-of-thinking↩︎",
    "crumbs": [
      "FAQs"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to Management Science!",
    "section": "",
    "text": "Management Science is an interdisciplinary field that applies scientific methods to organizational problem-solving and decision-making. By leveraging mathematical modeling, statistics, and numerical algorithms, management science helps businesses achieve their strategic goals effectively.\nIn this course, you’ll build a comprehensive toolkit by solving real problems across diverse business domains. Each algorithm is a tool, each case is a client, and each presentation is a pitch. Throughout the semester, you’ll work with realistic, business-relevant scenarios using Python. The course end in a consulting competition where teams tackle client briefs (food delivery routing, healthcare staff scheduling, or inventory optimization) and present solutions to a panel of “executives.”",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#required-tools",
    "href": "index.html#required-tools",
    "title": "Welcome to Management Science!",
    "section": "Required Tools",
    "text": "Required Tools\n\nLaptop capable of running Python and Jupyter notebooks\nPython (installed via uv package manager in class)\nGitHub Copilot (free with Student Developer Pack)\nVS Code or similar IDE",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#getting-help",
    "href": "index.html#getting-help",
    "title": "Welcome to Management Science!",
    "section": "Getting Help",
    "text": "Getting Help\n\nDuring class: Ask questions immediately, others likely have the same question\nTeam support: Leverage your group for collaborative problem-solving\nEmail: Response within 48 hours for urgent questions",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "general/cheatsheet.html",
    "href": "general/cheatsheet.html",
    "title": "Cheatsheet",
    "section": "",
    "text": "Definition: Containers for storing information.\nExample: x = 10\n\n\n\n\n\nIntegers (int): Whole numbers (e.g., count of dates).\nFloats (float): Decimal numbers (e.g., compatibility score).\nBooleans (bool): True/False values (e.g., availability).\nStrings (str): Text values (e.g., names).\n\n  name = \"Alexander\"  # String variable\n  flags = 0           # Integer variable\n  butterflies = True  # Boolean variable\n\n\n\n\nChecking: Use type() to check the type of a variable.\nConversion:\n\nint(): Converts to integer.\nfloat(): Converts to float.\nstr(): Converts to string.\nbool(): Converts to boolean.\n\n\n\n\n\n\nConcatenation: Combine strings using +.\nFormatting: Use f\"...\" for formatted strings.\n\n\nname = \"Alexander\"\nprint(f\"Hello, {name}!\")\n\nHello, Alexander!",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#variables",
    "href": "general/cheatsheet.html#variables",
    "title": "Cheatsheet",
    "section": "",
    "text": "Definition: Containers for storing information.\nExample: x = 10",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#data-types",
    "href": "general/cheatsheet.html#data-types",
    "title": "Cheatsheet",
    "section": "",
    "text": "Integers (int): Whole numbers (e.g., count of dates).\nFloats (float): Decimal numbers (e.g., compatibility score).\nBooleans (bool): True/False values (e.g., availability).\nStrings (str): Text values (e.g., names).\n\n  name = \"Alexander\"  # String variable\n  flags = 0           # Integer variable\n  butterflies = True  # Boolean variable",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#type-conversion",
    "href": "general/cheatsheet.html#type-conversion",
    "title": "Cheatsheet",
    "section": "",
    "text": "Checking: Use type() to check the type of a variable.\nConversion:\n\nint(): Converts to integer.\nfloat(): Converts to float.\nstr(): Converts to string.\nbool(): Converts to boolean.",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#string-formatting",
    "href": "general/cheatsheet.html#string-formatting",
    "title": "Cheatsheet",
    "section": "",
    "text": "Concatenation: Combine strings using +.\nFormatting: Use f\"...\" for formatted strings.\n\n\nname = \"Alexander\"\nprint(f\"Hello, {name}!\")\n\nHello, Alexander!",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#comparison-operators",
    "href": "general/cheatsheet.html#comparison-operators",
    "title": "Cheatsheet",
    "section": "Comparison Operators",
    "text": "Comparison Operators\n\n\n\n\n\n\n\n\nSymbol\nMeaning\nExample\n\n\n\n\n==\nEqual to\nscore == 100\n\n\n!=\nNot equal to\ndegree != “Computer Science”\n\n\n&lt;\nLess than\nsalary &lt; 80000\n\n\n&gt;\nGreater than\nexperience &gt; 5\n\n\n&lt;=\nLess than or equal to\nage &lt;= 65\n\n\n&gt;=\nGreater than or equal to\ntest_score &gt;= 80",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#logical-operators",
    "href": "general/cheatsheet.html#logical-operators",
    "title": "Cheatsheet",
    "section": "Logical Operators",
    "text": "Logical Operators\n\n\n\n\n\n\n\n\nSymbol\nMeaning\nExample\n\n\n\n\nand\nBoth conditions must be true\nscore &gt; 80 and experience &gt; 5\n\n\nor\nAt least one condition must be true\nscore &gt; 80 or experience &gt; 5\n\n\nnot\nCondition must be false\nnot (score &gt; 80)",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#if-statements",
    "href": "general/cheatsheet.html#if-statements",
    "title": "Cheatsheet",
    "section": "if Statements",
    "text": "if Statements\n\nStructure:\n\nif condition:\n    # code to execute if condition is True\n\nExample:\n\n\nflat_rating = 8\nif flat_rating &gt;= 7:\n    print(\"This is a good apartment!\")\n\nThis is a good apartment!",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#if-else-statements",
    "href": "general/cheatsheet.html#if-else-statements",
    "title": "Cheatsheet",
    "section": "if-else Statements",
    "text": "if-else Statements\n\nStructure:\n\nif condition:\n    # code to execute if condition is True\nelse:\n    # code to execute if condition is False\n\nExample:\n\n\nflat_rating = 4\nif flat_rating &gt;= 7:\n    print(\"Apply for this flat!\")\nelse:\n    print(\"Keep searching!\")\n\nKeep searching!",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#if-elif-else-statements",
    "href": "general/cheatsheet.html#if-elif-else-statements",
    "title": "Cheatsheet",
    "section": "if-elif-else Statements",
    "text": "if-elif-else Statements\n\nStructure:\n\nif condition:\n    # code to execute if condition is True\nelif condition:\n    # code to execute if condition is False\nelse:\n    # code to execute if condition is False\n\nExample:\n\n\nflat_rating = 8\nif flat_rating &gt;= 9:\n    print(\"Amazing flat - apply immediately!\")\nelif flat_rating &gt;= 7:\n    print(\"Good flat - consider applying\")\nelse:\n    print(\"Keep looking\")\n\nGood flat - consider applying",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#complex-conditions",
    "href": "general/cheatsheet.html#complex-conditions",
    "title": "Cheatsheet",
    "section": "Complex Conditions",
    "text": "Complex Conditions\n\nNested if Statements: Use if statements inside other if statements.\nLogical Operators: Combine conditions using and, or, not.\nStructure:\n\nif (condition1) and (condition2):\n    # code if both conditions are True\nelif (condition1) or (condition2):\n    # code if at least one condition is True\nelse:\n    # code if none of the conditions are True\n\nExample:\n\n\nflat_rating = 9\nprice = 900\nif (flat_rating &gt;= 9) and (price &lt; 1000):\n    print(\"Amazing flat - apply immediately!\")\n\nAmazing flat - apply immediately!",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#accessing-elements",
    "href": "general/cheatsheet.html#accessing-elements",
    "title": "Cheatsheet",
    "section": "Accessing Elements",
    "text": "Accessing Elements\n\nIndexing: Use [index] to access elements.\n\n\nprint(restaurants[0])  # Access the first element\n\nMagic Place\n\n\n\nNegative Indexing: Use [-1] to access the last element.\n\n\nprint(restaurants[-1])  # Access the last element\n\nCoffee Shop\n\n\n\nSlicing: Use [start:end] to access a range of elements.\n\n\nprint(restaurants[0:2])  # Access the first two elements\n\n['Magic Place', 'Sushi Bar']",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#adding-elements",
    "href": "general/cheatsheet.html#adding-elements",
    "title": "Cheatsheet",
    "section": "Adding Elements",
    "text": "Adding Elements\n\nAppending: Use append() to add an element to the end of the list.\n\n\nrestaurants.append(\"Pasta Place\")\n\n\nInserting: Use insert() to add an element at a specific index.\n\n\nrestaurants.insert(0, \"Pasta Magic\")",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#removing-elements",
    "href": "general/cheatsheet.html#removing-elements",
    "title": "Cheatsheet",
    "section": "Removing Elements",
    "text": "Removing Elements\n\nRemoving: Use remove() to remove an element by value.\n\n\nrestaurants.remove(\"Pasta Place\")\n\n\nRemoving by Index: Use pop() to remove an element by index.\n\n\nrestaurants.pop(0)\n\n'Pasta Magic'",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#nested-lists",
    "href": "general/cheatsheet.html#nested-lists",
    "title": "Cheatsheet",
    "section": "Nested Lists",
    "text": "Nested Lists\n\nDefinition: Lists containing other lists or tuples.\nAccessing: Use nested indexing.\n\n\nrestaurant_data = [\n    [\"Pasta Place\", 4.5, 3],\n    [\"Sushi Bar\", 4.2, 1]\n]\nprint(restaurants[0][1])  # Access the second element of the first list\n\na",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#tuples",
    "href": "general/cheatsheet.html#tuples",
    "title": "Cheatsheet",
    "section": "Tuples",
    "text": "Tuples\n\nDefinition: Ordered, immutable collections of items.\nCreation: Use parentheses ().\nImmutability: Once created, cannot be changed.\nMemory Efficiency: Use less memory than lists.\nUse Cases: Ideal for fixed data (e.g., restaurant location).\n\n\nratings = (4.5, 3.8, 4.2)\nrestaurant_info = (\"Pasta Place\", \"Italian\", 2020)",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#for-loops",
    "href": "general/cheatsheet.html#for-loops",
    "title": "Cheatsheet",
    "section": "for Loops",
    "text": "for Loops\n\nDefinition: Iterate over a sequence of items.\nStructure:\n\nfor item in sequence:\n    # code to execute for each item\n\nExample:\n\n\ntreatments = [\"Standard Drug\", \"New Drug A\", \"New Drug B\"]\nfor treatment in treatments:\n    print(f\"Evaluating efficacy of {treatment}\")\n\nEvaluating efficacy of Standard Drug\nEvaluating efficacy of New Drug A\nEvaluating efficacy of New Drug B",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#range-in-for-loops",
    "href": "general/cheatsheet.html#range-in-for-loops",
    "title": "Cheatsheet",
    "section": "Range in for Loops",
    "text": "Range in for Loops\n\nDefinition: Generate a sequence of numbers.\nStructure:\n\nrange(start, stop, step)\n\nExample:\n\n\nfor phase in range(5):  # 0 to 4\n    print(f\"Starting Phase {phase + 1}\")\n\nStarting Phase 1\nStarting Phase 2\nStarting Phase 3\nStarting Phase 4\nStarting Phase 5\n\n\n\nfor phase in range(1, 5):  # 1 to 4\n    print(f\"Starting Phase {phase}\")\n\nStarting Phase 1\nStarting Phase 2\nStarting Phase 3\nStarting Phase 4\n\n\n\nfor phase in range(1, 5, 2):  # 1 to 4, step 2\n    print(f\"Starting Phase {phase}\")\n\nStarting Phase 1\nStarting Phase 3",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#break-and-continue",
    "href": "general/cheatsheet.html#break-and-continue",
    "title": "Cheatsheet",
    "section": "break and continue",
    "text": "break and continue\n\nbreak: Exit the loop.\ncontinue: Skip the current iteration and continue with the next.\n\n\nefficacy_scores = [45, 60, 75, 85, 90]\nfor score in efficacy_scores:\n    if score &lt; 50:\n        continue\n        print(f\"Treatment efficacy: {score}%\")\n    if score &gt;= 85:\n        break",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#tuple-unpacking",
    "href": "general/cheatsheet.html#tuple-unpacking",
    "title": "Cheatsheet",
    "section": "Tuple unpacking",
    "text": "Tuple unpacking\n\nDefinition: Assign elements of a tuple to variables.\nStructure:\nExample:\n\n\nrestaurant_info = (\"Pasta Place\", \"Italian\", 2020)\nname, cuisine, year = restaurant_info\nprint(name)\nprint(cuisine)\nprint(year)\n\nPasta Place\nItalian\n2020",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#while-loops",
    "href": "general/cheatsheet.html#while-loops",
    "title": "Cheatsheet",
    "section": "while Loops",
    "text": "while Loops\n\nDefinition: Execute code repeatedly as long as a condition is true.\nStructure:\n\nwhile condition:\n    # code to execute while condition is True\n\nExample:\n\n\nphase = 1\nwhile phase &lt;= 5:\n    print(f\"Starting Phase {phase}\")\n    phase += 1\n\nStarting Phase 1\nStarting Phase 2\nStarting Phase 3\nStarting Phase 4\nStarting Phase 5",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#basic-function",
    "href": "general/cheatsheet.html#basic-function",
    "title": "Cheatsheet",
    "section": "Basic Function",
    "text": "Basic Function\n\nDefinition: Use the def keyword.\nStructure:\n\ndef function_name(parameters):\n    # code to execute (function body)\n    return value  # Optional\n\nExample:\n\n\ndef greet_visitor(name):\n    return f\"Welcome to the library, {name}!\"\n\ngreet_visitor(\"Student\")\n\n'Welcome to the library, Student!'",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#return-value",
    "href": "general/cheatsheet.html#return-value",
    "title": "Cheatsheet",
    "section": "Return Value",
    "text": "Return Value\n\nDefinition: The value returned by a function.\nExample:\n\n\ndef multiply_by_two(number):\n    return number * 2\n\nresult = multiply_by_two(5)\nprint(result)\n\n10\n\n\n\nNote: If a function does not return a value, it implicitly returns None.",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#default-parameters",
    "href": "general/cheatsheet.html#default-parameters",
    "title": "Cheatsheet",
    "section": "Default Parameters",
    "text": "Default Parameters\n\nDefinition: Provide default values for function parameters.\nStructure:\n\ndef greet_visitor(name=\"People\"):\n    return f\"Welcome to the library, {name}!\"\n\nprint(greet_visitor()) # Calls the function with the default parameter\nprint(greet_visitor(\"Tobias\")) # Calls the function with a custom parameter",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#multiple-parameters",
    "href": "general/cheatsheet.html#multiple-parameters",
    "title": "Cheatsheet",
    "section": "Multiple Parameters",
    "text": "Multiple Parameters\n\nDefinition: Functions can have multiple parameters.\nStructure:\n\ndef greet_visitor(name, age):\n    return f\"Welcome to the library, {name}! You are {age} years old.\"\n\nprint(greet_visitor(\"Tobias\", 30))",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#standard-libraries",
    "href": "general/cheatsheet.html#standard-libraries",
    "title": "Cheatsheet",
    "section": "Standard Libraries",
    "text": "Standard Libraries\n\nDefinition: Libraries that are part of the Python standard library.\nAccess: Import them using import.\n\n\nimport math\nimport random\n\n\nFor long package names, you can use the as keyword to create an alias.\n\n\nimport random as rd\n\n\nTo call a function from an imported package, use the package name as a prefix.\n\n\nrandom_number = rd.random()\nprint(random_number)\n\n0.9776567391156107",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#installing-packages",
    "href": "general/cheatsheet.html#installing-packages",
    "title": "Cheatsheet",
    "section": "Installing Packages",
    "text": "Installing Packages\n\nDefinition: Install packages using uv. Note, don’t do this inside of a notebook but in the terminal in your project folder!\n\nuv add package_name",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#normal-distribution",
    "href": "general/cheatsheet.html#normal-distribution",
    "title": "Cheatsheet",
    "section": "Normal Distribution",
    "text": "Normal Distribution\n\nWhen to Use: Most common in business and nature; symmetric outcomes around a mean\nCharacteristics:\n\nBell-shaped, symmetric curve\nMost values cluster around the mean\nRare extreme values in tails\n\nExamples:\n\nInvestment returns\nManufacturing variations\nEmployee performance scores\nMeasurement errors\n\n\nPython Syntax:\n\nimport numpy as np\n\n# Generate normal distribution\nreturns = np.random.normal(loc=mean, scale=std_dev, size=n_samples)\n\n# Example: Stock returns with 10% mean, 15% volatility\nstock_returns = np.random.normal(loc=0.10, scale=0.15, size=10000)\n\nParameters:\n\nloc: The mean (center) of the distribution\nscale: The standard deviation (spread)\nsize: Number of samples to generate",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#uniform-distribution",
    "href": "general/cheatsheet.html#uniform-distribution",
    "title": "Cheatsheet",
    "section": "Uniform Distribution",
    "text": "Uniform Distribution\n\nWhen to Use: Complete uncertainty within a range; all outcomes equally likely\nCharacteristics:\n\nFlat distribution\nAll values equally likely\nHard boundaries (min/max)\nNo clustering around any value\n\nExamples:\n\nRandom wait times\nInitial demand estimates with only min/max known\nRandom sampling from a range\n\n\nPython Syntax:\n\n# Generate uniform distribution\nvalues = np.random.uniform(low=minimum, high=maximum, size=n_samples)\n\n# Example: Demand between 1000 and 5000 units\ndemand = np.random.uniform(low=1000, high=5000, size=10000)\n\nParameters:\n\nlow: Minimum value (inclusive)\nhigh: Maximum value (exclusive)\nsize: Number of samples to generate",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#exponential-distribution",
    "href": "general/cheatsheet.html#exponential-distribution",
    "title": "Cheatsheet",
    "section": "Exponential Distribution",
    "text": "Exponential Distribution\n\nWhen to Use: Time between events; waiting times\nCharacteristics:\n\nMany small values, few large ones\nAlways positive\nMemoryless property\nRight-skewed (long tail)\n\nExamples:\n\nTime between customer arrivals\nEquipment failure times\nTime until next sale\nDuration of phone calls\n\n\nPython Syntax:\n\n# Generate exponential distribution\nwait_times = np.random.exponential(scale=average_time, size=n_samples)\n\n# Example: Time between customers (avg 5 minutes)\narrivals = np.random.exponential(scale=5, size=10000)\n\nParameters:\n\nscale: The average (mean) time between events\nsize: Number of samples to generate",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#binomial-distribution",
    "href": "general/cheatsheet.html#binomial-distribution",
    "title": "Cheatsheet",
    "section": "Binomial Distribution",
    "text": "Binomial Distribution\n\nWhen to Use: Fixed number of independent yes/no trials\nCharacteristics:\n\nDiscrete outcomes (counts)\nFixed number of trials\nEach trial has same probability\nTrials are independent\n\nExamples:\n\nNumber of defective items in a batch\nNumber of successful sales calls\nNumber of customers who convert\nNumber of loans that default\n\n\nPython Syntax:\n\n# Generate binomial distribution\nsuccesses = np.random.binomial(n=n_trials, p=prob_success, size=n_samples)\n\n# Example: 100 sales calls with 20% conversion rate\nconversions = np.random.binomial(n=100, p=0.20, size=10000)\n\nParameters:\n\nn: Number of trials\np: Probability of success on each trial\nsize: Number of experiments to simulate",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#common-risk-metrics",
    "href": "general/cheatsheet.html#common-risk-metrics",
    "title": "Cheatsheet",
    "section": "Common Risk Metrics",
    "text": "Common Risk Metrics\nCalculate from simulated results:\n\n# Basic statistics\nmean_return = results.mean()\nstd_dev = results.std()\nmin_value = results.min()\nmax_value = results.max()\n\n# Percentiles (Value at Risk)\nvar_5 = np.percentile(results, 5)  # 5th percentile (worst 5%)\nvar_95 = np.percentile(results, 95)  # 95th percentile (best 5%)\n\n# Probability of loss\nprob_loss = (results &lt; 0).mean()\n\n# Expected shortfall (average of worst 5%)\nworst_5_percent = results[results &lt;= var_5]\nexpected_shortfall = worst_5_percent.mean()\n\n# Correlation between two variables\ncorrelation = np.corrcoef(returns1, returns2)[0, 1]",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#basic-simulation-pattern",
    "href": "general/cheatsheet.html#basic-simulation-pattern",
    "title": "Cheatsheet",
    "section": "Basic Simulation Pattern",
    "text": "Basic Simulation Pattern\nDefinition: Running many scenarios to understand possible outcomes under uncertainty.\nCommon Pattern: 1. Create empty list to store results: results = [] 2. Run simulations in a loop, calling simulation function 3. Append each result to list: results.append(simulation_result) 4. Convert to DataFrame: pd.DataFrame(results)\n\n# Example simulation function\ndef simulate_business_day():\n    customers = np.random.normal(100, 20)  # Uncertain demand\n    revenue = customers * np.random.uniform(8, 12)  # Variable pricing\n    profit = revenue - 500  # Fixed costs\n    return {'customers': customers, 'revenue': revenue, 'profit': profit}\n\n# Run multiple simulations\nresults = []\nfor i in range(10000):\n    day_result = simulate_business_day()\n    results.append(day_result)\n\n# Convert to DataFrame for analysis\ndf_results = pd.DataFrame(results)",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#analyzing-simulation-results",
    "href": "general/cheatsheet.html#analyzing-simulation-results",
    "title": "Cheatsheet",
    "section": "Analyzing Simulation Results",
    "text": "Analyzing Simulation Results\n\n# Basic statistics\nmean_profit = df_results['profit'].mean()\nstd_profit = df_results['profit'].std()\n\n# Risk analysis\nloss_probability = (df_results['profit'] &lt; 0).mean()\nprofit_range = (df_results['profit'] &gt;= 100) & (df_results['profit'] &lt;= 200)\nrange_probability = profit_range.mean()\n\n# Percentiles for Value at Risk\nvar_5 = np.percentile(df_results['profit'], 5)  # Worst 5% scenario\nvar_95 = np.percentile(df_results['profit'], 95)  # Best 5% scenario",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#working-with-dates",
    "href": "general/cheatsheet.html#working-with-dates",
    "title": "Cheatsheet",
    "section": "Working with Dates",
    "text": "Working with Dates\n\n# Convert strings to datetime\ndates = pd.to_datetime(['2024-01-15', '2024-02-20'])\n\n# Extract date components using .dt accessor\ndf['month'] = df['date'].dt.month\ndf['day_of_week'] = df['date'].dt.day_of_week  # 0=Monday, 6=Sunday\ndf['quarter'] = df['date'].dt.quarter\ndf['is_month_end'] = df['date'].dt.is_month_end\n\n# Access specific elements\nthird_month = df['date'].dt.month.iloc[2]  # Third row's month",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#moving-averages",
    "href": "general/cheatsheet.html#moving-averages",
    "title": "Cheatsheet",
    "section": "Moving Averages",
    "text": "Moving Averages\nDefinition: Smooth time series by averaging over a window of periods.\n\n# Simple moving average\ndf['ma_7'] = df['sales'].rolling(window=7).mean()  # 7-day average\ndf['ma_30'] = df['sales'].rolling(window=30).mean()  # 30-day average\n\n# Note: First few values will be NaN due to insufficient data\n# Use .dropna() to remove NaN values if needed\nclean_data = df.dropna()",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#basic-forecasting-methods",
    "href": "general/cheatsheet.html#basic-forecasting-methods",
    "title": "Cheatsheet",
    "section": "Basic Forecasting Methods",
    "text": "Basic Forecasting Methods\n\nNaive Forecast\n\ndef naive_forecast(data, periods=1):\n    \"\"\"Tomorrow = today (simplest baseline)\"\"\"\n    return [data.iloc[-1]] * periods\n\n\n\nMoving Average Forecast\n\ndef moving_average_forecast(data, window=7, periods=1):\n    \"\"\"Forecast using average of last 'window' periods\"\"\"\n    ma = data.iloc[-window:].mean()\n    return [ma] * periods\n\n\n\nExponential Smoothing\n\ndef exponential_smoothing_forecast(data, alpha=0.3, periods=1):\n    \"\"\"Weight recent observations more heavily\"\"\"\n    forecasts = [data.iloc[0]]  # Start with first value\n\n    # Calculate smoothed values\n    for i in range(1, len(data)):\n        forecast = alpha * data.iloc[i] + (1 - alpha) * forecasts[-1]\n        forecasts.append(forecast)\n\n    # Use last smoothed value for future periods\n    return [forecasts[-1]] * periods\n\nAlpha parameter:\n\nα = 0.9: Very responsive (trust recent data)\nα = 0.3: Balanced (typical default)\nα = 0.1: Very stable (smooth out noise)",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#forecast-accuracy-metrics",
    "href": "general/cheatsheet.html#forecast-accuracy-metrics",
    "title": "Cheatsheet",
    "section": "Forecast Accuracy Metrics",
    "text": "Forecast Accuracy Metrics\n\ndef calculate_mae(actual, forecast):\n    \"\"\"Mean Absolute Error - average error size\"\"\"\n    return np.mean(np.abs(actual - forecast))\n\ndef calculate_rmse(actual, forecast):\n    \"\"\"Root Mean Squared Error - penalizes large errors\"\"\"\n    return np.sqrt(np.mean((actual - forecast) ** 2))\n\nWhen to use:\n\nMAE: Easier to interpret, same units as data\nRMSE: More sensitive to large errors/outliers",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#key-performance-metrics",
    "href": "general/cheatsheet.html#key-performance-metrics",
    "title": "Cheatsheet",
    "section": "Key Performance Metrics",
    "text": "Key Performance Metrics\n\ndef calculate_metrics(schedule_df):\n    \"\"\"Calculate scheduling performance metrics\"\"\"\n    return {\n        'makespan': schedule_df['completion'].max(),  # Total time\n        'avg_flow_time': schedule_df['completion'].mean(),  # Average completion\n        'total_tardiness': np.maximum(0, schedule_df['completion'] - schedule_df['due']).sum(),\n        'late_orders': (schedule_df['completion'] &gt; schedule_df['due']).sum()\n    }",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#key-concepts",
    "href": "general/cheatsheet.html#key-concepts",
    "title": "Cheatsheet",
    "section": "Key Concepts",
    "text": "Key Concepts\n\nSlack: Scheduling flexibility = Due Time - Processing Time\nStatic Scheduling: Sort all orders first, then process sequentially\nDynamic Scheduling: Make decisions as orders arrive",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#common-scheduling-rules",
    "href": "general/cheatsheet.html#common-scheduling-rules",
    "title": "Cheatsheet",
    "section": "Common Scheduling Rules",
    "text": "Common Scheduling Rules\n\nFIFO (First In, First Out)\nProcess orders in original sequence (by ID or arrival time).\n\n\nSPT (Shortest Processing Time)\nProcess shortest jobs first - minimizes average flow time.\n\n\nEDD (Earliest Due Date)\nProcess orders with earliest due dates first - minimizes maximum lateness.",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/cheatsheet.html#dynamic-vs-static-scheduling",
    "href": "general/cheatsheet.html#dynamic-vs-static-scheduling",
    "title": "Cheatsheet",
    "section": "Dynamic vs Static Scheduling",
    "text": "Dynamic vs Static Scheduling\nStatic: All orders available at time 0, sort once and process. Dynamic: Orders arrive over time, make decisions when machine becomes free.\n\n# Dynamic scheduling pattern\ndef schedule_dynamic(orders):\n    scheduled = []\n    remaining = [o.copy() for o in orders]\n    current_time = 0\n\n    while remaining:\n        # Find available orders (arrived by current_time)\n        available = [o for o in remaining if o['arrival'] &lt;= current_time]\n\n        # If nothing available, jump to next arrival\n        if not available:\n            current_time = min(o['arrival'] for o in remaining)\n            available = [o for o in remaining if o['arrival'] &lt;= current_time]\n\n        # Apply scheduling rule (e.g., SPT)\n        next_order = min(available, key=lambda x: x['processing'])\n\n        # Schedule and update\n        next_order['start'] = current_time\n        next_order['completion'] = current_time + next_order['processing']\n        current_time = next_order['completion']\n\n        scheduled.append(next_order)\n        remaining.remove(next_order)\n\n    return scheduled",
    "crumbs": [
      "Cheatsheet"
    ]
  },
  {
    "objectID": "general/literature.html",
    "href": "general/literature.html",
    "title": "Literature and Resources",
    "section": "",
    "text": "This section provides a curated list of books and resources to enhance your understanding of algorithmic thinking and programming. Each recommendation includes a brief description to help you choose the most suitable resources for you.",
    "crumbs": [
      "Literature"
    ]
  },
  {
    "objectID": "general/literature.html#books",
    "href": "general/literature.html#books",
    "title": "Literature and Resources",
    "section": "Books",
    "text": "Books\n\nChristian, B., & Griffiths, T. (2016). Algorithms to live by: the computer science of human decisions. First international edition. New York, Henry Holt and Company.\n\nA book that inspired this lecture and will give you a good intuition for the principles of algorithmic thinking and how they can be applied to solve problems in everyday life.\n\nZingaro, D. (2024) Algorithmic thinking, 2nd edition: Unlock your programming potential. AU: No Starch Press.\n\nA book that introduces you to different algorithms and their reasoning. Written without any pseudocode, but with a lot of examples and explanations.",
    "crumbs": [
      "Literature"
    ]
  },
  {
    "objectID": "general/literature.html#books-1",
    "href": "general/literature.html#books-1",
    "title": "Literature and Resources",
    "section": "Books",
    "text": "Books\n\nDowney, A. B. (2024). Think Python: How to think like a computer scientist (Third edition). O’Reilly.\n\nA great book to start with if you have no experience with programming.\nLink to free online book\n\n\n\nDowney, A. B. (2023). Modeling and Simulation in Python. No Starch Press.\n\n\nAn interesting book for those who want know more about simulations in Python.\nLink to the book\nVanderPlas, J. (2016). A whirlwind tour of Python (August 2016, First edition). O’Reilly Media Inc.\n\nA very good and short book to get a quick overview of the most important features of Python if you already have some experience with programming.\nLink to the free online version\n\nElter, S. (2021). Schrödinger programmiert Python: Das etwas andere Fachbuch (1. Auflage). Rheinwerk Verlag.\n\nA book that is unfortunately only available in German, but a very good and comedic start for beginners with lots of illustrations, examples and exercises. It is only available in print.\n\nMatthes, E. (2023). Python crash course: A hands-on, project-based introduction to programming (3rd edition). No Starch Press.\n\nA great book to learn Python with a hands-on approach. Highly recommended even for beginners but only available to buy.",
    "crumbs": [
      "Literature"
    ]
  },
  {
    "objectID": "general/literature.html#resources",
    "href": "general/literature.html#resources",
    "title": "Literature and Resources",
    "section": "Resources",
    "text": "Resources\n\nDaily Dose of Data Science\n\nA website and a newsletter with lots of easy-to-digest resources to improve your skills in Data Science.",
    "crumbs": [
      "Literature"
    ]
  },
  {
    "objectID": "general/literature.html#books-2",
    "href": "general/literature.html#books-2",
    "title": "Literature and Resources",
    "section": "Books",
    "text": "Books\n\nWilke, C. (2019). Fundamentals of data visualization: A primer on making informative and compelling figures (First edition). O’Reilly Media.\n\nA book that is highly recommended to understand the principles of data visualization and how to create effective visualizations.\nLink to the free book website\n\nThomas, D., & Hunt, A. (2019). The pragmatic programmer, 20th anniversary edition: Journey to mastery (Second edition). Addison-Wesley.\n\nA fantasticbook to understand the principles of software development and how to create effective software.",
    "crumbs": [
      "Literature"
    ]
  },
  {
    "objectID": "general/literature.html#resources-1",
    "href": "general/literature.html#resources-1",
    "title": "Literature and Resources",
    "section": "Resources",
    "text": "Resources\n\nQuarto\n\nA static website generator that is very powerful and flexible. Used to create the slides and the website for the course.\n\nCursor\n\nA code editor based on VS Code that is very powerful and flexible. It uses AI to help you write code.\n\nZed\n\nA young and lightweight code editor that is very fast and lightweight with built-in collaboration and AI features.\n\nAdvent of Code\n\nA wonderful website with daily challenges during the christmas time. Highly recommended to playfully improve your skills.\n\nTiny Python Projects\n\nInteresting and fun projects to programm in order to improve your programming skills.\n\nGithub\n\nThe largest provider for git repositories owned by Microsoft. A lot of open source projects are hosted here and you can read the code.\n\nCodewars\n\nA platform to improve your coding skills by solving challenges. You can compete with others, see how other people solved the challenges and read and learn from the code.\n\nCheat-Sheets\n\nFantastic resource with cheat sheets for the book “Python Crash Course” by Eric Matthes. You can use these to quickly look up syntax and functions.\n\nortools\n\nGoogle’s optimization tools based on metaheuristics. Include options for routing as well!",
    "crumbs": [
      "Literature"
    ]
  },
  {
    "objectID": "general/syllabus.html",
    "href": "general/syllabus.html",
    "title": "Course Syllabus",
    "section": "",
    "text": "No mini-competitions yet - focus on solid foundations\n\n\n\nCourse introduction\nPython setup with uv package manager\nVariables, data types, basic operations\nLists and indexing fundamentals\nConditionals and basic loops\n\n\n\n\n\nFunctions for code organization\nDictionaries for structured data\nTuples and multiple return values\nSorting and optimization fundamentals\nGitHub Copilot integration and best practices\n\n\n\n\n\nNumPy for numerical computing and random simulation\nPandas for data manipulation and analysis\nData visualization with matplotlib\nCSV file handling and real dataset exploration\nIntegration practice with business scenarios\n\n\n\n\n\nMini-competitions begin - apply algorithms to business problems\nFormat for Lectures 4-9:\n\nHour 1: Solution presentations of previous competition\nHour 2: Interactive lecture on core concepts\nHour 3: Hands-on notebook practice + class discussion\nHour 4: Mini-competition with real data\nBonus Points: Best solution teams earn points toward final grade\n\n\n\n\nProbability distributions and random sampling\nBusiness risk modeling techniques\nPortfolio optimization under uncertainty\nCoffee shop simulation case study\n\n\n\n\n\nTime series analysis fundamentals\nDemand forecasting methods\nForecast evaluation metrics\nSeasonal and trend analysis\n\n\n\n\n\nSPT (Shortest Processing Time) rule\nEDD (Earliest Due Date) rule\nGantt chart visualization\nPerformance metrics: makespan, tardiness, flow time\n\n\n\n\n\nNearest neighbor heuristic\n2-opt local search improvements\nRoute optimization metrics\nReal logistics applications\n\n\n\n\n\nWeighted scoring methods\nPareto efficiency concepts\nDecision criteria combination\nBusiness trade-off analysis\n\n\n\n\n\nWhen simple heuristics fail\nGenetic algorithms introduction\nSimulated annealing basics\nAlgorithm selection strategies\n\n\n\n\n\nReal client challenges with professional presentations\n\n\n\nThree client projects to choose from:\n\nQuickBite: Food delivery routing optimization\nNurseNext: Healthcare staff scheduling\nTechMart: E-commerce inventory optimization\n\nTeam formation and data exploration\nProject scope definition\n\n\n\n\n\nPresentation skills training\nIntensive solution development\nPeer consultation and feedback\nPrototype completion milestone\n\n\n\n\n\nProfessional presentation competition\n“Executive panel evaluation”\nSolution demonstration and Q&A",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "general/syllabus.html#part-i-python-foundation-lectures-1-3",
    "href": "general/syllabus.html#part-i-python-foundation-lectures-1-3",
    "title": "Course Syllabus",
    "section": "",
    "text": "No mini-competitions yet - focus on solid foundations\n\n\n\nCourse introduction\nPython setup with uv package manager\nVariables, data types, basic operations\nLists and indexing fundamentals\nConditionals and basic loops\n\n\n\n\n\nFunctions for code organization\nDictionaries for structured data\nTuples and multiple return values\nSorting and optimization fundamentals\nGitHub Copilot integration and best practices\n\n\n\n\n\nNumPy for numerical computing and random simulation\nPandas for data manipulation and analysis\nData visualization with matplotlib\nCSV file handling and real dataset exploration\nIntegration practice with business scenarios",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "general/syllabus.html#part-ii-management-science-tools-lectures-4-9",
    "href": "general/syllabus.html#part-ii-management-science-tools-lectures-4-9",
    "title": "Course Syllabus",
    "section": "",
    "text": "Mini-competitions begin - apply algorithms to business problems\nFormat for Lectures 4-9:\n\nHour 1: Solution presentations of previous competition\nHour 2: Interactive lecture on core concepts\nHour 3: Hands-on notebook practice + class discussion\nHour 4: Mini-competition with real data\nBonus Points: Best solution teams earn points toward final grade\n\n\n\n\nProbability distributions and random sampling\nBusiness risk modeling techniques\nPortfolio optimization under uncertainty\nCoffee shop simulation case study\n\n\n\n\n\nTime series analysis fundamentals\nDemand forecasting methods\nForecast evaluation metrics\nSeasonal and trend analysis\n\n\n\n\n\nSPT (Shortest Processing Time) rule\nEDD (Earliest Due Date) rule\nGantt chart visualization\nPerformance metrics: makespan, tardiness, flow time\n\n\n\n\n\nNearest neighbor heuristic\n2-opt local search improvements\nRoute optimization metrics\nReal logistics applications\n\n\n\n\n\nWeighted scoring methods\nPareto efficiency concepts\nDecision criteria combination\nBusiness trade-off analysis\n\n\n\n\n\nWhen simple heuristics fail\nGenetic algorithms introduction\nSimulated annealing basics\nAlgorithm selection strategies",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "general/syllabus.html#part-iii-consulting-competition-lectures-10-12",
    "href": "general/syllabus.html#part-iii-consulting-competition-lectures-10-12",
    "title": "Course Syllabus",
    "section": "",
    "text": "Real client challenges with professional presentations\n\n\n\nThree client projects to choose from:\n\nQuickBite: Food delivery routing optimization\nNurseNext: Healthcare staff scheduling\nTechMart: E-commerce inventory optimization\n\nTeam formation and data exploration\nProject scope definition\n\n\n\n\n\nPresentation skills training\nIntensive solution development\nPeer consultation and feedback\nPrototype completion milestone\n\n\n\n\n\nProfessional presentation competition\n“Executive panel evaluation”\nSolution demonstration and Q&A",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "general/syllabus.html#grade-composition-100-points-total",
    "href": "general/syllabus.html#grade-composition-100-points-total",
    "title": "Course Syllabus",
    "section": "Grade Composition (100 points total)",
    "text": "Grade Composition (100 points total)\n\n\n\nComponent\nPoints\nPercentage\nDescription\n\n\n\n\nAssignment 1: Risk & Forecasting\n30\n30%\nDue Lecture 8\n\n\nAssignment 2: Optimization Toolkit\n30\n30%\nDue Lecture 10\n\n\nFinal Competition Project\n40\n40%\nLectures 10-12\n\n\n- Solution Quality\n20\n20%\nTechnical implementation\n\n\n- Presentation\n20\n20%\nCommunication effectiveness",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "general/syllabus.html#bonus-opportunities-additional-points-possible",
    "href": "general/syllabus.html#bonus-opportunities-additional-points-possible",
    "title": "Course Syllabus",
    "section": "Bonus Opportunities (Additional points possible)",
    "text": "Bonus Opportunities (Additional points possible)\n\nMini-competition victories (Lectures 4-9): up to +10 points\nPeer-selected best client project: +5 points",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "general/syllabus.html#late-work-policy",
    "href": "general/syllabus.html#late-work-policy",
    "title": "Course Syllabus",
    "section": "Late Work Policy",
    "text": "Late Work Policy\n\nAssignment 1 & 2: -10% per day late (up to 3 days)\nCompetition project: No late submissions accepted (real consulting deadline!)\nExtensions granted only for documented emergencies",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html",
    "href": "lectures/lec_02_copilot_intro.html",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "Coding by hand is not the only way to generate code\nMost likely, a lot of you have already used ChatGPT\n\n. . .\n\n\n\n\n\n\n\n\n\nHow do\nLarge Language\nModels work?\n\n\nPhoto by Taylor Vick on Unsplash\n\n\n\n\n\nThink of them like advanced pattern recognition systems\nThey have “read” massive amounts of text\nBooks, websites, articles, code, and more\nText is broken into tokens, parts of words or punctuation\nBased on patterns, they can generate new text\n\n\n\n\n\nImagine learning a language by reading millions of books\nLearns patterns in how words and ideas connect via tokens\nInterconnected nodes with weights representing patterns\nDuring training, these weights are adjusted\nOnce trained, applying them takes much less ressources\n\n. . .\n\n\n\n\n\n\nUsing a trained model is called inference.\n\n\n\n\n\n\n\nNot like a search engine!\nWhen asked, it looks for relevant patterns it learned\nLike having a huge library in its “memory” to draw from\nIt can find patterns between concepts and your question\nKnows only limited text at once (context window)\n\n. . .\n\n\n\n\n\n\nManaging context windows is crucial!\n\n\n\n\n\n\n\nAfter each written token, it predicts “what should come next?”\nLike a advanced version of the word prediction on your phone\nChooses the most likely next token based on training\nBut can’t actually “think” or “understand” like humans\n\n\n\n\n\nNo true understanding of cause and effect1\nSometimes makes mistakes or “hallucinates”\nMostly only knows what it was trained on2 and can reflect biases\nNo emotional understanding (but can simulate responses!)3\n\n\n\n\n\n\nQuestion: What do you think about their impact on jobs?\nQuestion: What are the implications for us?\nQuestion: Can we use them to our advantage?\n\n\n. . .\n\n\n\n\n\n\nIf you use free models, be aware that your prompts are going to be used by the providers and are not private. But for learning and experimenting, this should be no issue.\n\n\n\n\n\n\n\nGreg Sanderson provides an excellent explanation of LLMs\nGreat starting point to understand LLMs\nCheck out his YouTube channel, 3Blue1Brown for more",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#using-ai-to-generate-code",
    "href": "lectures/lec_02_copilot_intro.html#using-ai-to-generate-code",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "Coding by hand is not the only way to generate code\nMost likely, a lot of you have already used ChatGPT\n\n. . .",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#section",
    "href": "lectures/lec_02_copilot_intro.html#section",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "How do\nLarge Language\nModels work?\n\n\nPhoto by Taylor Vick on Unsplash",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#large-language-models-llms",
    "href": "lectures/lec_02_copilot_intro.html#large-language-models-llms",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "Think of them like advanced pattern recognition systems\nThey have “read” massive amounts of text\nBooks, websites, articles, code, and more\nText is broken into tokens, parts of words or punctuation\nBased on patterns, they can generate new text",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#training-llms",
    "href": "lectures/lec_02_copilot_intro.html#training-llms",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "Imagine learning a language by reading millions of books\nLearns patterns in how words and ideas connect via tokens\nInterconnected nodes with weights representing patterns\nDuring training, these weights are adjusted\nOnce trained, applying them takes much less ressources\n\n. . .\n\n\n\n\n\n\nUsing a trained model is called inference.",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#pattern-recognition",
    "href": "lectures/lec_02_copilot_intro.html#pattern-recognition",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "Not like a search engine!\nWhen asked, it looks for relevant patterns it learned\nLike having a huge library in its “memory” to draw from\nIt can find patterns between concepts and your question\nKnows only limited text at once (context window)\n\n. . .\n\n\n\n\n\n\nManaging context windows is crucial!",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#probability-based-responses",
    "href": "lectures/lec_02_copilot_intro.html#probability-based-responses",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "After each written token, it predicts “what should come next?”\nLike a advanced version of the word prediction on your phone\nChooses the most likely next token based on training\nBut can’t actually “think” or “understand” like humans",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#limitations",
    "href": "lectures/lec_02_copilot_intro.html#limitations",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "No true understanding of cause and effect1\nSometimes makes mistakes or “hallucinates”\nMostly only knows what it was trained on2 and can reflect biases\nNo emotional understanding (but can simulate responses!)3",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#impact-on-jobs",
    "href": "lectures/lec_02_copilot_intro.html#impact-on-jobs",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "Question: What do you think about their impact on jobs?\nQuestion: What are the implications for us?\nQuestion: Can we use them to our advantage?\n\n\n. . .\n\n\n\n\n\n\nIf you use free models, be aware that your prompts are going to be used by the providers and are not private. But for learning and experimenting, this should be no issue.",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#a-great-overview-by-3blue1brown",
    "href": "lectures/lec_02_copilot_intro.html#a-great-overview-by-3blue1brown",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "Greg Sanderson provides an excellent explanation of LLMs\nGreat starting point to understand LLMs\nCheck out his YouTube channel, 3Blue1Brown for more",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#what-is-github-copilot",
    "href": "lectures/lec_02_copilot_intro.html#what-is-github-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "What is GitHub Copilot?",
    "text": "What is GitHub Copilot?\nGitHub Copilot is an AI pair programmer that helps you write code faster and with less effort.\n. . .\nThink of it as:\n\nAn autocomplete for entire lines or blocks of code\nA coding assistant that understands context\nA learning tool that shows you coding patterns\n\n. . .\n\n\n\n\n\n\nCopilot uses AI trained on billions of lines of public code to suggest completions.\n\n\n\n. . .\n\n\n\n\n\n\nThere are alternative like Zed or Cursor, but you can use Copilot for free as student.",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#used-autocomplete-before",
    "href": "lectures/lec_02_copilot_intro.html#used-autocomplete-before",
    "title": "Lecture 2 - AI Programming",
    "section": "Used autocomplete before?",
    "text": "Used autocomplete before?\n. . .\nWhen you type on your phone, it suggests the next word.\n. . .\nGitHub Copilot does the same for code:\n\nYou write a comment describing what you want\nCopilot suggests the code to do it\nYou accept, modify, or reject the suggestion\n\n. . .\nIt’s autocomplete but much better then what you are used to",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#why-use-copilot",
    "href": "lectures/lec_02_copilot_intro.html#why-use-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "Why Use Copilot?",
    "text": "Why Use Copilot?\nBenefits you while learning and working with Python:\n\nFaster coding: Less time typing boilerplate code\nLearn patterns: See how experienced programmers code\nUnderstand syntax: Get correct syntax without memorizing\nStay in flow: Focus on logic, not syntax errors\n\n. . .\n\n\n\n\n\n\nEspecially helpful when you know WHAT you want to do but forget HOW to do it.",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#when-should-you-use-copilot",
    "href": "lectures/lec_02_copilot_intro.html#when-should-you-use-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "When should you use Copilot?",
    "text": "When should you use Copilot?\n. . .\nGood uses of Copilot\n\nUnderstanding Python syntax you forgot\nWriting repetitive or boilerplate code\nGetting unstuck on simple problems\nExploring different approaches",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#what-shouldnt-you-do-with-copilot",
    "href": "lectures/lec_02_copilot_intro.html#what-shouldnt-you-do-with-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "What shouldn’t you do with Copilot?",
    "text": "What shouldn’t you do with Copilot?\n. . .\nNot so good uses of Copilot\n\nReplacing learning fundamentals\nAccepting code you don’t understand\nSkipping practice exercises\nCopy-pasting without reading\n\n. . .\nAlways understand what Copilot suggests before accepting!\n. . .\nBut of course I know you will not do that ;)",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#demo-writing-a-function",
    "href": "lectures/lec_02_copilot_intro.html#demo-writing-a-function",
    "title": "Lecture 2 - AI Programming",
    "section": "Demo: Writing a Function",
    "text": "Demo: Writing a Function\nScenario: Calculate shipping costs based on weight and distance.\n. . .\nStep 1: Write a text describing what you want\n\"\"\"\nCalculate shipping cost based on weight (kg) and distance (km)\nBase rate: €5, plus €0.10 per kg, plus €0.05 per km\n\"\"\"\n. . .\nStep 2: Copilot suggests the function\n. . .\nWatch how Copilot solves this in the IDE!",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#demo-the-result-hopefully",
    "href": "lectures/lec_02_copilot_intro.html#demo-the-result-hopefully",
    "title": "Lecture 2 - AI Programming",
    "section": "Demo: The Result (hopefully)",
    "text": "Demo: The Result (hopefully)\n\ndef calculate_shipping_cost(weight, distance):\n    \"\"\"Calculate shipping cost based on weight and distance.\"\"\"\n    base_rate = 5.0\n    weight_rate = 0.10\n    distance_rate = 0.05\n    return base_rate + (weight * weight_rate) + (distance * distance_rate)\n\n. . .\nWhat Copilot did:\n\nCreated function with proper parameters\nImplemented the calculation logic\nUsed clear variable names\n\n. . .\n\n\n\n\n\n\nNotice how the text guided Copilot to generate exactly what we needed!",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#accept-without-reading",
    "href": "lectures/lec_02_copilot_intro.html#accept-without-reading",
    "title": "Lecture 2 - AI Programming",
    "section": "Accept without reading?",
    "text": "Accept without reading?\n. . .\nCopilot might suggest code that:\n\nWorks but uses concepts you haven’t learned yet\nContains subtle bugs or edge cases\nDoesn’t match your specific requirements\nUses inefficient approaches\nIntroduce dangerous code in your project\n\n. . .\n\n\n\n\n\n\nDangerous code can lead to security vulnerabilities, data loss, or other issues. In the context of this lecture it should be no issue, but in companies it can be one!",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#my-take-just-be-careful-ok",
    "href": "lectures/lec_02_copilot_intro.html#my-take-just-be-careful-ok",
    "title": "Lecture 2 - AI Programming",
    "section": "My take: Just be careful, ok?",
    "text": "My take: Just be careful, ok?\nYour code, your responsibility:\n\nRead the suggestion carefully\nUnderstand what it does\nTest it with examples\nModify if needed\n\n. . .\n\n\n\n\n\n\nDon’t accept code blindly, especially later if things are more complicated.",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#get-free-access",
    "href": "lectures/lec_02_copilot_intro.html#get-free-access",
    "title": "Lecture 2 - AI Programming",
    "section": "Get Free Access",
    "text": "Get Free Access\nGitHub Student Developer Pack gives you free Copilot access!\n. . .\n\nGo to education.github.com/pack\nSign up with your university email\nVerify your student status\nWait for approval (usually 1-2 days)\nLogin into your account in VS Code\n\n. . .\n\n\n\n\n\n\nYou’ll need a GitHub account. Create one at github.com if you don’t have one.",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#verifying-copilot-is-working",
    "href": "lectures/lec_02_copilot_intro.html#verifying-copilot-is-working",
    "title": "Lecture 2 - AI Programming",
    "section": "Verifying Copilot is Working",
    "text": "Verifying Copilot is Working\n\nCreate a new Python file (.py) and type something\nWait 1-2 seconds\n\n. . .\nIf working, you’ll see:\n\nGray “ghost text” suggesting code\nPress Tab to accept\nPress Esc to reject\n\n. . .\n\n\n\n\n\n\nTry to get copilot running on your own until next session.",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#when-to-use-copilot",
    "href": "lectures/lec_02_copilot_intro.html#when-to-use-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "When to Use Copilot",
    "text": "When to Use Copilot\nUse Copilot for:\n. . .\n1. Syntax Help\n# Convert string to datetime\n# Copilot remembers: pd.to_datetime()\n. . .\n2. Boilerplate Code\n# Create a function to read CSV file and return DataFrame\n# Copilot writes the import and function structure\n. . .\n3. Getting Unstuck\n# I know I need to filter this list, but forget the syntax\n# Copilot suggests: [x for x in items if x &gt; 10]",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#when-not-to-use-copilot",
    "href": "lectures/lec_02_copilot_intro.html#when-not-to-use-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "When Not to Use Copilot",
    "text": "When Not to Use Copilot\nDon’t use Copilot for\n. . .\n1. Learning Fundamentals\n\nYou should understand loops, functions, and data types\n\n. . .\n2. Skipping Problem-Solving\n\nFigure out the logic first, then use Copilot for syntax\n\n. . .\n3. Accepting Without Understanding\n\nAsk: “Can I explain what this code does?”",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#key-takeaways",
    "href": "lectures/lec_02_copilot_intro.html#key-takeaways",
    "title": "Lecture 2 - AI Programming",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nGitHub Copilot is a tool: You still need to learn fundamentals\nUnderstand before accepting: Read every suggestion carefully\nUse it strategically: Syntax help yes, thinking replacement no\nGet free access: GitHub Student Developer Pack\nPractice:The more you use it, the more helpful it becomes\n\n. . .\n\n\n\n\n\n\nBefore next lecture, make sure you applied for GitHub Student Developer Pack to get access to copilot!\n\n\n\n. . .\n\n\n\n\n\n\nIf you run into issues, we will solve them next week together!",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_copilot_intro.html#footnotes",
    "href": "lectures/lec_02_copilot_intro.html#footnotes",
    "title": "Lecture 2 - AI Programming",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://www.anthropic.com/research/tracing-thoughts-language-model↩︎\nThis can partially be improved by using context from the internet.↩︎\nUser can get attached to talking to models↩︎",
    "crumbs": [
      "02 Advances",
      "02 Generative AI"
    ]
  },
  {
    "objectID": "lectures/lec_02_presentation.html#using-ai-to-generate-code",
    "href": "lectures/lec_02_presentation.html#using-ai-to-generate-code",
    "title": "Lecture 2 - AI Programming",
    "section": "Using AI to generate code",
    "text": "Using AI to generate code\n\nCoding by hand is not the only way to generate code\nMost likely, a lot of you have already used ChatGPT"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#section",
    "href": "lectures/lec_02_presentation.html#section",
    "title": "Lecture 2 - AI Programming",
    "section": "",
    "text": "How do\nLarge Language\nModels work?\n\n\nPhoto by Taylor Vick on Unsplash"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#large-language-models-llms",
    "href": "lectures/lec_02_presentation.html#large-language-models-llms",
    "title": "Lecture 2 - AI Programming",
    "section": "Large Language Models (LLMs)",
    "text": "Large Language Models (LLMs)\n\nThink of them like advanced pattern recognition systems\nThey have “read” massive amounts of text\nBooks, websites, articles, code, and more\nText is broken into tokens, parts of words or punctuation\nBased on patterns, they can generate new text"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#training-llms",
    "href": "lectures/lec_02_presentation.html#training-llms",
    "title": "Lecture 2 - AI Programming",
    "section": "Training LLMs",
    "text": "Training LLMs\n\nImagine learning a language by reading millions of books\nLearns patterns in how words and ideas connect via tokens\nInterconnected nodes with weights representing patterns\nDuring training, these weights are adjusted\nOnce trained, applying them takes much less ressources\n\n\n\n\n\n\n\n\nUsing a trained model is called inference."
  },
  {
    "objectID": "lectures/lec_02_presentation.html#pattern-recognition",
    "href": "lectures/lec_02_presentation.html#pattern-recognition",
    "title": "Lecture 2 - AI Programming",
    "section": "Pattern Recognition",
    "text": "Pattern Recognition\n\nNot like a search engine!\nWhen asked, it looks for relevant patterns it learned\nLike having a huge library in its “memory” to draw from\nIt can find patterns between concepts and your question\nKnows only limited text at once (context window)\n\n\n\n\n\n\n\n\nManaging context windows is crucial!"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#probability-based-responses",
    "href": "lectures/lec_02_presentation.html#probability-based-responses",
    "title": "Lecture 2 - AI Programming",
    "section": "Probability based responses",
    "text": "Probability based responses\n\nAfter each written token, it predicts “what should come next?”\nLike a advanced version of the word prediction on your phone\nChooses the most likely next token based on training\nBut can’t actually “think” or “understand” like humans"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#limitations",
    "href": "lectures/lec_02_presentation.html#limitations",
    "title": "Lecture 2 - AI Programming",
    "section": "Limitations",
    "text": "Limitations\n\nNo true understanding of cause and effect1\nSometimes makes mistakes or “hallucinates”\nMostly only knows what it was trained on2 and can reflect biases\nNo emotional understanding (but can simulate responses!)3\n\nhttps://www.anthropic.com/research/tracing-thoughts-language-modelThis can partially be improved by using context from the internet.User can get attached to talking to models"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#impact-on-jobs",
    "href": "lectures/lec_02_presentation.html#impact-on-jobs",
    "title": "Lecture 2 - AI Programming",
    "section": "Impact on Jobs",
    "text": "Impact on Jobs\n\nQuestion: What do you think about their impact on jobs?\nQuestion: What are the implications for us?\nQuestion: Can we use them to our advantage?\n\n\n\n\n\n\n\n\nIf you use free models, be aware that your prompts are going to be used by the providers and are not private. But for learning and experimenting, this should be no issue."
  },
  {
    "objectID": "lectures/lec_02_presentation.html#a-great-overview-by-3blue1brown",
    "href": "lectures/lec_02_presentation.html#a-great-overview-by-3blue1brown",
    "title": "Lecture 2 - AI Programming",
    "section": "A Great Overview by 3Blue1Brown",
    "text": "A Great Overview by 3Blue1Brown\n\nGreg Sanderson provides an excellent explanation of LLMs\nGreat starting point to understand LLMs\nCheck out his YouTube channel, 3Blue1Brown for more"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#what-is-github-copilot",
    "href": "lectures/lec_02_presentation.html#what-is-github-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "What is GitHub Copilot?",
    "text": "What is GitHub Copilot?\nGitHub Copilot is an AI pair programmer that helps you write code faster and with less effort.\n\nThink of it as:\n\nAn autocomplete for entire lines or blocks of code\nA coding assistant that understands context\nA learning tool that shows you coding patterns\n\n\n\n\n\n\n\n\n\nCopilot uses AI trained on billions of lines of public code to suggest completions.\n\n\n\n\n\n\n\n\n\n\n\nThere are alternative like Zed or Cursor, but you can use Copilot for free as student."
  },
  {
    "objectID": "lectures/lec_02_presentation.html#used-autocomplete-before",
    "href": "lectures/lec_02_presentation.html#used-autocomplete-before",
    "title": "Lecture 2 - AI Programming",
    "section": "Used autocomplete before?",
    "text": "Used autocomplete before?\n\nWhen you type on your phone, it suggests the next word.\n\n\nGitHub Copilot does the same for code:\n\nYou write a comment describing what you want\nCopilot suggests the code to do it\nYou accept, modify, or reject the suggestion\n\n\n\nIt’s autocomplete but much better then what you are used to"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#why-use-copilot",
    "href": "lectures/lec_02_presentation.html#why-use-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "Why Use Copilot?",
    "text": "Why Use Copilot?\nBenefits you while learning and working with Python:\n\nFaster coding: Less time typing boilerplate code\nLearn patterns: See how experienced programmers code\nUnderstand syntax: Get correct syntax without memorizing\nStay in flow: Focus on logic, not syntax errors\n\n\n\n\n\n\n\n\nEspecially helpful when you know WHAT you want to do but forget HOW to do it."
  },
  {
    "objectID": "lectures/lec_02_presentation.html#when-should-you-use-copilot",
    "href": "lectures/lec_02_presentation.html#when-should-you-use-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "When should you use Copilot?",
    "text": "When should you use Copilot?\n\nGood uses of Copilot\n\nUnderstanding Python syntax you forgot\nWriting repetitive or boilerplate code\nGetting unstuck on simple problems\nExploring different approaches"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#what-shouldnt-you-do-with-copilot",
    "href": "lectures/lec_02_presentation.html#what-shouldnt-you-do-with-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "What shouldn’t you do with Copilot?",
    "text": "What shouldn’t you do with Copilot?\n\nNot so good uses of Copilot\n\nReplacing learning fundamentals\nAccepting code you don’t understand\nSkipping practice exercises\nCopy-pasting without reading\n\n\n\nAlways understand what Copilot suggests before accepting!\n\n\nBut of course I know you will not do that ;)"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#demo-writing-a-function",
    "href": "lectures/lec_02_presentation.html#demo-writing-a-function",
    "title": "Lecture 2 - AI Programming",
    "section": "Demo: Writing a Function",
    "text": "Demo: Writing a Function\nScenario: Calculate shipping costs based on weight and distance.\n\nStep 1: Write a text describing what you want\n\"\"\"\nCalculate shipping cost based on weight (kg) and distance (km)\nBase rate: €5, plus €0.10 per kg, plus €0.05 per km\n\"\"\"\n\n\nStep 2: Copilot suggests the function\n\n\nWatch how Copilot solves this in the IDE!"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#demo-the-result-hopefully",
    "href": "lectures/lec_02_presentation.html#demo-the-result-hopefully",
    "title": "Lecture 2 - AI Programming",
    "section": "Demo: The Result (hopefully)",
    "text": "Demo: The Result (hopefully)\n\ndef calculate_shipping_cost(weight, distance):\n    \"\"\"Calculate shipping cost based on weight and distance.\"\"\"\n    base_rate = 5.0\n    weight_rate = 0.10\n    distance_rate = 0.05\n    return base_rate + (weight * weight_rate) + (distance * distance_rate)\n\n\nWhat Copilot did:\n\nCreated function with proper parameters\nImplemented the calculation logic\nUsed clear variable names\n\n\n\n\n\n\n\n\n\nNotice how the text guided Copilot to generate exactly what we needed!"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#accept-without-reading",
    "href": "lectures/lec_02_presentation.html#accept-without-reading",
    "title": "Lecture 2 - AI Programming",
    "section": "Accept without reading?",
    "text": "Accept without reading?\n\nCopilot might suggest code that:\n\nWorks but uses concepts you haven’t learned yet\nContains subtle bugs or edge cases\nDoesn’t match your specific requirements\nUses inefficient approaches\nIntroduce dangerous code in your project\n\n\n\n\n\n\n\n\n\nDangerous code can lead to security vulnerabilities, data loss, or other issues. In the context of this lecture it should be no issue, but in companies it can be one!"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#my-take-just-be-careful-ok",
    "href": "lectures/lec_02_presentation.html#my-take-just-be-careful-ok",
    "title": "Lecture 2 - AI Programming",
    "section": "My take: Just be careful, ok?",
    "text": "My take: Just be careful, ok?\nYour code, your responsibility:\n\nRead the suggestion carefully\nUnderstand what it does\nTest it with examples\nModify if needed\n\n\n\n\n\n\n\n\nDon’t accept code blindly, especially later if things are more complicated."
  },
  {
    "objectID": "lectures/lec_02_presentation.html#get-free-access",
    "href": "lectures/lec_02_presentation.html#get-free-access",
    "title": "Lecture 2 - AI Programming",
    "section": "Get Free Access",
    "text": "Get Free Access\nGitHub Student Developer Pack gives you free Copilot access!\n\n\nGo to education.github.com/pack\nSign up with your university email\nVerify your student status\nWait for approval (usually 1-2 days)\nLogin into your account in VS Code\n\n\n\n\n\n\n\n\n\nYou’ll need a GitHub account. Create one at github.com if you don’t have one."
  },
  {
    "objectID": "lectures/lec_02_presentation.html#verifying-copilot-is-working",
    "href": "lectures/lec_02_presentation.html#verifying-copilot-is-working",
    "title": "Lecture 2 - AI Programming",
    "section": "Verifying Copilot is Working",
    "text": "Verifying Copilot is Working\n\nCreate a new Python file (.py) and type something\nWait 1-2 seconds\n\n\nIf working, you’ll see:\n\nGray “ghost text” suggesting code\nPress Tab to accept\nPress Esc to reject\n\n\n\n\n\n\n\n\n\nTry to get copilot running on your own until next session."
  },
  {
    "objectID": "lectures/lec_02_presentation.html#when-to-use-copilot",
    "href": "lectures/lec_02_presentation.html#when-to-use-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "When to Use Copilot",
    "text": "When to Use Copilot\nUse Copilot for:\n\n1. Syntax Help\n# Convert string to datetime\n# Copilot remembers: pd.to_datetime()\n\n\n2. Boilerplate Code\n# Create a function to read CSV file and return DataFrame\n# Copilot writes the import and function structure\n\n\n3. Getting Unstuck\n# I know I need to filter this list, but forget the syntax\n# Copilot suggests: [x for x in items if x &gt; 10]"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#when-not-to-use-copilot",
    "href": "lectures/lec_02_presentation.html#when-not-to-use-copilot",
    "title": "Lecture 2 - AI Programming",
    "section": "When Not to Use Copilot",
    "text": "When Not to Use Copilot\nDon’t use Copilot for\n\n1. Learning Fundamentals\n\nYou should understand loops, functions, and data types\n\n\n\n2. Skipping Problem-Solving\n\nFigure out the logic first, then use Copilot for syntax\n\n\n\n3. Accepting Without Understanding\n\nAsk: “Can I explain what this code does?”"
  },
  {
    "objectID": "lectures/lec_02_presentation.html#key-takeaways",
    "href": "lectures/lec_02_presentation.html#key-takeaways",
    "title": "Lecture 2 - AI Programming",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nGitHub Copilot is a tool: You still need to learn fundamentals\nUnderstand before accepting: Read every suggestion carefully\nUse it strategically: Syntax help yes, thinking replacement no\nGet free access: GitHub Student Developer Pack\nPractice:The more you use it, the more helpful it becomes\n\n\n\n\n\n\n\n\nBefore next lecture, make sure you applied for GitHub Student Developer Pack to get access to copilot!\n\n\n\n\n\n\n\n\n\n\n\nIf you run into issues, we will solve them next week together!"
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html",
    "href": "lectures/lec_04_monte_carlo.html",
    "title": "Dealing with Uncertainty",
    "section": "",
    "text": ". . .\nCEO’s Dilemma:\n“We have €2M to invest in 2 of 4 startups. Each promises great returns, but the future is uncertain. How do we make the best choice without just gambling?”\n\n\n\nQuestion: Why can’t we just pick the two startups with the highest average returns?\n. . .\n\n\nHidden Risk: A startup with 30% average return but 50% chance of failure might be worse than 20% return with 5% failure chance\nPortfolio Effects: Two risky startups together might amplify risk beyond acceptable levels\nTail Events: The worst-case scenario can matter as much as the average case\n\n\n. . .\n\n\n\n\n\n\nCommon Pitfall: Optimizing on averages ignores the distribution of outcomes.\n\n\n\n\n\n\nWhere uncertainty modeling is critical:\n\n\nNetflix Series Decisions\n\nWill a show hit 10M viewers?\nRange: 500K to 50M\nInvestment: €20M per season\n\n\nPharmaceutical R&D\n\nWill the drug pass trials?\nSuccess rate: 10-20%\nInvestment: €1B over 10 years\n\n\n\n. . .\n\n\n\n\n\n\nWhen decisions are expensive and outcomes are uncertain, Monte Carlo simulation can be helpful to reduce risk and maximize value!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#client-briefing-techventure-innovation-fund",
    "href": "lectures/lec_04_monte_carlo.html#client-briefing-techventure-innovation-fund",
    "title": "Dealing with Uncertainty",
    "section": "",
    "text": ". . .\nCEO’s Dilemma:\n“We have €2M to invest in 2 of 4 startups. Each promises great returns, but the future is uncertain. How do we make the best choice without just gambling?”",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#business-valuing-uncertainty",
    "href": "lectures/lec_04_monte_carlo.html#business-valuing-uncertainty",
    "title": "Dealing with Uncertainty",
    "section": "",
    "text": "Question: Why can’t we just pick the two startups with the highest average returns?\n. . .\n\n\nHidden Risk: A startup with 30% average return but 50% chance of failure might be worse than 20% return with 5% failure chance\nPortfolio Effects: Two risky startups together might amplify risk beyond acceptable levels\nTail Events: The worst-case scenario can matter as much as the average case\n\n\n. . .\n\n\n\n\n\n\nCommon Pitfall: Optimizing on averages ignores the distribution of outcomes.",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#real-world-examples",
    "href": "lectures/lec_04_monte_carlo.html#real-world-examples",
    "title": "Dealing with Uncertainty",
    "section": "",
    "text": "Where uncertainty modeling is critical:\n\n\nNetflix Series Decisions\n\nWill a show hit 10M viewers?\nRange: 500K to 50M\nInvestment: €20M per season\n\n\nPharmaceutical R&D\n\nWill the drug pass trials?\nSuccess rate: 10-20%\nInvestment: €1B over 10 years\n\n\n\n. . .\n\n\n\n\n\n\nWhen decisions are expensive and outcomes are uncertain, Monte Carlo simulation can be helpful to reduce risk and maximize value!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#rolling-the-dice-10000-times-i",
    "href": "lectures/lec_04_monte_carlo.html#rolling-the-dice-10000-times-i",
    "title": "Dealing with Uncertainty",
    "section": "Rolling the Dice 10,000 Times I",
    "text": "Rolling the Dice 10,000 Times I\nQuestion: If you roll two dice, what’s the probability of getting exactly 7 as result?\n. . .\nMethod 1: Math\n\nCount combinations: (1,6), (2,5), (3,4), (4,3), (5,2), (6,1)\nTotal combinations: 36\nProbability: 6/36 = 16.67%",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#rolling-the-dice-10000-times-ii",
    "href": "lectures/lec_04_monte_carlo.html#rolling-the-dice-10000-times-ii",
    "title": "Dealing with Uncertainty",
    "section": "Rolling the Dice 10,000 Times II",
    "text": "Rolling the Dice 10,000 Times II\nQuestion: If you roll two dice, what’s the probability of getting exactly 7 as result?\n. . .\nMethod 2: Simulation\n\nimport numpy as np\nnp.random.seed(42)\n\n# Roll two dice 10,000 times\ndice1 = np.random.randint(1, 7, size=10_000)\ndice2 = np.random.randint(1, 7, size=10_000)\ntotal = dice1 + dice2\n\n# What fraction equals 7?\nprobability = (total == 7).mean()\nprint(f\"Simulated probability of rolling 7: {probability:.1%}\")\n\nSimulated probability of rolling 7: 16.2%",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#how-probability-converges",
    "href": "lectures/lec_04_monte_carlo.html#how-probability-converges",
    "title": "Dealing with Uncertainty",
    "section": "How Probability Converges",
    "text": "How Probability Converges\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nAs we roll more dice, the estimated probability converges to the true value (16.7%)",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#the-law-of-large-numbers",
    "href": "lectures/lec_04_monte_carlo.html#the-law-of-large-numbers",
    "title": "Dealing with Uncertainty",
    "section": "The Law of Large Numbers",
    "text": "The Law of Large Numbers\nFundamental Principle: As sample size increases, sample average converges to the true expected value\n. . .\nIf \\(X_1, X_2, \\ldots, X_n\\) are independent random samples from the same distribution with mean \\(\\mu\\):\n\\[\\text{As } n \\to \\infty, \\quad \\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^n X_i \\to \\mu\\]\n. . .\n\n\n\n\n\n\nThis is WHY simulations works. More simulations = better estimates!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#the-central-limit-theorem",
    "href": "lectures/lec_04_monte_carlo.html#the-central-limit-theorem",
    "title": "Dealing with Uncertainty",
    "section": "The Central Limit Theorem",
    "text": "The Central Limit Theorem\nAnother Fundamental Principle: The sum of many random variables tends toward a normal distribution\n. . .\nWhat it means:\n\nEven if individual returns are NOT normally distributed…\nThe portfolio of many assets WILL be approximately normal\nThe average of many simulations WILL be approximately normal\n\n. . .\n\n\n\n\n\n\nFor Business: This is why we can use normal distributions to model portfolio returns, even when individual assets have skewed or unusual distributions!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#why-this-matters-for-business",
    "href": "lectures/lec_04_monte_carlo.html#why-this-matters-for-business",
    "title": "Dealing with Uncertainty",
    "section": "Why This Matters for Business",
    "text": "Why This Matters for Business\nQuestion: How many simulations do we need for reliable results?\n. . .\n\n# Test convergence with different sample sizes\nsample_sizes = [10, 100, 1000, 10000, 100000]\nestimates = []\n\nfor n in sample_sizes:\n    dice1 = np.random.randint(1, 7, size=n)\n    dice2 = np.random.randint(1, 7, size=n)\n    total = dice1 + dice2\n    prob = (total == 7).mean()\n    estimates.append(prob)\n    print(f\"n={n:6d}: Estimated probability = {prob:.4f}\")\n\nn=    10: Estimated probability = 0.2000\nn=   100: Estimated probability = 0.1900\nn=  1000: Estimated probability = 0.1480\nn= 10000: Estimated probability = 0.1652\nn=100000: Estimated probability = 0.1670",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#practical-guidelines",
    "href": "lectures/lec_04_monte_carlo.html#practical-guidelines",
    "title": "Dealing with Uncertainty",
    "section": "Practical Guidelines",
    "text": "Practical Guidelines\nHow many simulations should you run?\n\n\nQuick exploration: 10,000 simulations\n\nGood for initial insights, prototyping\n\nCritical decisions: 100,000+ simulations\n\nFinancial risk models, regulatory compliance\n\nWhen to stop: When more simulations don’t change conclusion\n\n\n. . .\n\n\n\n\n\n\nIf your decision changes with 10x more simulations, you didn’t run enough!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#the-monte-carlo-method",
    "href": "lectures/lec_04_monte_carlo.html#the-monte-carlo-method",
    "title": "Dealing with Uncertainty",
    "section": "The Monte Carlo Method",
    "text": "The Monte Carlo Method\nThree Simple Steps:\n\n\nModel the Uncertainty:\n\nDefine probability distributions for unknown variables\n\nSimulate Many Scenarios:\n\nGenerate thousands of possible outcomes\n\nAnalyze the Results:\n\nCalculate statistics from the simulation\n\n\n\n. . .\n\n\n\n\n\n\nMonte Carlo Casino in Monaco inspired the method’s development in the 1940s.",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#step-1-model-the-uncertainty",
    "href": "lectures/lec_04_monte_carlo.html#step-1-model-the-uncertainty",
    "title": "Dealing with Uncertainty",
    "section": "Step 1: Model the Uncertainty",
    "text": "Step 1: Model the Uncertainty\nKey Function: np.random.normal(loc, scale, size)\n\nloc: The center (mean/average)\nscale: The spread (standard deviation)\nsize: How many samples to generate\n\n. . .\n\n# AI-Growth: average 38% return, ±25% volatility\nreturns = np.random.normal(loc=0.38, scale=0.25, size=10_000)\nprint(f\"Mean return: {returns.mean():.1%}\")\nprint(f\"Std deviation: {returns.std():.1%}\")\nprint(f\"Minimum: {returns.min():.1%}\")\nprint(f\"Maximum: {returns.max():.1%}\")\n\nMean return: 38.8%\nStd deviation: 24.8%\nMinimum: -67.0%\nMaximum: 125.7%",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#expected-returns",
    "href": "lectures/lec_04_monte_carlo.html#expected-returns",
    "title": "Dealing with Uncertainty",
    "section": "Expected Returns",
    "text": "Expected Returns\nLet’s calculate percentiles with np.percentile().\n. . .\nQuestion: Do you still know what a percentile is?\n. . .\n\nprint(f\"\\nPercentiles:\")\nprint(f\"  5th: {np.percentile(returns, 5):.1%} (worst 5% of scenarios)\")\nprint(f\" 25th: {np.percentile(returns, 25):.1%} (worst 25% of scenarios)\")\nprint(f\" 50th: {np.percentile(returns, 50):.1%} (median)\")\nprint(f\" 75th: {np.percentile(returns, 75):.1%} (best 25% of scenarios)\")\nprint(f\" 95th: {np.percentile(returns, 95):.1%} (best 5% of scenarios)\")\n\n\nPercentiles:\n  5th: -2.7% (worst 5% of scenarios)\n 25th: 22.1% (worst 25% of scenarios)\n 50th: 38.9% (median)\n 75th: 55.7% (best 25% of scenarios)\n 95th: 78.6% (best 5% of scenarios)",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#understanding-the-distribution",
    "href": "lectures/lec_04_monte_carlo.html#understanding-the-distribution",
    "title": "Dealing with Uncertainty",
    "section": "Understanding the Distribution",
    "text": "Understanding the Distribution\nQuestion: Before we plot, what shape do you expect for np.random.normal()?\n. . .",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#risk-analysis",
    "href": "lectures/lec_04_monte_carlo.html#risk-analysis",
    "title": "Dealing with Uncertainty",
    "section": "Risk Analysis",
    "text": "Risk Analysis\nQuestion: What’s the probability that AI-Growth loses money?\n. . .\n\n# Calculate risk metrics\nprob_loss = (returns &lt; 0).mean() # proportion of returns that are less than zero\nprob_double = (returns &gt; 1.0).mean()  # proportion greater than 100%\n\nprint(f\"Probability of loss: {prob_loss:.1%}\")\nprint(f\"Probability of doubling money: {prob_double:.1%}\")\n\nProbability of loss: 6.0%\nProbability of doubling money: 0.8%\n\n\n. . .\n\n\n\n\n\n\nWith 6 % chance of loss, AI-Growth is relatively safe. Easy for one startup, right?",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#different-distributions",
    "href": "lectures/lec_04_monte_carlo.html#different-distributions",
    "title": "Dealing with Uncertainty",
    "section": "Different Distributions",
    "text": "Different Distributions\nAttention: Not everything follows a normal distribution!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#overview",
    "href": "lectures/lec_04_monte_carlo.html#overview",
    "title": "Dealing with Uncertainty",
    "section": "Overview",
    "text": "Overview\n\nNormalUniformExponential\n\n\n\n# Most common in nature/business\n# Bell-shaped, symmetric\nreturns = np.random.normal(mean, std, size)\n\n# Example: CloudAI startup returns\ncloudai = np.random.normal(0.25, 0.15, 10000)  # 25% ± 15%\n\nMain Characteristics:\n\nSymmetric bell curve\nMost values cluster around mean\nCommon in nature and business\n\n\n\n\n# Equal probability across range\n# Example: FinFlow returns between 10-35%\nreturns = np.random.uniform(0.10, 0.35, size)\n\n# Example: FinFlow startup returns\nfinflow = np.random.uniform(0.10, 0.35, 10000)  # 10-35% equally likely\n\nMain Characteristics:\n\nAll values equally likely\nHard boundaries (min/max)\nGood for modeling complete uncertainty within range\n\n\n\n\n# Time between events\n# Example: Customer arrivals, equipment failure\ntimes = np.random.exponential(scale, size)\n\n# Example: Time between customer arrivals (minutes)\narrivals = np.random.exponential(5, 10000)  # Average 5 minutes\n\nMain Characteristics:\n\nMany small values, few large ones\nAlways positive\nCommon for waiting times and rare events",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#combining-investments",
    "href": "lectures/lec_04_monte_carlo.html#combining-investments",
    "title": "Dealing with Uncertainty",
    "section": "Combining Investments",
    "text": "Combining Investments\nSuppose we have the following startups:\nCloudAI, GreenGrid, HealthTrack, FinFlow\n. . .\nQuestion: If we must pick 2 of 4, how many unique pairs exist?\n. . .\nThe Math:\n\\[\\binom{4}{2} = \\frac{4!}{2! \\times 2!} = \\frac{4 \\times 3 \\times 2 \\times 1}{(2 \\times 1) \\times (2 \\times 1)} = \\frac{24}{4} = 6\\]\n. . .\n\n\n\n\n\n\nEach combination has different risk-return characteristics!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#four-startup-profiles",
    "href": "lectures/lec_04_monte_carlo.html#four-startup-profiles",
    "title": "Dealing with Uncertainty",
    "section": "Four Startup Profiles",
    "text": "Four Startup Profiles\n\n\n\n\n\n\n\n\n\n. . .\nQuestion: Which startup is the best choice?",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#key-metrics-for-decision-making",
    "href": "lectures/lec_04_monte_carlo.html#key-metrics-for-decision-making",
    "title": "Dealing with Uncertainty",
    "section": "Key Metrics for Decision Making",
    "text": "Key Metrics for Decision Making\nQuestion: Which metrics matter most for investment decisions?\n\n\nExpected Return: Average outcome across all scenarios\nVolatility (Risk): Standard deviation of returns\nProbability of Loss: How often do we lose money?\nUpside Potential: Chance of exceptional returns (&gt;50%)\nTail Risk: What happens in the worst 10% of cases?\n\n\n. . .\n\n\n\n\n\n\nNo metric tells the whole story. Investors consider multiple dimensions of risk and return.",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#understanding-tail-risk",
    "href": "lectures/lec_04_monte_carlo.html#understanding-tail-risk",
    "title": "Dealing with Uncertainty",
    "section": "Understanding Tail Risk",
    "text": "Understanding Tail Risk\nTail Risk: The danger lurking in worst-case scenarios\nExpected Shortfall (ES)\n\nAverage loss in worst X% of cases\nGoes beyond simple probability\nMeasures depth of potential losses\nCritical for risk management\n\n. . .\n\n\n\n\n\n\nA portfolio with higher average returns might have catastrophic tail risk. Always look at the extremes!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#the-independence-assumption",
    "href": "lectures/lec_04_monte_carlo.html#the-independence-assumption",
    "title": "Dealing with Uncertainty",
    "section": "The Independence Assumption",
    "text": "The Independence Assumption\nSo far, we’ve assumed startups succeed or fail independently.\n. . .\nIndependent Events:\n\nCloudAI’s success doesn’t affect GreenGrid’s success\nEach startup faces separate, unrelated risks\nPortfolio risk = Average of individual risks\n\n. . .\nQuestion: Is this realistic in the real world?\n. . .\n\n\n\n\n\n\nReality Check: Many business risks are correlated! Economic downturns, market trends, and technology shifts affect multiple companies simultaneously.",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#what-is-correlation",
    "href": "lectures/lec_04_monte_carlo.html#what-is-correlation",
    "title": "Dealing with Uncertainty",
    "section": "What is Correlation?",
    "text": "What is Correlation?\nCorrelation measures how two variables move together.\n\\[\\rho_{X,Y} = \\frac{\\text{Cov}(X,Y)}{\\sigma_X \\sigma_Y} \\quad \\text{where } -1 \\leq \\rho \\leq 1\\]\n. . .\nInterpreting Correlation:\n\nρ = +1: Perfect positive correlation (move together)\nρ = 0: No correlation (independent)\nρ = -1: Perfect negative correlation (move opposite)",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#correlation-in-practice",
    "href": "lectures/lec_04_monte_carlo.html#correlation-in-practice",
    "title": "Dealing with Uncertainty",
    "section": "Correlation in Practice",
    "text": "Correlation in Practice\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nIn Python: np.corrcoef(returns1, returns2) calculates correlation",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#why-correlation-matters",
    "href": "lectures/lec_04_monte_carlo.html#why-correlation-matters",
    "title": "Dealing with Uncertainty",
    "section": "Why Correlation Matters",
    "text": "Why Correlation Matters\nTwo AI startups in your portfolio:\nScenario 1: Independent (ρ = 0)\n\nOne fails due to technical issues, other succeeds\nRisk is averaged out\n\nScenario 2: Positively Correlated (ρ = 0.8)\n\nBoth rely on same AI infrastructure provider - risk is amplified!\n\n. . .\n\n\n\n\n\n\nDiversification only reduces risk when investments are not highly correlated!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#impact-on-portfolio-risk",
    "href": "lectures/lec_04_monte_carlo.html#impact-on-portfolio-risk",
    "title": "Dealing with Uncertainty",
    "section": "Impact on Portfolio Risk",
    "text": "Impact on Portfolio Risk\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nHigher correlation = Wider distribution = More risk!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#real-world-correlation-examples",
    "href": "lectures/lec_04_monte_carlo.html#real-world-correlation-examples",
    "title": "Dealing with Uncertainty",
    "section": "Real-World Correlation Examples",
    "text": "Real-World Correlation Examples\nCommon sources of correlation in business:\n\n\nIndustry-specific: All tech startups affected by downturn\nGeographic: All European companies affected by EU regulations\nSupply chain: Multiple companies relying on same supplier\nMacroeconomic: Interest rates, inflation affect most businesses\n\n\n. . .\n\n\n\n\n\n\nDiversification: Choose investments with LOW correlation to reduce portfolio risk!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#when-diversification-fails",
    "href": "lectures/lec_04_monte_carlo.html#when-diversification-fails",
    "title": "Dealing with Uncertainty",
    "section": "When Diversification Fails",
    "text": "When Diversification Fails\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\n2008 Financial Crisis: Many “diversified” portfolios collapsed due to correlations!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#when-to-use-monte-carlo",
    "href": "lectures/lec_04_monte_carlo.html#when-to-use-monte-carlo",
    "title": "Dealing with Uncertainty",
    "section": "When to Use Monte Carlo",
    "text": "When to Use Monte Carlo\nQuestion: For our simple startup examples so far, do we really NEED Monte Carlo?\n. . .\nShort answer: No! For basic mean/variance calculations, we can use analytical formulas.\n. . .\nSo when is Monte Carlo truly necessary?",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#necessary-vs.-convenient",
    "href": "lectures/lec_04_monte_carlo.html#necessary-vs.-convenient",
    "title": "Dealing with Uncertainty",
    "section": "Necessary vs. Convenient",
    "text": "Necessary vs. Convenient\nYou can use math (analytical solutions):\n\n\nSimple distributions: Mean and variance of normal distributions\nLinear combinations: Portfolio of independent assets\n\n\n. . .\nYou NEED Monte Carlo when:\n\n\nComplex dependencies: Nonlinear relationships\nPath-dependent problems: Outcome depends on a sequence\nNo closed-form solution: The math is intractable",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications",
    "href": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications",
    "text": "Real Monte Carlo Applications\nWhere Monte Carlo is ESSENTIAL, not just convenient:\n1. Option Pricing with Path Dependencies\n\n# Payoff depends on AVERAGE price over time\nn_simulations = 10000; strike_price = 105; payoffs = []\nfor sim in range(n_simulations):\n    prices = [100]  # Starting price\n    for day in range(365):\n        prices.append(prices[-1] * (1 + np.random.normal(0.001, 0.02)))\n    payoff = max(0, np.mean(prices) - strike_price)\n    payoffs.append(payoff)\npayoffs = np.array(payoffs)\nprint(f\"Average option value: ${payoffs.mean():.2f}\")\nprint(f\"Probability of profit: {(payoffs &gt; 0).mean():.1%}\")\n\nAverage option value: $19.58\nProbability of profit: 68.9%",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-ii",
    "href": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-ii",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications II",
    "text": "Real Monte Carlo Applications II",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-iii",
    "href": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-iii",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications III",
    "text": "Real Monte Carlo Applications III\n2. Supply Chain with Cascading Effects\n\n# Each stage affects the next (nonlinear dependencies)\nn_simulations = 10000; factory_capacity = 150; demand = 120; price = 5\npenalty = 10; revenues = []\n\nfor sim in range(n_simulations):\n    parts_delivered = np.random.poisson(100)\n    production = min(parts_delivered, factory_capacity)\n    if production &gt;= demand:\n        revenue = demand * price\n    else:\n        revenue = production * price - penalty\n    revenues.append(revenue)\n\nrevenues = np.array(revenues)\nprint(f\"Average revenue: ${revenues.mean():.2f}\")\nprint(f\"Worst-case revenue: ${revenues.min():.2f}\")\n\nAverage revenue: $489.22\nWorst-case revenue: $325.00",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-iv",
    "href": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-iv",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications IV",
    "text": "Real Monte Carlo Applications IV",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-v",
    "href": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-v",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications V",
    "text": "Real Monte Carlo Applications V\n3. Project Management with Sequential Risks\n\n# Project phases must happen in order, later phases only if earlier succeed\nn_simulations = 10000; shape = 2; scale = 10; project_times = []\n\nfor sim in range(n_simulations):\n    total_time = 0\n    for phase in ['design', 'build', 'test', 'deploy']:\n        # Each phase has uncertain duration\n        phase_time = np.random.gamma(shape, scale)\n        total_time += phase_time\n        if np.random.random() &lt; 0.1:\n            total_time += phase_time * 0.5  # Rework time\n    project_times.append(total_time)\n\nproject_times = np.array(project_times)\nprint(f\"Average project duration: {project_times.mean():.1f} days\")\nprint(f\"90th percentile: {np.percentile(project_times, 90):.1f} days\")\n\nAverage project duration: 84.3 days\n90th percentile: 125.2 days",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-vi",
    "href": "lectures/lec_04_monte_carlo.html#real-monte-carlo-applications-vi",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications VI",
    "text": "Real Monte Carlo Applications VI",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#example-why-still-useful",
    "href": "lectures/lec_04_monte_carlo.html#example-why-still-useful",
    "title": "Dealing with Uncertainty",
    "section": "Example: Why Still Useful?",
    "text": "Example: Why Still Useful?\nQuestion: If we can calculate variance analytically, why simulate?\n. . .\n\n\nVisualization: Seeing the full distribution is intuitive\nFlexibility: When problems become complex, simulation adapts\nExtensions: Practice for complex problem\n\n\n. . .\n\n\n\n\n\n\nThink of our examples as learning the tool on simple problems so you can solve complex ones where Monte Carlo is required!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#when-not-to-use-monte-carlo",
    "href": "lectures/lec_04_monte_carlo.html#when-not-to-use-monte-carlo",
    "title": "Dealing with Uncertainty",
    "section": "When NOT to Use Monte Carlo",
    "text": "When NOT to Use Monte Carlo\nEven when you CAN use Monte Carlo, sometimes you shouldn’t:\n. . .\n\n\nSimple analytical solution exists and suffices\n\nUse math directly: faster, more precise, easier to understand\n\nCan’t reasonably estimate input distributions\n\nGarbage in = garbage out; need solid basis for assumptions\n\nProblem is deterministic (no uncertainty)\n\nSimulation adds complexity without value\n\n\n\n. . .\n\n\n\n\n\n\nSimulation is a tool for managing uncertainty, not creating false precision!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#decision-framework",
    "href": "lectures/lec_04_monte_carlo.html#decision-framework",
    "title": "Dealing with Uncertainty",
    "section": "Decision Framework",
    "text": "Decision Framework\n\nDefine Your Risk Tolerance\n\nCan you afford to lose money and what’s your time horizon?\nAre you risk-averse or risk-seeking?\n\nEvaluate Multiple Metrics\n\nDon’t just maximize returns, consider volatility and risk\nLook at probability of achieving goals\n\nScenario Test\n\nWhat if distributions change or a company fails?",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#the-plan-for-the-day",
    "href": "lectures/lec_04_monte_carlo.html#the-plan-for-the-day",
    "title": "Dealing with Uncertainty",
    "section": "The Plan for the Day",
    "text": "The Plan for the Day\n\n\nHour 1:\nLecture\n\nConcepts\nExamples\nVisualization\n\n\nHour 2:\nPractice Notebook\n\nSimulation\nHands-on coding\nBuild your skills\n\n\nHours 3-4:\nCompetition\n\nTechVenture\nTeam collaboration\n€2M investment\n\n\n\n. . .\nRemember: The lecture gives you concepts. The notebook gives you practice. The competition tests your skills!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#hour-2-simulation",
    "href": "lectures/lec_04_monte_carlo.html#hour-2-simulation",
    "title": "Dealing with Uncertainty",
    "section": "Hour 2: Simulation",
    "text": "Hour 2: Simulation\nYour Practice Case: Bean Counter Expansion\n\nModel uncertain variables (customers, spending)\nCombine multiple uncertainties\nCalculate business metrics (VaR, profit probability)\nMake data-driven recommendations",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#hours-3-4-the-challenge",
    "href": "lectures/lec_04_monte_carlo.html#hours-3-4-the-challenge",
    "title": "Dealing with Uncertainty",
    "section": "Hours 3-4: The Challenge",
    "text": "Hours 3-4: The Challenge\nTechVenture Investment Competition\n\n\nYour Budget: €2 million\nYour Choice: Pick 2 of 4 startups\nYour Goal: Maximize risk-adjusted returns\nYour Deliverable: One-slide recommendation + 3-minute pitch\n\n\n. . .\n\nConsider multiple risk metrics and prepare a clear justification!\n\n. . .\nPrizes: 10 / 6 / 3 bonus points for top three teams!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#what-youve-learned-today",
    "href": "lectures/lec_04_monte_carlo.html#what-youve-learned-today",
    "title": "Dealing with Uncertainty",
    "section": "What You’ve Learned Today",
    "text": "What You’ve Learned Today\n\n\nConcepts\n\nMonte Carlo simulation\nProbability distributions\nRisk has multiple dimensions\nExpected Value vs. Variance\nCorrelation and dependence\n\n\nSkills\n\nUsing np.random for simulation\nCalculating risk metrics\nVisualizing uncertainty\nComparing portfolios\nUnderstanding correlation\n\n\n\n. . .\n\n\n\n\n\n\nMonte Carlo doesn’t predict THE future - it shows possible futures! And correlation can amplify or reduce risk!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_monte_carlo.html#next-week",
    "href": "lectures/lec_04_monte_carlo.html#next-week",
    "title": "Dealing with Uncertainty",
    "section": "Next Week",
    "text": "Next Week\nForecasting the Future\n\nMoving from simulation to prediction\nTime series analysis\nTrend and seasonality detection\nMeasuring forecast accuracy\n\n. . .\nNow, short break and then we start coding!",
    "crumbs": [
      "04 Monte Carlo",
      "04 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_04_presentation.html#client-briefing-techventure-innovation-fund",
    "href": "lectures/lec_04_presentation.html#client-briefing-techventure-innovation-fund",
    "title": "Dealing with Uncertainty",
    "section": "Client Briefing: TechVenture Innovation Fund",
    "text": "Client Briefing: TechVenture Innovation Fund\n\nCEO’s Dilemma:\n“We have €2M to invest in 2 of 4 startups. Each promises great returns, but the future is uncertain. How do we make the best choice without just gambling?”"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#business-valuing-uncertainty",
    "href": "lectures/lec_04_presentation.html#business-valuing-uncertainty",
    "title": "Dealing with Uncertainty",
    "section": "Business: Valuing Uncertainty",
    "text": "Business: Valuing Uncertainty\nQuestion: Why can’t we just pick the two startups with the highest average returns?\n\n\nHidden Risk: A startup with 30% average return but 50% chance of failure might be worse than 20% return with 5% failure chance\nPortfolio Effects: Two risky startups together might amplify risk beyond acceptable levels\nTail Events: The worst-case scenario can matter as much as the average case\n\n\n\n\n\n\n\n\n\nCommon Pitfall: Optimizing on averages ignores the distribution of outcomes."
  },
  {
    "objectID": "lectures/lec_04_presentation.html#real-world-examples",
    "href": "lectures/lec_04_presentation.html#real-world-examples",
    "title": "Dealing with Uncertainty",
    "section": "Real-World Examples",
    "text": "Real-World Examples\nWhere uncertainty modeling is critical:\n\n\nNetflix Series Decisions\n\nWill a show hit 10M viewers?\nRange: 500K to 50M\nInvestment: €20M per season\n\n\nPharmaceutical R&D\n\nWill the drug pass trials?\nSuccess rate: 10-20%\nInvestment: €1B over 10 years\n\n\n\n\n\n\n\n\n\nWhen decisions are expensive and outcomes are uncertain, Monte Carlo simulation can be helpful to reduce risk and maximize value!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#rolling-the-dice-10000-times-i",
    "href": "lectures/lec_04_presentation.html#rolling-the-dice-10000-times-i",
    "title": "Dealing with Uncertainty",
    "section": "Rolling the Dice 10,000 Times I",
    "text": "Rolling the Dice 10,000 Times I\nQuestion: If you roll two dice, what’s the probability of getting exactly 7 as result?\n\nMethod 1: Math\n\nCount combinations: (1,6), (2,5), (3,4), (4,3), (5,2), (6,1)\nTotal combinations: 36\nProbability: 6/36 = 16.67%"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#rolling-the-dice-10000-times-ii",
    "href": "lectures/lec_04_presentation.html#rolling-the-dice-10000-times-ii",
    "title": "Dealing with Uncertainty",
    "section": "Rolling the Dice 10,000 Times II",
    "text": "Rolling the Dice 10,000 Times II\nQuestion: If you roll two dice, what’s the probability of getting exactly 7 as result?\n\nMethod 2: Simulation\n\nimport numpy as np\nnp.random.seed(42)\n\n# Roll two dice 10,000 times\ndice1 = np.random.randint(1, 7, size=10_000)\ndice2 = np.random.randint(1, 7, size=10_000)\ntotal = dice1 + dice2\n\n# What fraction equals 7?\nprobability = (total == 7).mean()\nprint(f\"Simulated probability of rolling 7: {probability:.1%}\")\n\n\n\nSimulated probability of rolling 7: 16.2%"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#how-probability-converges",
    "href": "lectures/lec_04_presentation.html#how-probability-converges",
    "title": "Dealing with Uncertainty",
    "section": "How Probability Converges",
    "text": "How Probability Converges\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs we roll more dice, the estimated probability converges to the true value (16.7%)"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#the-law-of-large-numbers",
    "href": "lectures/lec_04_presentation.html#the-law-of-large-numbers",
    "title": "Dealing with Uncertainty",
    "section": "The Law of Large Numbers",
    "text": "The Law of Large Numbers\nFundamental Principle: As sample size increases, sample average converges to the true expected value\n\nIf \\(X_1, X_2, \\ldots, X_n\\) are independent random samples from the same distribution with mean \\(\\mu\\):\n\\[\\text{As } n \\to \\infty, \\quad \\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^n X_i \\to \\mu\\]\n\n\n\n\n\n\n\n\nThis is WHY simulations works. More simulations = better estimates!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#the-central-limit-theorem",
    "href": "lectures/lec_04_presentation.html#the-central-limit-theorem",
    "title": "Dealing with Uncertainty",
    "section": "The Central Limit Theorem",
    "text": "The Central Limit Theorem\nAnother Fundamental Principle: The sum of many random variables tends toward a normal distribution\n\nWhat it means:\n\nEven if individual returns are NOT normally distributed…\nThe portfolio of many assets WILL be approximately normal\nThe average of many simulations WILL be approximately normal\n\n\n\n\n\n\n\n\n\nFor Business: This is why we can use normal distributions to model portfolio returns, even when individual assets have skewed or unusual distributions!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#why-this-matters-for-business",
    "href": "lectures/lec_04_presentation.html#why-this-matters-for-business",
    "title": "Dealing with Uncertainty",
    "section": "Why This Matters for Business",
    "text": "Why This Matters for Business\nQuestion: How many simulations do we need for reliable results?\n\n\n# Test convergence with different sample sizes\nsample_sizes = [10, 100, 1000, 10000, 100000]\nestimates = []\n\nfor n in sample_sizes:\n    dice1 = np.random.randint(1, 7, size=n)\n    dice2 = np.random.randint(1, 7, size=n)\n    total = dice1 + dice2\n    prob = (total == 7).mean()\n    estimates.append(prob)\n    print(f\"n={n:6d}: Estimated probability = {prob:.4f}\")\n\n\n\nn=    10: Estimated probability = 0.2000\nn=   100: Estimated probability = 0.1900\nn=  1000: Estimated probability = 0.1480\nn= 10000: Estimated probability = 0.1652\nn=100000: Estimated probability = 0.1670"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#practical-guidelines",
    "href": "lectures/lec_04_presentation.html#practical-guidelines",
    "title": "Dealing with Uncertainty",
    "section": "Practical Guidelines",
    "text": "Practical Guidelines\nHow many simulations should you run?\n\nQuick exploration: 10,000 simulations\n\nGood for initial insights, prototyping\n\nCritical decisions: 100,000+ simulations\n\nFinancial risk models, regulatory compliance\n\nWhen to stop: When more simulations don’t change conclusion\n\n\n\n\n\n\n\n\nIf your decision changes with 10x more simulations, you didn’t run enough!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#the-monte-carlo-method",
    "href": "lectures/lec_04_presentation.html#the-monte-carlo-method",
    "title": "Dealing with Uncertainty",
    "section": "The Monte Carlo Method",
    "text": "The Monte Carlo Method\nThree Simple Steps:\n\nModel the Uncertainty:\n\nDefine probability distributions for unknown variables\n\nSimulate Many Scenarios:\n\nGenerate thousands of possible outcomes\n\nAnalyze the Results:\n\nCalculate statistics from the simulation\n\n\n\n\n\n\n\n\n\nMonte Carlo Casino in Monaco inspired the method’s development in the 1940s."
  },
  {
    "objectID": "lectures/lec_04_presentation.html#step-1-model-the-uncertainty",
    "href": "lectures/lec_04_presentation.html#step-1-model-the-uncertainty",
    "title": "Dealing with Uncertainty",
    "section": "Step 1: Model the Uncertainty",
    "text": "Step 1: Model the Uncertainty\nKey Function: np.random.normal(loc, scale, size)\n\nloc: The center (mean/average)\nscale: The spread (standard deviation)\nsize: How many samples to generate\n\n\n\n# AI-Growth: average 38% return, ±25% volatility\nreturns = np.random.normal(loc=0.38, scale=0.25, size=10_000)\nprint(f\"Mean return: {returns.mean():.1%}\")\nprint(f\"Std deviation: {returns.std():.1%}\")\nprint(f\"Minimum: {returns.min():.1%}\")\nprint(f\"Maximum: {returns.max():.1%}\")\n\n\n\nMean return: 38.8%\nStd deviation: 24.8%\nMinimum: -67.0%\nMaximum: 125.7%"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#expected-returns",
    "href": "lectures/lec_04_presentation.html#expected-returns",
    "title": "Dealing with Uncertainty",
    "section": "Expected Returns",
    "text": "Expected Returns\nLet’s calculate percentiles with np.percentile().\n\nQuestion: Do you still know what a percentile is?\n\n\n\nprint(f\"\\nPercentiles:\")\nprint(f\"  5th: {np.percentile(returns, 5):.1%} (worst 5% of scenarios)\")\nprint(f\" 25th: {np.percentile(returns, 25):.1%} (worst 25% of scenarios)\")\nprint(f\" 50th: {np.percentile(returns, 50):.1%} (median)\")\nprint(f\" 75th: {np.percentile(returns, 75):.1%} (best 25% of scenarios)\")\nprint(f\" 95th: {np.percentile(returns, 95):.1%} (best 5% of scenarios)\")\n\n\n\n\nPercentiles:\n  5th: -2.7% (worst 5% of scenarios)\n 25th: 22.1% (worst 25% of scenarios)\n 50th: 38.9% (median)\n 75th: 55.7% (best 25% of scenarios)\n 95th: 78.6% (best 5% of scenarios)"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#understanding-the-distribution",
    "href": "lectures/lec_04_presentation.html#understanding-the-distribution",
    "title": "Dealing with Uncertainty",
    "section": "Understanding the Distribution",
    "text": "Understanding the Distribution\nQuestion: Before we plot, what shape do you expect for np.random.normal()?"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#risk-analysis",
    "href": "lectures/lec_04_presentation.html#risk-analysis",
    "title": "Dealing with Uncertainty",
    "section": "Risk Analysis",
    "text": "Risk Analysis\nQuestion: What’s the probability that AI-Growth loses money?\n\n\n# Calculate risk metrics\nprob_loss = (returns &lt; 0).mean() # proportion of returns that are less than zero\nprob_double = (returns &gt; 1.0).mean()  # proportion greater than 100%\n\nprint(f\"Probability of loss: {prob_loss:.1%}\")\nprint(f\"Probability of doubling money: {prob_double:.1%}\")\n\n\n\nProbability of loss: 6.0%\nProbability of doubling money: 0.8%\n\n\n\n\n\n\n\n\n\n\nWith 6 % chance of loss, AI-Growth is relatively safe. Easy for one startup, right?"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#different-distributions",
    "href": "lectures/lec_04_presentation.html#different-distributions",
    "title": "Dealing with Uncertainty",
    "section": "Different Distributions",
    "text": "Different Distributions\nAttention: Not everything follows a normal distribution!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#overview",
    "href": "lectures/lec_04_presentation.html#overview",
    "title": "Dealing with Uncertainty",
    "section": "Overview",
    "text": "Overview\n\nNormalUniformExponential\n\n\n\n# Most common in nature/business\n# Bell-shaped, symmetric\nreturns = np.random.normal(mean, std, size)\n\n# Example: CloudAI startup returns\ncloudai = np.random.normal(0.25, 0.15, 10000)  # 25% ± 15%\n\nMain Characteristics:\n\nSymmetric bell curve\nMost values cluster around mean\nCommon in nature and business\n\n\n\n\n# Equal probability across range\n# Example: FinFlow returns between 10-35%\nreturns = np.random.uniform(0.10, 0.35, size)\n\n# Example: FinFlow startup returns\nfinflow = np.random.uniform(0.10, 0.35, 10000)  # 10-35% equally likely\n\nMain Characteristics:\n\nAll values equally likely\nHard boundaries (min/max)\nGood for modeling complete uncertainty within range\n\n\n\n\n# Time between events\n# Example: Customer arrivals, equipment failure\ntimes = np.random.exponential(scale, size)\n\n# Example: Time between customer arrivals (minutes)\narrivals = np.random.exponential(5, 10000)  # Average 5 minutes\n\nMain Characteristics:\n\nMany small values, few large ones\nAlways positive\nCommon for waiting times and rare events"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#combining-investments",
    "href": "lectures/lec_04_presentation.html#combining-investments",
    "title": "Dealing with Uncertainty",
    "section": "Combining Investments",
    "text": "Combining Investments\nSuppose we have the following startups:\nCloudAI, GreenGrid, HealthTrack, FinFlow\n\nQuestion: If we must pick 2 of 4, how many unique pairs exist?\n\n\nThe Math:\n\\[\\binom{4}{2} = \\frac{4!}{2! \\times 2!} = \\frac{4 \\times 3 \\times 2 \\times 1}{(2 \\times 1) \\times (2 \\times 1)} = \\frac{24}{4} = 6\\]\n\n\n\n\n\n\n\n\nEach combination has different risk-return characteristics!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#four-startup-profiles",
    "href": "lectures/lec_04_presentation.html#four-startup-profiles",
    "title": "Dealing with Uncertainty",
    "section": "Four Startup Profiles",
    "text": "Four Startup Profiles\n\n\n\n\n\n\n\n\n\n\nQuestion: Which startup is the best choice?"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#key-metrics-for-decision-making",
    "href": "lectures/lec_04_presentation.html#key-metrics-for-decision-making",
    "title": "Dealing with Uncertainty",
    "section": "Key Metrics for Decision Making",
    "text": "Key Metrics for Decision Making\nQuestion: Which metrics matter most for investment decisions?\n\nExpected Return: Average outcome across all scenarios\nVolatility (Risk): Standard deviation of returns\nProbability of Loss: How often do we lose money?\nUpside Potential: Chance of exceptional returns (&gt;50%)\nTail Risk: What happens in the worst 10% of cases?\n\n\n\n\n\n\n\n\nNo metric tells the whole story. Investors consider multiple dimensions of risk and return."
  },
  {
    "objectID": "lectures/lec_04_presentation.html#understanding-tail-risk",
    "href": "lectures/lec_04_presentation.html#understanding-tail-risk",
    "title": "Dealing with Uncertainty",
    "section": "Understanding Tail Risk",
    "text": "Understanding Tail Risk\nTail Risk: The danger lurking in worst-case scenarios\nExpected Shortfall (ES)\n\nAverage loss in worst X% of cases\nGoes beyond simple probability\nMeasures depth of potential losses\nCritical for risk management\n\n\n\n\n\n\n\n\nA portfolio with higher average returns might have catastrophic tail risk. Always look at the extremes!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#the-independence-assumption",
    "href": "lectures/lec_04_presentation.html#the-independence-assumption",
    "title": "Dealing with Uncertainty",
    "section": "The Independence Assumption",
    "text": "The Independence Assumption\nSo far, we’ve assumed startups succeed or fail independently.\n\nIndependent Events:\n\nCloudAI’s success doesn’t affect GreenGrid’s success\nEach startup faces separate, unrelated risks\nPortfolio risk = Average of individual risks\n\n\n\nQuestion: Is this realistic in the real world?\n\n\n\n\n\n\n\n\nReality Check: Many business risks are correlated! Economic downturns, market trends, and technology shifts affect multiple companies simultaneously."
  },
  {
    "objectID": "lectures/lec_04_presentation.html#what-is-correlation",
    "href": "lectures/lec_04_presentation.html#what-is-correlation",
    "title": "Dealing with Uncertainty",
    "section": "What is Correlation?",
    "text": "What is Correlation?\nCorrelation measures how two variables move together.\n\\[\\rho_{X,Y} = \\frac{\\text{Cov}(X,Y)}{\\sigma_X \\sigma_Y} \\quad \\text{where } -1 \\leq \\rho \\leq 1\\]\n\nInterpreting Correlation:\n\nρ = +1: Perfect positive correlation (move together)\nρ = 0: No correlation (independent)\nρ = -1: Perfect negative correlation (move opposite)"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#correlation-in-practice",
    "href": "lectures/lec_04_presentation.html#correlation-in-practice",
    "title": "Dealing with Uncertainty",
    "section": "Correlation in Practice",
    "text": "Correlation in Practice\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn Python: np.corrcoef(returns1, returns2) calculates correlation"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#why-correlation-matters",
    "href": "lectures/lec_04_presentation.html#why-correlation-matters",
    "title": "Dealing with Uncertainty",
    "section": "Why Correlation Matters",
    "text": "Why Correlation Matters\nTwo AI startups in your portfolio:\nScenario 1: Independent (ρ = 0)\n\nOne fails due to technical issues, other succeeds\nRisk is averaged out\n\nScenario 2: Positively Correlated (ρ = 0.8)\n\nBoth rely on same AI infrastructure provider - risk is amplified!\n\n\n\n\n\n\n\n\nDiversification only reduces risk when investments are not highly correlated!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#impact-on-portfolio-risk",
    "href": "lectures/lec_04_presentation.html#impact-on-portfolio-risk",
    "title": "Dealing with Uncertainty",
    "section": "Impact on Portfolio Risk",
    "text": "Impact on Portfolio Risk\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHigher correlation = Wider distribution = More risk!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#real-world-correlation-examples",
    "href": "lectures/lec_04_presentation.html#real-world-correlation-examples",
    "title": "Dealing with Uncertainty",
    "section": "Real-World Correlation Examples",
    "text": "Real-World Correlation Examples\nCommon sources of correlation in business:\n\nIndustry-specific: All tech startups affected by downturn\nGeographic: All European companies affected by EU regulations\nSupply chain: Multiple companies relying on same supplier\nMacroeconomic: Interest rates, inflation affect most businesses\n\n\n\n\n\n\n\n\nDiversification: Choose investments with LOW correlation to reduce portfolio risk!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#when-diversification-fails",
    "href": "lectures/lec_04_presentation.html#when-diversification-fails",
    "title": "Dealing with Uncertainty",
    "section": "When Diversification Fails",
    "text": "When Diversification Fails\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2008 Financial Crisis: Many “diversified” portfolios collapsed due to correlations!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#when-to-use-monte-carlo",
    "href": "lectures/lec_04_presentation.html#when-to-use-monte-carlo",
    "title": "Dealing with Uncertainty",
    "section": "When to Use Monte Carlo",
    "text": "When to Use Monte Carlo\nQuestion: For our simple startup examples so far, do we really NEED Monte Carlo?\n\nShort answer: No! For basic mean/variance calculations, we can use analytical formulas.\n\n\nSo when is Monte Carlo truly necessary?"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#necessary-vs.-convenient",
    "href": "lectures/lec_04_presentation.html#necessary-vs.-convenient",
    "title": "Dealing with Uncertainty",
    "section": "Necessary vs. Convenient",
    "text": "Necessary vs. Convenient\nYou can use math (analytical solutions):\n\nSimple distributions: Mean and variance of normal distributions\nLinear combinations: Portfolio of independent assets\n\n\nYou NEED Monte Carlo when:\n\nComplex dependencies: Nonlinear relationships\nPath-dependent problems: Outcome depends on a sequence\nNo closed-form solution: The math is intractable"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#real-monte-carlo-applications",
    "href": "lectures/lec_04_presentation.html#real-monte-carlo-applications",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications",
    "text": "Real Monte Carlo Applications\nWhere Monte Carlo is ESSENTIAL, not just convenient:\n1. Option Pricing with Path Dependencies\n\n# Payoff depends on AVERAGE price over time\nn_simulations = 10000; strike_price = 105; payoffs = []\nfor sim in range(n_simulations):\n    prices = [100]  # Starting price\n    for day in range(365):\n        prices.append(prices[-1] * (1 + np.random.normal(0.001, 0.02)))\n    payoff = max(0, np.mean(prices) - strike_price)\n    payoffs.append(payoff)\npayoffs = np.array(payoffs)\nprint(f\"Average option value: ${payoffs.mean():.2f}\")\nprint(f\"Probability of profit: {(payoffs &gt; 0).mean():.1%}\")\n\n\n\nAverage option value: $19.58\nProbability of profit: 68.9%"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#real-monte-carlo-applications-ii",
    "href": "lectures/lec_04_presentation.html#real-monte-carlo-applications-ii",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications II",
    "text": "Real Monte Carlo Applications II"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#real-monte-carlo-applications-iii",
    "href": "lectures/lec_04_presentation.html#real-monte-carlo-applications-iii",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications III",
    "text": "Real Monte Carlo Applications III\n2. Supply Chain with Cascading Effects\n\n# Each stage affects the next (nonlinear dependencies)\nn_simulations = 10000; factory_capacity = 150; demand = 120; price = 5\npenalty = 10; revenues = []\n\nfor sim in range(n_simulations):\n    parts_delivered = np.random.poisson(100)\n    production = min(parts_delivered, factory_capacity)\n    if production &gt;= demand:\n        revenue = demand * price\n    else:\n        revenue = production * price - penalty\n    revenues.append(revenue)\n\nrevenues = np.array(revenues)\nprint(f\"Average revenue: ${revenues.mean():.2f}\")\nprint(f\"Worst-case revenue: ${revenues.min():.2f}\")\n\n\n\nAverage revenue: $489.22\nWorst-case revenue: $325.00"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#real-monte-carlo-applications-iv",
    "href": "lectures/lec_04_presentation.html#real-monte-carlo-applications-iv",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications IV",
    "text": "Real Monte Carlo Applications IV"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#real-monte-carlo-applications-v",
    "href": "lectures/lec_04_presentation.html#real-monte-carlo-applications-v",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications V",
    "text": "Real Monte Carlo Applications V\n3. Project Management with Sequential Risks\n\n# Project phases must happen in order, later phases only if earlier succeed\nn_simulations = 10000; shape = 2; scale = 10; project_times = []\n\nfor sim in range(n_simulations):\n    total_time = 0\n    for phase in ['design', 'build', 'test', 'deploy']:\n        # Each phase has uncertain duration\n        phase_time = np.random.gamma(shape, scale)\n        total_time += phase_time\n        if np.random.random() &lt; 0.1:\n            total_time += phase_time * 0.5  # Rework time\n    project_times.append(total_time)\n\nproject_times = np.array(project_times)\nprint(f\"Average project duration: {project_times.mean():.1f} days\")\nprint(f\"90th percentile: {np.percentile(project_times, 90):.1f} days\")\n\n\n\nAverage project duration: 84.3 days\n90th percentile: 125.2 days"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#real-monte-carlo-applications-vi",
    "href": "lectures/lec_04_presentation.html#real-monte-carlo-applications-vi",
    "title": "Dealing with Uncertainty",
    "section": "Real Monte Carlo Applications VI",
    "text": "Real Monte Carlo Applications VI"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#example-why-still-useful",
    "href": "lectures/lec_04_presentation.html#example-why-still-useful",
    "title": "Dealing with Uncertainty",
    "section": "Example: Why Still Useful?",
    "text": "Example: Why Still Useful?\nQuestion: If we can calculate variance analytically, why simulate?\n\n\nVisualization: Seeing the full distribution is intuitive\nFlexibility: When problems become complex, simulation adapts\nExtensions: Practice for complex problem\n\n\n\n\n\n\n\n\n\nThink of our examples as learning the tool on simple problems so you can solve complex ones where Monte Carlo is required!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#when-not-to-use-monte-carlo",
    "href": "lectures/lec_04_presentation.html#when-not-to-use-monte-carlo",
    "title": "Dealing with Uncertainty",
    "section": "When NOT to Use Monte Carlo",
    "text": "When NOT to Use Monte Carlo\nEven when you CAN use Monte Carlo, sometimes you shouldn’t:\n\n\nSimple analytical solution exists and suffices\n\nUse math directly: faster, more precise, easier to understand\n\nCan’t reasonably estimate input distributions\n\nGarbage in = garbage out; need solid basis for assumptions\n\nProblem is deterministic (no uncertainty)\n\nSimulation adds complexity without value\n\n\n\n\n\n\n\n\n\n\nSimulation is a tool for managing uncertainty, not creating false precision!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#decision-framework",
    "href": "lectures/lec_04_presentation.html#decision-framework",
    "title": "Dealing with Uncertainty",
    "section": "Decision Framework",
    "text": "Decision Framework\n\nDefine Your Risk Tolerance\n\nCan you afford to lose money and what’s your time horizon?\nAre you risk-averse or risk-seeking?\n\nEvaluate Multiple Metrics\n\nDon’t just maximize returns, consider volatility and risk\nLook at probability of achieving goals\n\nScenario Test\n\nWhat if distributions change or a company fails?"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#the-plan-for-the-day",
    "href": "lectures/lec_04_presentation.html#the-plan-for-the-day",
    "title": "Dealing with Uncertainty",
    "section": "The Plan for the Day",
    "text": "The Plan for the Day\n\n\nHour 1:\nLecture\n\nConcepts\nExamples\nVisualization\n\n\nHour 2:\nPractice Notebook\n\nSimulation\nHands-on coding\nBuild your skills\n\n\nHours 3-4:\nCompetition\n\nTechVenture\nTeam collaboration\n€2M investment\n\n\n\nRemember: The lecture gives you concepts. The notebook gives you practice. The competition tests your skills!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#hour-2-simulation",
    "href": "lectures/lec_04_presentation.html#hour-2-simulation",
    "title": "Dealing with Uncertainty",
    "section": "Hour 2: Simulation",
    "text": "Hour 2: Simulation\nYour Practice Case: Bean Counter Expansion\n\nModel uncertain variables (customers, spending)\nCombine multiple uncertainties\nCalculate business metrics (VaR, profit probability)\nMake data-driven recommendations"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#hours-3-4-the-challenge",
    "href": "lectures/lec_04_presentation.html#hours-3-4-the-challenge",
    "title": "Dealing with Uncertainty",
    "section": "Hours 3-4: The Challenge",
    "text": "Hours 3-4: The Challenge\nTechVenture Investment Competition\n\nYour Budget: €2 million\nYour Choice: Pick 2 of 4 startups\nYour Goal: Maximize risk-adjusted returns\nYour Deliverable: One-slide recommendation + 3-minute pitch\n\n\n\nConsider multiple risk metrics and prepare a clear justification!\n\n\n\nPrizes: 10 / 6 / 3 bonus points for top three teams!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#what-youve-learned-today",
    "href": "lectures/lec_04_presentation.html#what-youve-learned-today",
    "title": "Dealing with Uncertainty",
    "section": "What You’ve Learned Today",
    "text": "What You’ve Learned Today\n\n\nConcepts\n\nMonte Carlo simulation\nProbability distributions\nRisk has multiple dimensions\nExpected Value vs. Variance\nCorrelation and dependence\n\n\nSkills\n\nUsing np.random for simulation\nCalculating risk metrics\nVisualizing uncertainty\nComparing portfolios\nUnderstanding correlation\n\n\n\n\n\n\n\n\n\nMonte Carlo doesn’t predict THE future - it shows possible futures! And correlation can amplify or reduce risk!"
  },
  {
    "objectID": "lectures/lec_04_presentation.html#next-week",
    "href": "lectures/lec_04_presentation.html#next-week",
    "title": "Dealing with Uncertainty",
    "section": "Next Week",
    "text": "Next Week\nForecasting the Future\n\nMoving from simulation to prediction\nTime series analysis\nTrend and seasonality detection\nMeasuring forecast accuracy\n\n\nNow, short break and then we start coding!"
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html",
    "href": "lectures/lec_06_greedy_algorithms.html",
    "title": "Smart Quick Decisions",
    "section": "",
    "text": ". . .\nOperations Manager’s Friday Crisis:\n“It’s Friday at 06:00 in the morning. We just received 16 custom bicycle orders that must be completed by this evening. Two workstations. Rush orders with penalties. Overtime costs €100/hour after Friday 19:00. How do we schedule production to minimize costs?”\n\n\n\nCustom Cycles faces multiple scheduling decisions:\n\n\nOrder Sequencing: Which bike to build first?\nWorkstation Management: Assembly must finish before painting\nDeadline Pressure: Rush orders have steep penalties (€150 each)\nCost Control: Overtime at €100/hour after Saturday 8 PM\n\n\n. . .\n\n\n\n\n\n\nThe Stakes: With 16 orders totaling 13+ hours of work, wrong scheduling could mean €1000+ in overtime and penalties!\n\n\n\n\n\n\nQuestion: With 16 bicycle orders to sequence, how many possible schedules exist?\n. . .\n16! = 20,922,789,888,000 possible schedules\n. . .\n\n\nNumber of Orders\n\n5 bikes\n10 bikes\n16 bikes\n\n\nPossible Schedules\n\n120\n3.6 million\n20.9 trillion\n\n\n\n. . .\n\n\n\n\n\n\nTesting all 20.9 trillion possibilities for 16 bikes would take thousands of years on a modern computer!\n\n\n\n\n\n\nLook at these 4 bicycle orders. Which should we build first?\n. . .\n\n\n\nOrder\nArrival\nProcessing\nDue\nPenalty\n\n\n\n\nB12\n1st\n90 min\n180 min\n€150\n\n\nB08\n2nd\n45 min\n280 min\n€150\n\n\nB15\n3rd\n75 min\n220 min\n€150\n\n\nB03\n4th\n30 min\n300 min\n€150\n\n\n\n. . .\nQuestion: How would you proceed here?\n. . .\n\n\n\n\n\n\nThis is the greedy choice problem: Which local decision leads to the best global outcome?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#client-briefing-custom-cycles-manufacturing",
    "href": "lectures/lec_06_greedy_algorithms.html#client-briefing-custom-cycles-manufacturing",
    "title": "Smart Quick Decisions",
    "section": "",
    "text": ". . .\nOperations Manager’s Friday Crisis:\n“It’s Friday at 06:00 in the morning. We just received 16 custom bicycle orders that must be completed by this evening. Two workstations. Rush orders with penalties. Overtime costs €100/hour after Friday 19:00. How do we schedule production to minimize costs?”",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#the-manufacturing-challenge",
    "href": "lectures/lec_06_greedy_algorithms.html#the-manufacturing-challenge",
    "title": "Smart Quick Decisions",
    "section": "",
    "text": "Custom Cycles faces multiple scheduling decisions:\n\n\nOrder Sequencing: Which bike to build first?\nWorkstation Management: Assembly must finish before painting\nDeadline Pressure: Rush orders have steep penalties (€150 each)\nCost Control: Overtime at €100/hour after Saturday 8 PM\n\n\n. . .\n\n\n\n\n\n\nThe Stakes: With 16 orders totaling 13+ hours of work, wrong scheduling could mean €1000+ in overtime and penalties!",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#why-cant-we-just-try-everything",
    "href": "lectures/lec_06_greedy_algorithms.html#why-cant-we-just-try-everything",
    "title": "Smart Quick Decisions",
    "section": "",
    "text": "Question: With 16 bicycle orders to sequence, how many possible schedules exist?\n. . .\n16! = 20,922,789,888,000 possible schedules\n. . .\n\n\nNumber of Orders\n\n5 bikes\n10 bikes\n16 bikes\n\n\nPossible Schedules\n\n120\n3.6 million\n20.9 trillion\n\n\n\n. . .\n\n\n\n\n\n\nTesting all 20.9 trillion possibilities for 16 bikes would take thousands of years on a modern computer!",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#can-you-spot-the-pattern",
    "href": "lectures/lec_06_greedy_algorithms.html#can-you-spot-the-pattern",
    "title": "Smart Quick Decisions",
    "section": "",
    "text": "Look at these 4 bicycle orders. Which should we build first?\n. . .\n\n\n\nOrder\nArrival\nProcessing\nDue\nPenalty\n\n\n\n\nB12\n1st\n90 min\n180 min\n€150\n\n\nB08\n2nd\n45 min\n280 min\n€150\n\n\nB15\n3rd\n75 min\n220 min\n€150\n\n\nB03\n4th\n30 min\n300 min\n€150\n\n\n\n. . .\nQuestion: How would you proceed here?\n. . .\n\n\n\n\n\n\nThis is the greedy choice problem: Which local decision leads to the best global outcome?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#what-are-greedy-algorithms",
    "href": "lectures/lec_06_greedy_algorithms.html#what-are-greedy-algorithms",
    "title": "Smart Quick Decisions",
    "section": "What Are Greedy Algorithms?",
    "text": "What Are Greedy Algorithms?\nGreedy algorithms make the locally optimal choice at each step.\n. . .\nThe Idea: “Take what looks best right now, don’t look back”\n\n\nFast: O(n log n)1 vs O(n!) for exhaustive search\nSimple: Easy to implement and explain\nGood Enough: Often near-optimal for many problems\nBut: No guarantee of global optimality",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#the-greedy-paradigm",
    "href": "lectures/lec_06_greedy_algorithms.html#the-greedy-paradigm",
    "title": "Smart Quick Decisions",
    "section": "The Greedy Paradigm",
    "text": "The Greedy Paradigm\nAlgorithmic strategy that builds solutions piece by piece\n. . .\nCore Philosophy:\n\n\nMake the best immediate decision at each step\nNever reconsider previous choices (no backtracking)\nHope that local optimality leads to global optimality\nTrade guaranteed optimality for speed and simplicity",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#greedy-in-everyday-life",
    "href": "lectures/lec_06_greedy_algorithms.html#greedy-in-everyday-life",
    "title": "Smart Quick Decisions",
    "section": "Greedy in Everyday Life",
    "text": "Greedy in Everyday Life\nYou already use greedy thinking daily!\n. . .\nCommon Greedy Decisions:\n\n\nMaking change: Give the largest coin first (€2 → €1 → €0.50…)\nGrocery shopping: Pick items with best price/value ratio\nRoute planning: Take the nearest unvisited landmark\nPacking a suitcase: Put largest items in first\nReading emails: Answer quick replies first, defer complex ones\n\n\n. . .\nQuestion: Which of these actually gives the optimal solution?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#when-greedy-works-vs.-fails",
    "href": "lectures/lec_06_greedy_algorithms.html#when-greedy-works-vs.-fails",
    "title": "Smart Quick Decisions",
    "section": "When Greedy Works vs. Fails",
    "text": "When Greedy Works vs. Fails\nNot all greedy algorithms are optimal\n. . .\nGreedy IS Optimal:\n\n\nKruskal’s algorithms (minimum spanning tree)\nSPT scheduling (minimizes average flow time)\nEDD scheduling (minimizes maximum lateness)\n\n\n. . .\nGreedy FAILS:\n\n\nTraveling salesman problem (nearest neighbor is worse)\n0/1 Knapsack (greedy by value/weight ratio fails)",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#the-two-key-properties",
    "href": "lectures/lec_06_greedy_algorithms.html#the-two-key-properties",
    "title": "Smart Quick Decisions",
    "section": "The Two Key Properties",
    "text": "The Two Key Properties\nFor greedy to be optimal, we need:\n. . .\n1. Greedy Choice Property\n\nLocally optimal choice leads to globally optimal solution\nCan make choice without considering future consequences\n\n. . .\n2. Optimal Substructure\n\nOptimal solution contains optimal solutions to subproblems\nAfter making greedy choice, remaining problem is similar",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#complexity-why-greedy-is-fast",
    "href": "lectures/lec_06_greedy_algorithms.html#complexity-why-greedy-is-fast",
    "title": "Smart Quick Decisions",
    "section": "Complexity: Why Greedy is Fast",
    "text": "Complexity: Why Greedy is Fast\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nFor 16 bikes: Exhaustive = 20 trillion operations, Greedy = 64 operations!",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#three-classic-scheduling-rules",
    "href": "lectures/lec_06_greedy_algorithms.html#three-classic-scheduling-rules",
    "title": "Smart Quick Decisions",
    "section": "Three Classic Scheduling Rules",
    "text": "Three Classic Scheduling Rules\nWe’ll explore three greedy approaches that manufacturing uses:\n\n\nFIFO (First In, First Out) - The fairness rule\nSPT (Shortest Processing Time) - The efficiency rule\nEDD (Earliest Due Date) - The deadline rule\n\n\n. . .\nQuestion: Just as first feeling. Which rule would you use for the bike factory with penalties and overtime costs?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#rule-1-fifo-first-in-first-out",
    "href": "lectures/lec_06_greedy_algorithms.html#rule-1-fifo-first-in-first-out",
    "title": "Smart Quick Decisions",
    "section": "Rule 1: FIFO (First In, First Out)",
    "text": "Rule 1: FIFO (First In, First Out)\nProcess jobs in the order they arrive, no prioritization.\n\n\nWhen it’s good: Ensures fairness and prevents “customer favoritism”\nWhen it’s optimal: When all jobs have equal importance and no deadlines\nReal-world use: Bank queues, ticket counters, help desk systems\n\n\n. . .\n\n\n\n\n\n\nLike scheduling job interviews when all candidates applied at different times: You interview in application order to be fair, even if some candidates are stronger.",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#example-hospital-check-in",
    "href": "lectures/lec_06_greedy_algorithms.html#example-hospital-check-in",
    "title": "Smart Quick Decisions",
    "section": "Example: Hospital Check-In",
    "text": "Example: Hospital Check-In\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nSee the pattern? We just do patient A, then patient B, then patient C, then patient D.",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#spt-shortest-processing-time",
    "href": "lectures/lec_06_greedy_algorithms.html#spt-shortest-processing-time",
    "title": "Smart Quick Decisions",
    "section": "2: SPT (Shortest Processing Time)",
    "text": "2: SPT (Shortest Processing Time)\nThe Idea: Process quickest job next to maximize throughput.\n\n\nWhen it’s good: Minimizes average waiting time for customers\nWhen it’s optimal: Proven optimal for minimizing mean completion time\nReal-world use: Express checkout lanes, quick service repairs, email triage\n\n\n. . .\n\n\n\n\n\n\nLike answering emails: Respond to quick 1-minute replies first, then tackle the complex ones requiring research so more people get helped faster.",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#example-coffee-shop-orders",
    "href": "lectures/lec_06_greedy_algorithms.html#example-coffee-shop-orders",
    "title": "Smart Quick Decisions",
    "section": "Example: Coffee Shop Orders",
    "text": "Example: Coffee Shop Orders\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nHowever, not all customers might be willing to wait longer for their orders!",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#rule-3-edd-earliest-due-date",
    "href": "lectures/lec_06_greedy_algorithms.html#rule-3-edd-earliest-due-date",
    "title": "Smart Quick Decisions",
    "section": "Rule 3: EDD (Earliest Due Date)",
    "text": "Rule 3: EDD (Earliest Due Date)\nThe Idea: Jobs by deadline order to tackle urgent work first.\n\n\nWhen it’s good: Minimizes number of late jobs (tardiness)\nWhen it’s optimal: Proven optimal for minimizing maximum lateness\nReal-world use: Project deadlines, delivery logistics, exam grading\n\n\n. . .\n\n\n\n\n\n\nLike grading assignments: Grade the papers due back tomorrow before the ones due next week so students get feedback when promised.",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#example-package-delivery",
    "href": "lectures/lec_06_greedy_algorithms.html#example-package-delivery",
    "title": "Smart Quick Decisions",
    "section": "Example: Package Delivery",
    "text": "Example: Package Delivery\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nNote, that we only minimize maximal lateness here!",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#implementing-spt-in-python-i",
    "href": "lectures/lec_06_greedy_algorithms.html#implementing-spt-in-python-i",
    "title": "Smart Quick Decisions",
    "section": "Implementing SPT in Python I",
    "text": "Implementing SPT in Python I\nLet’s code it together - it’s remarkably simple!\nLet’s assume we want to make some pizzas under deadlines.\n\n# Pizza data\npizzas = [\n    {'id': 'P1', 'time': 10, 'due': 20},\n    {'id': 'P2', 'time': 8, 'due': 15},\n    {'id': 'P3', 'time': 6, 'due': 25},\n    {'id': 'P4', 'time': 15, 'due': 20},\n    {'id': 'P5', 'time': 12, 'due': 30},\n]\n\n. . .\nQuestion: How should we proceed for SPT?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#implementing-spt-in-python-ii",
    "href": "lectures/lec_06_greedy_algorithms.html#implementing-spt-in-python-ii",
    "title": "Smart Quick Decisions",
    "section": "Implementing SPT in Python II",
    "text": "Implementing SPT in Python II\n\n# SPT Rule: Sort by processing time\nspt_order = sorted(pizzas, key=lambda p: p['time'])\n\nprint(\"SPT Schedule:\")\ncurrent_time = 0\nfor pizza in spt_order:\n    current_time += pizza['time']\n    print(f\"  {pizza['id']}: due {pizza['due']}, done {current_time}\")\n\nSPT Schedule:\n  P3: due 25, done 6\n  P2: due 15, done 14\n  P1: due 20, done 24\n  P5: due 30, done 36\n  P4: due 20, done 51\n\n\n. . .\n\n\n\n\n\n\nEasy, right? Just one line of Python! sorted() with a key function. Greedy algorithms are often simple to implement.",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#implementing-edd-in-python",
    "href": "lectures/lec_06_greedy_algorithms.html#implementing-edd-in-python",
    "title": "Smart Quick Decisions",
    "section": "Implementing EDD in Python",
    "text": "Implementing EDD in Python\nEDD is just as simple - change the sorting key!\n\n# EDD Rule: Sort by due date\nedd_order = sorted(pizzas, key=lambda p: p['due'])\n\nprint(\"EDD Schedule:\")\ncurrent_time = 0\nfor pizza in edd_order:\n    current_time += pizza['time']\n    print(f\"  {pizza['id']}: due {pizza['due']}, done {current_time}\")\n\nEDD Schedule:\n  P2: due 15, done 8\n  P1: due 20, done 18\n  P4: due 20, done 33\n  P3: due 25, done 39\n  P5: due 30, done 51\n\n\n. . .\nQuestion: Can you modify this to implement FIFO?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#comparing-all-three",
    "href": "lectures/lec_06_greedy_algorithms.html#comparing-all-three",
    "title": "Smart Quick Decisions",
    "section": "Comparing All Three",
    "text": "Comparing All Three\nNow let’s compare all three rules on the same dataset\n. . .\nScenario: 4 rush bike orders arrive with conflicting priorities\n. . .\n\n\n\nOrder\nArrival\nProcessing\nDue\nPenalty\n\n\n\n\nB12\n1st\n90 min\n180 min\n€150\n\n\nB08\n2nd\n45 min\n280 min\n€150\n\n\nB15\n3rd\n75 min\n220 min\n€150\n\n\nB03\n4th\n30 min\n300 min\n€150\n\n\n\n. . .\nQuestion: How would we schedule for each rule?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#all-schedules-compared",
    "href": "lectures/lec_06_greedy_algorithms.html#all-schedules-compared",
    "title": "Smart Quick Decisions",
    "section": "All Schedules Compared",
    "text": "All Schedules Compared\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nNo single rule is always best! The right choice depends on your objectives, which might include fairness, throughput, deadlines and much more.",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#hybrid-scheduling-strategies",
    "href": "lectures/lec_06_greedy_algorithms.html#hybrid-scheduling-strategies",
    "title": "Smart Quick Decisions",
    "section": "Hybrid Scheduling Strategies",
    "text": "Hybrid Scheduling Strategies\n1. Priority Classes:\nIF order.type == \"Rush\":\n    schedule using EDD\nELSE:\n    schedule using SPT\n. . .\n2. Time-Based Switching:\nIF current_time &lt; 3pm:\n    use SPT (maximize throughput)\nELSE:\n    use EDD (meet end-of-day deadlines)\n. . .\n3. Threshold Rules:\nIF (due_date - current_time) &lt; 30 minutes:\n    prioritize this order (emergency mode)\nELSE:\n    use normal SPT rule",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#key-takeaways",
    "href": "lectures/lec_06_greedy_algorithms.html#key-takeaways",
    "title": "Smart Quick Decisions",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\n\nFIFO: Simple and fair, but ignores job characteristics\nSPT: Minimizes average completion time\nEDD: Minimizes maximum lateness\n\n\n. . .\nQuestion: Any questions up until here?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#professional-applications-i",
    "href": "lectures/lec_06_greedy_algorithms.html#professional-applications-i",
    "title": "Smart Quick Decisions",
    "section": "Professional Applications I",
    "text": "Professional Applications I\nWhere scheduling algorithms appear in practice\n. . .\nProject Management:\n\nTask dependencies and precedence constraints\nResource allocation across teams\n\n. . .\nSoftware Development:\n\nCPU process scheduling (operating systems)\nThread management and concurrency",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#professional-applications-ii",
    "href": "lectures/lec_06_greedy_algorithms.html#professional-applications-ii",
    "title": "Smart Quick Decisions",
    "section": "Professional Applications II",
    "text": "Professional Applications II\nOperations & Manufacturing:\n\nProduction line scheduling and supply chain optimization\nWarehouse picking routes and maintenance scheduling\n\n. . .\nTransportation & Logistics:\n\nVehicle routing problems\nCrew scheduling and maintenance window planning\n\n. . .\nHealthcare:\n\nPatient appointment scheduling and staff shift scheduling",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#metric-definitions",
    "href": "lectures/lec_06_greedy_algorithms.html#metric-definitions",
    "title": "Smart Quick Decisions",
    "section": "Metric Definitions",
    "text": "Metric Definitions\nIf we formalize these:\n\n\nCompletion Time (\\(C_i\\)): When job \\(i\\) finishes\nFlow Time (\\(F_i\\)): Time job spends in system = \\(C_i - \\text{arrival}_i\\)\nLateness (\\(L_i\\)): \\(C_i - \\text{due}_i\\) (can be negative = early)\nTardiness (\\(T_i\\)): \\(\\max(0, L_i)\\) (only counts late jobs)",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#aggregate-metric-definitions",
    "href": "lectures/lec_06_greedy_algorithms.html#aggregate-metric-definitions",
    "title": "Smart Quick Decisions",
    "section": "Aggregate Metric Definitions",
    "text": "Aggregate Metric Definitions\nIf we look at several of these:\n\n\nMakespan (\\(C_{\\max}\\)): \\(\\max(C_i)\\) - when all jobs done\nAverage Flow Time: \\(\\sum F_i / n\\)\nTotal Tardiness: \\(\\sum T_i\\)\nMaximum Lateness: \\(\\max(L_i)\\)\n\n\n. . .\nQuestion: In which context would you use each metric?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#why-metrics-matter",
    "href": "lectures/lec_06_greedy_algorithms.html#why-metrics-matter",
    "title": "Smart Quick Decisions",
    "section": "Why Metrics Matter",
    "text": "Why Metrics Matter\nDifferent objectives require different metrics\n. . .\nBusiness Context Matters:\n\n\nManufacturing: Minimize total production time (makespan)\nService: Minimize average customer wait (flow time)\nDelivery: Minimize late deliveries (tardiness)\nContracts: Minimize worst-case lateness (maximum lateness)\nCustomer satisfaction: Minimize number of late jobs\n\n\n. . .\n\n\n\n\n\n\nYou can’t optimize what you don’t measure! Choose metrics that align with business goals.",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#which-metric-when",
    "href": "lectures/lec_06_greedy_algorithms.html#which-metric-when",
    "title": "Smart Quick Decisions",
    "section": "Which Metric When?",
    "text": "Which Metric When?\nMatching metrics to business context\n\n\n\nBusiness Goal\nMetric to Optimize\nBest Rule\n\n\n\n\nReduce customer wait time\nAvg Flow Time\nSPT\n\n\nMeet all deadlines\nMax Lateness\nEDD\n\n\nMinimize contract penalties\nTotal Tardiness\nEDD\n\n\nMaximize throughput\nMakespan\nAny (same!)\n\n\nCustomer satisfaction\nNumber Late\nEDD\n\n\nFairness/transparency\n(none)\nFIFO",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#revenue-based-consulting-firm",
    "href": "lectures/lec_06_greedy_algorithms.html#revenue-based-consulting-firm",
    "title": "Smart Quick Decisions",
    "section": "Revenue-Based: Consulting Firm",
    "text": "Revenue-Based: Consulting Firm\n5 consulting projects with different durations and revenues\n\n\n\nProject\nDuration\nRevenue\nRevenue/Hour\n\n\n\n\nC\n55h\n€11,000\n€200\n\n\nA\n25h\n€6,000\n€240\n\n\nE\n55h\n€4,950\n€90\n\n\nD\n45h\n€5,400\n€120\n\n\nB\n35h\n€7,000\n€200\n\n\n\n. . .\nGoal: Maximize revenue during limited consulting time\n. . .\nQuestion: Sort by total revenue? Duration? Or something else?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#revenuehour-rule",
    "href": "lectures/lec_06_greedy_algorithms.html#revenuehour-rule",
    "title": "Smart Quick Decisions",
    "section": "Revenue/Hour Rule",
    "text": "Revenue/Hour Rule\nRule: Sort by revenue per hour (descending)\n. . .\nSorted by Revenue/Hour:\n\n\n\nProject\nDuration\nRevenue\nRevenue/Hour\nSchedule\n\n\n\n\nA\n25h\n€6,000\n€240\n1st\n\n\nB\n35h\n€7,000\n€200\n2nd\n\n\nC\n55h\n€11,000\n€200\n3rd\n\n\nD\n45h\n€5,400\n€120\n4th\n\n\nE\n55h\n€4,950\n€90\n5th\n\n\n\n. . .\nOptimal order: A → B → C → D → E",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#why-revenuehour-works",
    "href": "lectures/lec_06_greedy_algorithms.html#why-revenuehour-works",
    "title": "Smart Quick Decisions",
    "section": "Why Revenue/Hour Works",
    "text": "Why Revenue/Hour Works\nMaximizing early revenue in capacity-constrained situations\n. . .\nScenario: 120 hours of consulting capacity this quarter\n\n\nRevenue/hour approach: A+B+C = 115h → €24,000 revenue\nWrong order (E+D+C): E+D+C = 155h → Doesn’t fit!\nOnly E+D = 100h → €10,350 revenue\nWorst case: Start with low-revenue/hour projects, waste capacity\n\n\n. . .\n\n\n\n\n\n\nThis is Smith’s Rule in action: Sort by (value / time) to maximize weighted completion!",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#the-real-challenge-flow-shops",
    "href": "lectures/lec_06_greedy_algorithms.html#the-real-challenge-flow-shops",
    "title": "Smart Quick Decisions",
    "section": "The Real Challenge: Flow Shops",
    "text": "The Real Challenge: Flow Shops\nMost manufacturing involves multiple stages\n. . .\nFlow Shop: Jobs must visit machines in the same order\n\n\nCar manufacturing: Welding → Painting → Assembly\nBicycle factory: Assembly → Painting\nElectronics: Circuit board → Component placement → Testing\nRestaurant: Cooking → Plating → Service\n\n\n. . .\n\n\n\n\n\n\nKey difference from single-machine: Machine 2 must wait for Machine 1 to finish each job. This creates idle time and blocking.",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#two-stage-example-setup",
    "href": "lectures/lec_06_greedy_algorithms.html#two-stage-example-setup",
    "title": "Smart Quick Decisions",
    "section": "Two-Stage Example Setup",
    "text": "Two-Stage Example Setup\n3 Bicycles through Assembly → Painting\n\n\n\nBike\nAssembly Time\nPainting Time\nTotal\n\n\n\n\nX\n30 min\n20 min\n50\n\n\nY\n20 min\n30 min\n50\n\n\nZ\n15 min\n15 min\n30\n\n\n\n. . .\nQuestion: If we process in order X → Y → Z, what happens?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#fifo-x-y-z",
    "href": "lectures/lec_06_greedy_algorithms.html#fifo-x-y-z",
    "title": "Smart Quick Decisions",
    "section": "FIFO: X → Y → Z",
    "text": "FIFO: X → Y → Z\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nPainting station waits 30 minutes for first bike! Total time = 95 minutes",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#why-simple-rules-struggle",
    "href": "lectures/lec_06_greedy_algorithms.html#why-simple-rules-struggle",
    "title": "Smart Quick Decisions",
    "section": "Why Simple Rules Struggle",
    "text": "Why Simple Rules Struggle\nEach rule has ambiguities in two-stage problems\n. . .\nSPT - Shortest Processing Time:\n\nSort by assembly time? → Favors Z (15 min)\nSort by painting time? → Favors X (20 min)\nSort by total time? → All tied (50, 50, 30)\n\n. . .\nEDD - Earliest Due Date: Doesn’t minimize idle time or makespan\n. . .\nFIFO: Arbitrary order, no optimization\n. . .\nQuestion: Is there a better approach for minimizing makespan?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#johnsons-algorithm-the-intuition",
    "href": "lectures/lec_06_greedy_algorithms.html#johnsons-algorithm-the-intuition",
    "title": "Smart Quick Decisions",
    "section": "Johnson’s Algorithm: The Intuition",
    "text": "Johnson’s Algorithm: The Intuition\n. . .\nWhy does Johnson’s work? Let’s understand the logic first\n. . .\nThink about bottlenecks in a two-stage flow:\n\n\nMachine 2 sits idle waiting for Machine 1 to finish\nGoal: Minimize that idle time\n\n\n. . .\nKey Observation:\n\n\nIf a job is quick on Machine 1 → Do it early (Machine 1 finishes fast, Machine 2 starts sooner!)\nIf a job is quick on Machine 2 → Do it late (Machine 2 can finish quickly at the end, no wasted capacity)",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#johnsons-algorithm-the-rule",
    "href": "lectures/lec_06_greedy_algorithms.html#johnsons-algorithm-the-rule",
    "title": "Smart Quick Decisions",
    "section": "Johnson’s Algorithm: The Rule",
    "text": "Johnson’s Algorithm: The Rule\nFour simple steps to optimal scheduling\n. . .\n\n\nFind minimum time across both machines for all remaining jobs\nIf minimum is on M1: Schedule this job at earliest open position\nIf minimum is on M2: Schedule this job at latest open position\nRepeat until all jobs scheduled\n\n\n. . .\n\n\n\n\n\n\nJohnson proved this greedy choice property guarantees global optimum for makespan in 2-machine flow shops!\n\n\n\n. . .\nLet’s apply this to our 3 bikes…",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#applying-johnsons-algorithm",
    "href": "lectures/lec_06_greedy_algorithms.html#applying-johnsons-algorithm",
    "title": "Smart Quick Decisions",
    "section": "Applying Johnson’s Algorithm",
    "text": "Applying Johnson’s Algorithm\n\n\n\nBike\nAssembly\nPainting\nMin Time\n\n\n\n\nX\n30\n20\n20 (P)\n\n\nY\n20\n30\n20 (A)\n\n\nZ\n15\n15\n15 (A/P)\n\n\n\n\n\nMin time = 15 (Z, assembly) → Schedule Z first\nMin time = 20 (Y, assembly) → Schedule Y second\nMin time = 20 (X, painting) → Schedule X last\n\n\n. . .\n\n\n\n\n\n\nEasy, right?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#johnsons-schedule-z-y-x",
    "href": "lectures/lec_06_greedy_algorithms.html#johnsons-schedule-z-y-x",
    "title": "Smart Quick Decisions",
    "section": "Johnson’s Schedule: Z → Y → X",
    "text": "Johnson’s Schedule: Z → Y → X\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\n10-minute improvement! (85 vs 95) - 10.5% faster with optimal ordering",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#beyond-two-machines",
    "href": "lectures/lec_06_greedy_algorithms.html#beyond-two-machines",
    "title": "Smart Quick Decisions",
    "section": "Beyond Two Machines",
    "text": "Beyond Two Machines\nWhat about 3+ machines?\n. . .\nBad news:\n\n3+ machine flow shop is NP-hard\nNo polynomial optimal algorithm known\n\n. . .\nGood news:\n\nHeuristics work well in practice\nSimulated annealing, genetic algorithms",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#dynamic-vs-static-scheduling",
    "href": "lectures/lec_06_greedy_algorithms.html#dynamic-vs-static-scheduling",
    "title": "Smart Quick Decisions",
    "section": "Dynamic vs Static Scheduling",
    "text": "Dynamic vs Static Scheduling\nHow scheduling changes with job arrivals\n. . .\n\n\nStatic (Offline):\n\nAll jobs known upfront\nSchedule computed once\nCan often use optimal algorithms\n\n\nDynamic (Online):\n\nMost real-world scenarios\nJobs arrive over time\nMust make decisions without future knowledge\n\n\n\n. . .\nQuestion: Any ideas about complications in dynamic environments?\n. . .\nQuestion: Any other real world considerations?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#real-world-considerations",
    "href": "lectures/lec_06_greedy_algorithms.html#real-world-considerations",
    "title": "Smart Quick Decisions",
    "section": "Real-World Considerations",
    "text": "Real-World Considerations\n\nSetup Times:\n\nChanging requires tool adjustments or cleaning\nSequence-dependent scheduling (TSP-like)\n\n\n. . .\n\nResource Constraints:\n\nLimited ressources, specialized tools, material shortages\nWorker skill levels and availability\n\n\n. . .\n\nUncertainty:\n\nProcessing times, break downs, and other unforeseen events",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#common-scheduling-mistakes-i",
    "href": "lectures/lec_06_greedy_algorithms.html#common-scheduling-mistakes-i",
    "title": "Smart Quick Decisions",
    "section": "Common Scheduling Mistakes I",
    "text": "Common Scheduling Mistakes I\nLearn from others’ errors - avoid these pitfalls!\n. . .\nQuestion: Any idea what could be common mistakes?\n. . .\nMistake #1: Ignoring Setup Times\n\n\nProblem: Changing from between tasks requires adjustments\nImpact: Your “optimal” SPT schedule wastes 3 hours on setups\nFix: Batch similar tasks together (hybrid rule: SPT within batches)",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#common-scheduling-mistakes-ii",
    "href": "lectures/lec_06_greedy_algorithms.html#common-scheduling-mistakes-ii",
    "title": "Smart Quick Decisions",
    "section": "Common Scheduling Mistakes II",
    "text": "Common Scheduling Mistakes II\nLearn from others’ errors - avoid these pitfalls!\nMistake #2: Static Scheduling with Dynamic Arrivals\n\n\nProblem: Using Johnson’s algorithm at 2 PM, never adjusting when urgent orders arrive at 4 PM\nImpact: New rush order sits idle while finishing low-priority work\nFix: Re-optimize periodically or use priority thresholds",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#common-scheduling-mistakes-iii",
    "href": "lectures/lec_06_greedy_algorithms.html#common-scheduling-mistakes-iii",
    "title": "Smart Quick Decisions",
    "section": "Common Scheduling Mistakes III",
    "text": "Common Scheduling Mistakes III\nLearn from others’ errors - avoid these pitfalls!\nMistake #3: Optimizing the Wrong Metric\n\n\nProblem: Minimizing makespan when penalty costs dominate\nImpact: You “win” on time but lose €400 on penalties\nFix: Always align algorithm choice with total cost function",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#thrashing",
    "href": "lectures/lec_06_greedy_algorithms.html#thrashing",
    "title": "Smart Quick Decisions",
    "section": "Thrashing",
    "text": "Thrashing\nWhen scheduling breaks down completely\n. . .\nWhat is Thrashing?\n\nExcessive context switching between tasks\nOrganization overhead exceeds actual productivity\nMaximum activity, minimum output\n\n. . .\nQuestion: Do you know this from your personally?",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#thrashing-warning-signs",
    "href": "lectures/lec_06_greedy_algorithms.html#thrashing-warning-signs",
    "title": "Smart Quick Decisions",
    "section": "Thrashing Warning Signs",
    "text": "Thrashing Warning Signs\nHow to recognize when you’re thrashing\n. . .\nIndividual Level:\n\n\nConstant task switching (&lt; 15 minutes per task)\nNothing getting completed despite being “busy”\nIncreasing stress and anxiety\nDeclining quality of work\nFeeling overwhelmed despite working hard",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#preventing-thrashing",
    "href": "lectures/lec_06_greedy_algorithms.html#preventing-thrashing",
    "title": "Smart Quick Decisions",
    "section": "Preventing Thrashing",
    "text": "Preventing Thrashing\nStrategic approaches to maintain productivity\n. . .\nStrategic Solutions:\n\n\nTask rejection threshold: Say no to new tasks when queue exceeds capacity\nMinimum work periods: Minimum focus time per task\nBatching: Group similar tasks (all emails at once, all calls at once)\nBuffer times: Schedule gaps between major tasks\nReduced reactivity: Check email at set times, not constantly",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#today",
    "href": "lectures/lec_06_greedy_algorithms.html#today",
    "title": "Smart Quick Decisions",
    "section": "Today",
    "text": "Today\n\n\nHour 2: This Lecture\n\nGreedy algorithms\nFIFO, SPT, EDD rules\nTrade-offs\nGantt charts\n\n\nHour 3: Notebook\n\nBean Counter CEO\nImplement rules\nVisualizations\nAnalyze orders\n\n\nHour 4: Competition\n\nBike Factory Crisis\n16 bicycle orders\nTwo-stage process\nMinimize total costs!",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#the-competition-challenge",
    "href": "lectures/lec_06_greedy_algorithms.html#the-competition-challenge",
    "title": "Smart Quick Decisions",
    "section": "The Competition Challenge",
    "text": "The Competition Challenge\nThe Bike Factory Crisis\n. . .\n\nSchedule 16 custom bicycle orders across 2 workstations\nOptimize Assembly → Painting workflow\nBalance overtime costs vs. late delivery penalties\nMinimize total cost (overtime + penalties)\n\n. . .\n\n\n\n\n\n\nChoose the right trade-off for the business context!",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#remember-this",
    "href": "lectures/lec_06_greedy_algorithms.html#remember-this",
    "title": "Smart Quick Decisions",
    "section": "Remember This!",
    "text": "Remember This!\nThe Rules of Greedy Scheduling\n\n\nKnow your objective - Fairness, speed, or deadlines?\nFIFO for fairness - Simple, transparent, no favoritism\nSPT for throughput - Minimizes average completion time\nEDD for deadlines - Minimizes maximum lateness\nNo single winner - Each rule optimizes different metrics\nContext matters - Match the rule to your business goal\nTwo-stage is harder - Assembly → Painting adds complexity",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#final-thought",
    "href": "lectures/lec_06_greedy_algorithms.html#final-thought",
    "title": "Smart Quick Decisions",
    "section": "Final Thought",
    "text": "Final Thought\nGreedy algorithms are about smart trade-offs\n. . .\n\n\nThe Advantage:\n\nFast O(n log n)\nEasy to implement\nExplainable decisions\nOften near-optimal\nPractical for real-time\n\n\nThe Challenge:\n\nNo global optimality guarantee\nDifferent rules, different results\nThree-stage problems are complex\nMay need hybrid approaches",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#break",
    "href": "lectures/lec_06_greedy_algorithms.html#break",
    "title": "Smart Quick Decisions",
    "section": "Break!",
    "text": "Break!\nTake 20 minutes, then we start the practice notebook\nNext up: You’ll become Bean Counter’s scheduler\nThen: The Bike Factory Crisis competition",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_greedy_algorithms.html#footnotes",
    "href": "lectures/lec_06_greedy_algorithms.html#footnotes",
    "title": "Smart Quick Decisions",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWhy n log n? Greedy algorithms typically: (1) Sort the jobs by some criterion = O(n log n), and (2) Process each job once = O(n). The sorting dominates, so overall O(n log n).↩︎",
    "crumbs": [
      "06 Greedy Search",
      "06 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_06_presentation.html#client-briefing-custom-cycles-manufacturing",
    "href": "lectures/lec_06_presentation.html#client-briefing-custom-cycles-manufacturing",
    "title": "Smart Quick Decisions",
    "section": "Client Briefing: Custom Cycles Manufacturing",
    "text": "Client Briefing: Custom Cycles Manufacturing\n\nOperations Manager’s Friday Crisis:\n“It’s Friday at 06:00 in the morning. We just received 16 custom bicycle orders that must be completed by this evening. Two workstations. Rush orders with penalties. Overtime costs €100/hour after Friday 19:00. How do we schedule production to minimize costs?”"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#the-manufacturing-challenge",
    "href": "lectures/lec_06_presentation.html#the-manufacturing-challenge",
    "title": "Smart Quick Decisions",
    "section": "The Manufacturing Challenge",
    "text": "The Manufacturing Challenge\nCustom Cycles faces multiple scheduling decisions:\n\nOrder Sequencing: Which bike to build first?\nWorkstation Management: Assembly must finish before painting\nDeadline Pressure: Rush orders have steep penalties (€150 each)\nCost Control: Overtime at €100/hour after Saturday 8 PM\n\n\n\n\n\n\n\n\nThe Stakes: With 16 orders totaling 13+ hours of work, wrong scheduling could mean €1000+ in overtime and penalties!"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#why-cant-we-just-try-everything",
    "href": "lectures/lec_06_presentation.html#why-cant-we-just-try-everything",
    "title": "Smart Quick Decisions",
    "section": "Why Can’t We Just Try Everything?",
    "text": "Why Can’t We Just Try Everything?\nQuestion: With 16 bicycle orders to sequence, how many possible schedules exist?\n\n16! = 20,922,789,888,000 possible schedules\n\n\n\n\nNumber of Orders\n\n5 bikes\n10 bikes\n16 bikes\n\n\nPossible Schedules\n\n120\n3.6 million\n20.9 trillion\n\n\n\n\n\n\n\n\n\n\nTesting all 20.9 trillion possibilities for 16 bikes would take thousands of years on a modern computer!"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#can-you-spot-the-pattern",
    "href": "lectures/lec_06_presentation.html#can-you-spot-the-pattern",
    "title": "Smart Quick Decisions",
    "section": "Can You Spot the Pattern?",
    "text": "Can You Spot the Pattern?\nLook at these 4 bicycle orders. Which should we build first?\n\n\n\n\nOrder\nArrival\nProcessing\nDue\nPenalty\n\n\n\n\nB12\n1st\n90 min\n180 min\n€150\n\n\nB08\n2nd\n45 min\n280 min\n€150\n\n\nB15\n3rd\n75 min\n220 min\n€150\n\n\nB03\n4th\n30 min\n300 min\n€150\n\n\n\n\n\nQuestion: How would you proceed here?\n\n\n\n\n\n\n\n\nThis is the greedy choice problem: Which local decision leads to the best global outcome?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#what-are-greedy-algorithms",
    "href": "lectures/lec_06_presentation.html#what-are-greedy-algorithms",
    "title": "Smart Quick Decisions",
    "section": "What Are Greedy Algorithms?",
    "text": "What Are Greedy Algorithms?\nGreedy algorithms make the locally optimal choice at each step.\n\nThe Idea: “Take what looks best right now, don’t look back”\n\nFast: O(n log n)1 vs O(n!) for exhaustive search\nSimple: Easy to implement and explain\nGood Enough: Often near-optimal for many problems\nBut: No guarantee of global optimality\n\n\nWhy n log n? Greedy algorithms typically: (1) Sort the jobs by some criterion = O(n log n), and (2) Process each job once = O(n). The sorting dominates, so overall O(n log n)."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#the-greedy-paradigm",
    "href": "lectures/lec_06_presentation.html#the-greedy-paradigm",
    "title": "Smart Quick Decisions",
    "section": "The Greedy Paradigm",
    "text": "The Greedy Paradigm\nAlgorithmic strategy that builds solutions piece by piece\n\nCore Philosophy:\n\nMake the best immediate decision at each step\nNever reconsider previous choices (no backtracking)\nHope that local optimality leads to global optimality\nTrade guaranteed optimality for speed and simplicity"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#greedy-in-everyday-life",
    "href": "lectures/lec_06_presentation.html#greedy-in-everyday-life",
    "title": "Smart Quick Decisions",
    "section": "Greedy in Everyday Life",
    "text": "Greedy in Everyday Life\nYou already use greedy thinking daily!\n\nCommon Greedy Decisions:\n\nMaking change: Give the largest coin first (€2 → €1 → €0.50…)\nGrocery shopping: Pick items with best price/value ratio\nRoute planning: Take the nearest unvisited landmark\nPacking a suitcase: Put largest items in first\nReading emails: Answer quick replies first, defer complex ones\n\n\n\nQuestion: Which of these actually gives the optimal solution?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#when-greedy-works-vs.-fails",
    "href": "lectures/lec_06_presentation.html#when-greedy-works-vs.-fails",
    "title": "Smart Quick Decisions",
    "section": "When Greedy Works vs. Fails",
    "text": "When Greedy Works vs. Fails\nNot all greedy algorithms are optimal\n\nGreedy IS Optimal:\n\nKruskal’s algorithms (minimum spanning tree)\nSPT scheduling (minimizes average flow time)\nEDD scheduling (minimizes maximum lateness)\n\n\n\nGreedy FAILS:\n\nTraveling salesman problem (nearest neighbor is worse)\n0/1 Knapsack (greedy by value/weight ratio fails)"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#the-two-key-properties",
    "href": "lectures/lec_06_presentation.html#the-two-key-properties",
    "title": "Smart Quick Decisions",
    "section": "The Two Key Properties",
    "text": "The Two Key Properties\nFor greedy to be optimal, we need:\n\n1. Greedy Choice Property\n\nLocally optimal choice leads to globally optimal solution\nCan make choice without considering future consequences\n\n\n\n2. Optimal Substructure\n\nOptimal solution contains optimal solutions to subproblems\nAfter making greedy choice, remaining problem is similar"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#complexity-why-greedy-is-fast",
    "href": "lectures/lec_06_presentation.html#complexity-why-greedy-is-fast",
    "title": "Smart Quick Decisions",
    "section": "Complexity: Why Greedy is Fast",
    "text": "Complexity: Why Greedy is Fast\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor 16 bikes: Exhaustive = 20 trillion operations, Greedy = 64 operations!"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#three-classic-scheduling-rules",
    "href": "lectures/lec_06_presentation.html#three-classic-scheduling-rules",
    "title": "Smart Quick Decisions",
    "section": "Three Classic Scheduling Rules",
    "text": "Three Classic Scheduling Rules\nWe’ll explore three greedy approaches that manufacturing uses:\n\nFIFO (First In, First Out) - The fairness rule\nSPT (Shortest Processing Time) - The efficiency rule\nEDD (Earliest Due Date) - The deadline rule\n\n\nQuestion: Just as first feeling. Which rule would you use for the bike factory with penalties and overtime costs?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#rule-1-fifo-first-in-first-out",
    "href": "lectures/lec_06_presentation.html#rule-1-fifo-first-in-first-out",
    "title": "Smart Quick Decisions",
    "section": "Rule 1: FIFO (First In, First Out)",
    "text": "Rule 1: FIFO (First In, First Out)\nProcess jobs in the order they arrive, no prioritization.\n\nWhen it’s good: Ensures fairness and prevents “customer favoritism”\nWhen it’s optimal: When all jobs have equal importance and no deadlines\nReal-world use: Bank queues, ticket counters, help desk systems\n\n\n\n\n\n\n\n\nLike scheduling job interviews when all candidates applied at different times: You interview in application order to be fair, even if some candidates are stronger."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#example-hospital-check-in",
    "href": "lectures/lec_06_presentation.html#example-hospital-check-in",
    "title": "Smart Quick Decisions",
    "section": "Example: Hospital Check-In",
    "text": "Example: Hospital Check-In\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSee the pattern? We just do patient A, then patient B, then patient C, then patient D."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#spt-shortest-processing-time",
    "href": "lectures/lec_06_presentation.html#spt-shortest-processing-time",
    "title": "Smart Quick Decisions",
    "section": "2: SPT (Shortest Processing Time)",
    "text": "2: SPT (Shortest Processing Time)\nThe Idea: Process quickest job next to maximize throughput.\n\nWhen it’s good: Minimizes average waiting time for customers\nWhen it’s optimal: Proven optimal for minimizing mean completion time\nReal-world use: Express checkout lanes, quick service repairs, email triage\n\n\n\n\n\n\n\n\nLike answering emails: Respond to quick 1-minute replies first, then tackle the complex ones requiring research so more people get helped faster."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#example-coffee-shop-orders",
    "href": "lectures/lec_06_presentation.html#example-coffee-shop-orders",
    "title": "Smart Quick Decisions",
    "section": "Example: Coffee Shop Orders",
    "text": "Example: Coffee Shop Orders\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHowever, not all customers might be willing to wait longer for their orders!"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#rule-3-edd-earliest-due-date",
    "href": "lectures/lec_06_presentation.html#rule-3-edd-earliest-due-date",
    "title": "Smart Quick Decisions",
    "section": "Rule 3: EDD (Earliest Due Date)",
    "text": "Rule 3: EDD (Earliest Due Date)\nThe Idea: Jobs by deadline order to tackle urgent work first.\n\nWhen it’s good: Minimizes number of late jobs (tardiness)\nWhen it’s optimal: Proven optimal for minimizing maximum lateness\nReal-world use: Project deadlines, delivery logistics, exam grading\n\n\n\n\n\n\n\n\nLike grading assignments: Grade the papers due back tomorrow before the ones due next week so students get feedback when promised."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#example-package-delivery",
    "href": "lectures/lec_06_presentation.html#example-package-delivery",
    "title": "Smart Quick Decisions",
    "section": "Example: Package Delivery",
    "text": "Example: Package Delivery\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote, that we only minimize maximal lateness here!"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#implementing-spt-in-python-i",
    "href": "lectures/lec_06_presentation.html#implementing-spt-in-python-i",
    "title": "Smart Quick Decisions",
    "section": "Implementing SPT in Python I",
    "text": "Implementing SPT in Python I\nLet’s code it together - it’s remarkably simple!\nLet’s assume we want to make some pizzas under deadlines.\n\n# Pizza data\npizzas = [\n    {'id': 'P1', 'time': 10, 'due': 20},\n    {'id': 'P2', 'time': 8, 'due': 15},\n    {'id': 'P3', 'time': 6, 'due': 25},\n    {'id': 'P4', 'time': 15, 'due': 20},\n    {'id': 'P5', 'time': 12, 'due': 30},\n]\n\n\nQuestion: How should we proceed for SPT?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#implementing-spt-in-python-ii",
    "href": "lectures/lec_06_presentation.html#implementing-spt-in-python-ii",
    "title": "Smart Quick Decisions",
    "section": "Implementing SPT in Python II",
    "text": "Implementing SPT in Python II\n\n# SPT Rule: Sort by processing time\nspt_order = sorted(pizzas, key=lambda p: p['time'])\n\nprint(\"SPT Schedule:\")\ncurrent_time = 0\nfor pizza in spt_order:\n    current_time += pizza['time']\n    print(f\"  {pizza['id']}: due {pizza['due']}, done {current_time}\")\n\n\n\nSPT Schedule:\n  P3: due 25, done 6\n  P2: due 15, done 14\n  P1: due 20, done 24\n  P5: due 30, done 36\n  P4: due 20, done 51\n\n\n\n\n\n\n\n\n\nEasy, right? Just one line of Python! sorted() with a key function. Greedy algorithms are often simple to implement."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#implementing-edd-in-python",
    "href": "lectures/lec_06_presentation.html#implementing-edd-in-python",
    "title": "Smart Quick Decisions",
    "section": "Implementing EDD in Python",
    "text": "Implementing EDD in Python\nEDD is just as simple - change the sorting key!\n\n# EDD Rule: Sort by due date\nedd_order = sorted(pizzas, key=lambda p: p['due'])\n\nprint(\"EDD Schedule:\")\ncurrent_time = 0\nfor pizza in edd_order:\n    current_time += pizza['time']\n    print(f\"  {pizza['id']}: due {pizza['due']}, done {current_time}\")\n\n\n\nEDD Schedule:\n  P2: due 15, done 8\n  P1: due 20, done 18\n  P4: due 20, done 33\n  P3: due 25, done 39\n  P5: due 30, done 51\n\n\n\nQuestion: Can you modify this to implement FIFO?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#comparing-all-three",
    "href": "lectures/lec_06_presentation.html#comparing-all-three",
    "title": "Smart Quick Decisions",
    "section": "Comparing All Three",
    "text": "Comparing All Three\nNow let’s compare all three rules on the same dataset\n\nScenario: 4 rush bike orders arrive with conflicting priorities\n\n\n\n\n\nOrder\nArrival\nProcessing\nDue\nPenalty\n\n\n\n\nB12\n1st\n90 min\n180 min\n€150\n\n\nB08\n2nd\n45 min\n280 min\n€150\n\n\nB15\n3rd\n75 min\n220 min\n€150\n\n\nB03\n4th\n30 min\n300 min\n€150\n\n\n\n\n\nQuestion: How would we schedule for each rule?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#all-schedules-compared",
    "href": "lectures/lec_06_presentation.html#all-schedules-compared",
    "title": "Smart Quick Decisions",
    "section": "All Schedules Compared",
    "text": "All Schedules Compared\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo single rule is always best! The right choice depends on your objectives, which might include fairness, throughput, deadlines and much more."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#hybrid-scheduling-strategies",
    "href": "lectures/lec_06_presentation.html#hybrid-scheduling-strategies",
    "title": "Smart Quick Decisions",
    "section": "Hybrid Scheduling Strategies",
    "text": "Hybrid Scheduling Strategies\n1. Priority Classes:\nIF order.type == \"Rush\":\n    schedule using EDD\nELSE:\n    schedule using SPT\n\n2. Time-Based Switching:\nIF current_time &lt; 3pm:\n    use SPT (maximize throughput)\nELSE:\n    use EDD (meet end-of-day deadlines)\n\n\n3. Threshold Rules:\nIF (due_date - current_time) &lt; 30 minutes:\n    prioritize this order (emergency mode)\nELSE:\n    use normal SPT rule"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#key-takeaways",
    "href": "lectures/lec_06_presentation.html#key-takeaways",
    "title": "Smart Quick Decisions",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nFIFO: Simple and fair, but ignores job characteristics\nSPT: Minimizes average completion time\nEDD: Minimizes maximum lateness\n\n\nQuestion: Any questions up until here?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#professional-applications-i",
    "href": "lectures/lec_06_presentation.html#professional-applications-i",
    "title": "Smart Quick Decisions",
    "section": "Professional Applications I",
    "text": "Professional Applications I\nWhere scheduling algorithms appear in practice\n\nProject Management:\n\nTask dependencies and precedence constraints\nResource allocation across teams\n\n\n\nSoftware Development:\n\nCPU process scheduling (operating systems)\nThread management and concurrency"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#professional-applications-ii",
    "href": "lectures/lec_06_presentation.html#professional-applications-ii",
    "title": "Smart Quick Decisions",
    "section": "Professional Applications II",
    "text": "Professional Applications II\nOperations & Manufacturing:\n\nProduction line scheduling and supply chain optimization\nWarehouse picking routes and maintenance scheduling\n\n\nTransportation & Logistics:\n\nVehicle routing problems\nCrew scheduling and maintenance window planning\n\n\n\nHealthcare:\n\nPatient appointment scheduling and staff shift scheduling"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#metric-definitions",
    "href": "lectures/lec_06_presentation.html#metric-definitions",
    "title": "Smart Quick Decisions",
    "section": "Metric Definitions",
    "text": "Metric Definitions\nIf we formalize these:\n\nCompletion Time (\\(C_i\\)): When job \\(i\\) finishes\nFlow Time (\\(F_i\\)): Time job spends in system = \\(C_i - \\text{arrival}_i\\)\nLateness (\\(L_i\\)): \\(C_i - \\text{due}_i\\) (can be negative = early)\nTardiness (\\(T_i\\)): \\(\\max(0, L_i)\\) (only counts late jobs)"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#aggregate-metric-definitions",
    "href": "lectures/lec_06_presentation.html#aggregate-metric-definitions",
    "title": "Smart Quick Decisions",
    "section": "Aggregate Metric Definitions",
    "text": "Aggregate Metric Definitions\nIf we look at several of these:\n\nMakespan (\\(C_{\\max}\\)): \\(\\max(C_i)\\) - when all jobs done\nAverage Flow Time: \\(\\sum F_i / n\\)\nTotal Tardiness: \\(\\sum T_i\\)\nMaximum Lateness: \\(\\max(L_i)\\)\n\n\nQuestion: In which context would you use each metric?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#why-metrics-matter",
    "href": "lectures/lec_06_presentation.html#why-metrics-matter",
    "title": "Smart Quick Decisions",
    "section": "Why Metrics Matter",
    "text": "Why Metrics Matter\nDifferent objectives require different metrics\n\nBusiness Context Matters:\n\nManufacturing: Minimize total production time (makespan)\nService: Minimize average customer wait (flow time)\nDelivery: Minimize late deliveries (tardiness)\nContracts: Minimize worst-case lateness (maximum lateness)\nCustomer satisfaction: Minimize number of late jobs\n\n\n\n\n\n\n\n\n\nYou can’t optimize what you don’t measure! Choose metrics that align with business goals."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#which-metric-when",
    "href": "lectures/lec_06_presentation.html#which-metric-when",
    "title": "Smart Quick Decisions",
    "section": "Which Metric When?",
    "text": "Which Metric When?\nMatching metrics to business context\n\n\n\nBusiness Goal\nMetric to Optimize\nBest Rule\n\n\n\n\nReduce customer wait time\nAvg Flow Time\nSPT\n\n\nMeet all deadlines\nMax Lateness\nEDD\n\n\nMinimize contract penalties\nTotal Tardiness\nEDD\n\n\nMaximize throughput\nMakespan\nAny (same!)\n\n\nCustomer satisfaction\nNumber Late\nEDD\n\n\nFairness/transparency\n(none)\nFIFO"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#revenue-based-consulting-firm",
    "href": "lectures/lec_06_presentation.html#revenue-based-consulting-firm",
    "title": "Smart Quick Decisions",
    "section": "Revenue-Based: Consulting Firm",
    "text": "Revenue-Based: Consulting Firm\n5 consulting projects with different durations and revenues\n\n\n\nProject\nDuration\nRevenue\nRevenue/Hour\n\n\n\n\nC\n55h\n€11,000\n€200\n\n\nA\n25h\n€6,000\n€240\n\n\nE\n55h\n€4,950\n€90\n\n\nD\n45h\n€5,400\n€120\n\n\nB\n35h\n€7,000\n€200\n\n\n\n\nGoal: Maximize revenue during limited consulting time\n\n\nQuestion: Sort by total revenue? Duration? Or something else?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#revenuehour-rule",
    "href": "lectures/lec_06_presentation.html#revenuehour-rule",
    "title": "Smart Quick Decisions",
    "section": "Revenue/Hour Rule",
    "text": "Revenue/Hour Rule\nRule: Sort by revenue per hour (descending)\n\nSorted by Revenue/Hour:\n\n\n\nProject\nDuration\nRevenue\nRevenue/Hour\nSchedule\n\n\n\n\nA\n25h\n€6,000\n€240\n1st\n\n\nB\n35h\n€7,000\n€200\n2nd\n\n\nC\n55h\n€11,000\n€200\n3rd\n\n\nD\n45h\n€5,400\n€120\n4th\n\n\nE\n55h\n€4,950\n€90\n5th\n\n\n\n\n\nOptimal order: A → B → C → D → E"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#why-revenuehour-works",
    "href": "lectures/lec_06_presentation.html#why-revenuehour-works",
    "title": "Smart Quick Decisions",
    "section": "Why Revenue/Hour Works",
    "text": "Why Revenue/Hour Works\nMaximizing early revenue in capacity-constrained situations\n\nScenario: 120 hours of consulting capacity this quarter\n\nRevenue/hour approach: A+B+C = 115h → €24,000 revenue\nWrong order (E+D+C): E+D+C = 155h → Doesn’t fit!\nOnly E+D = 100h → €10,350 revenue\nWorst case: Start with low-revenue/hour projects, waste capacity\n\n\n\n\n\n\n\n\n\nThis is Smith’s Rule in action: Sort by (value / time) to maximize weighted completion!"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#the-real-challenge-flow-shops",
    "href": "lectures/lec_06_presentation.html#the-real-challenge-flow-shops",
    "title": "Smart Quick Decisions",
    "section": "The Real Challenge: Flow Shops",
    "text": "The Real Challenge: Flow Shops\nMost manufacturing involves multiple stages\n\nFlow Shop: Jobs must visit machines in the same order\n\nCar manufacturing: Welding → Painting → Assembly\nBicycle factory: Assembly → Painting\nElectronics: Circuit board → Component placement → Testing\nRestaurant: Cooking → Plating → Service\n\n\n\n\n\n\n\n\n\nKey difference from single-machine: Machine 2 must wait for Machine 1 to finish each job. This creates idle time and blocking."
  },
  {
    "objectID": "lectures/lec_06_presentation.html#two-stage-example-setup",
    "href": "lectures/lec_06_presentation.html#two-stage-example-setup",
    "title": "Smart Quick Decisions",
    "section": "Two-Stage Example Setup",
    "text": "Two-Stage Example Setup\n3 Bicycles through Assembly → Painting\n\n\n\nBike\nAssembly Time\nPainting Time\nTotal\n\n\n\n\nX\n30 min\n20 min\n50\n\n\nY\n20 min\n30 min\n50\n\n\nZ\n15 min\n15 min\n30\n\n\n\n\nQuestion: If we process in order X → Y → Z, what happens?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#fifo-x-y-z",
    "href": "lectures/lec_06_presentation.html#fifo-x-y-z",
    "title": "Smart Quick Decisions",
    "section": "FIFO: X → Y → Z",
    "text": "FIFO: X → Y → Z\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPainting station waits 30 minutes for first bike! Total time = 95 minutes"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#why-simple-rules-struggle",
    "href": "lectures/lec_06_presentation.html#why-simple-rules-struggle",
    "title": "Smart Quick Decisions",
    "section": "Why Simple Rules Struggle",
    "text": "Why Simple Rules Struggle\nEach rule has ambiguities in two-stage problems\n\nSPT - Shortest Processing Time:\n\nSort by assembly time? → Favors Z (15 min)\nSort by painting time? → Favors X (20 min)\nSort by total time? → All tied (50, 50, 30)\n\n\n\nEDD - Earliest Due Date: Doesn’t minimize idle time or makespan\n\n\nFIFO: Arbitrary order, no optimization\n\n\nQuestion: Is there a better approach for minimizing makespan?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#johnsons-algorithm-the-intuition",
    "href": "lectures/lec_06_presentation.html#johnsons-algorithm-the-intuition",
    "title": "Smart Quick Decisions",
    "section": "Johnson’s Algorithm: The Intuition",
    "text": "Johnson’s Algorithm: The Intuition\n\nWhy does Johnson’s work? Let’s understand the logic first\n\n\nThink about bottlenecks in a two-stage flow:\n\nMachine 2 sits idle waiting for Machine 1 to finish\nGoal: Minimize that idle time\n\n\n\nKey Observation:\n\nIf a job is quick on Machine 1 → Do it early (Machine 1 finishes fast, Machine 2 starts sooner!)\nIf a job is quick on Machine 2 → Do it late (Machine 2 can finish quickly at the end, no wasted capacity)"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#johnsons-algorithm-the-rule",
    "href": "lectures/lec_06_presentation.html#johnsons-algorithm-the-rule",
    "title": "Smart Quick Decisions",
    "section": "Johnson’s Algorithm: The Rule",
    "text": "Johnson’s Algorithm: The Rule\nFour simple steps to optimal scheduling\n\n\nFind minimum time across both machines for all remaining jobs\nIf minimum is on M1: Schedule this job at earliest open position\nIf minimum is on M2: Schedule this job at latest open position\nRepeat until all jobs scheduled\n\n\n\n\n\n\n\n\n\nJohnson proved this greedy choice property guarantees global optimum for makespan in 2-machine flow shops!\n\n\n\n\n\nLet’s apply this to our 3 bikes…"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#applying-johnsons-algorithm",
    "href": "lectures/lec_06_presentation.html#applying-johnsons-algorithm",
    "title": "Smart Quick Decisions",
    "section": "Applying Johnson’s Algorithm",
    "text": "Applying Johnson’s Algorithm\n\n\n\nBike\nAssembly\nPainting\nMin Time\n\n\n\n\nX\n30\n20\n20 (P)\n\n\nY\n20\n30\n20 (A)\n\n\nZ\n15\n15\n15 (A/P)\n\n\n\n\nMin time = 15 (Z, assembly) → Schedule Z first\nMin time = 20 (Y, assembly) → Schedule Y second\nMin time = 20 (X, painting) → Schedule X last\n\n\n\n\n\n\n\n\nEasy, right?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#johnsons-schedule-z-y-x",
    "href": "lectures/lec_06_presentation.html#johnsons-schedule-z-y-x",
    "title": "Smart Quick Decisions",
    "section": "Johnson’s Schedule: Z → Y → X",
    "text": "Johnson’s Schedule: Z → Y → X\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10-minute improvement! (85 vs 95) - 10.5% faster with optimal ordering"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#beyond-two-machines",
    "href": "lectures/lec_06_presentation.html#beyond-two-machines",
    "title": "Smart Quick Decisions",
    "section": "Beyond Two Machines",
    "text": "Beyond Two Machines\nWhat about 3+ machines?\n\nBad news:\n\n3+ machine flow shop is NP-hard\nNo polynomial optimal algorithm known\n\n\n\nGood news:\n\nHeuristics work well in practice\nSimulated annealing, genetic algorithms"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#dynamic-vs-static-scheduling",
    "href": "lectures/lec_06_presentation.html#dynamic-vs-static-scheduling",
    "title": "Smart Quick Decisions",
    "section": "Dynamic vs Static Scheduling",
    "text": "Dynamic vs Static Scheduling\nHow scheduling changes with job arrivals\n\n\n\nStatic (Offline):\n\nAll jobs known upfront\nSchedule computed once\nCan often use optimal algorithms\n\n\nDynamic (Online):\n\nMost real-world scenarios\nJobs arrive over time\nMust make decisions without future knowledge\n\n\n\n\nQuestion: Any ideas about complications in dynamic environments?\n\n\nQuestion: Any other real world considerations?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#real-world-considerations",
    "href": "lectures/lec_06_presentation.html#real-world-considerations",
    "title": "Smart Quick Decisions",
    "section": "Real-World Considerations",
    "text": "Real-World Considerations\n\nSetup Times:\n\nChanging requires tool adjustments or cleaning\nSequence-dependent scheduling (TSP-like)\n\n\n\n\nResource Constraints:\n\nLimited ressources, specialized tools, material shortages\nWorker skill levels and availability\n\n\n\n\n\nUncertainty:\n\nProcessing times, break downs, and other unforeseen events"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#common-scheduling-mistakes-i",
    "href": "lectures/lec_06_presentation.html#common-scheduling-mistakes-i",
    "title": "Smart Quick Decisions",
    "section": "Common Scheduling Mistakes I",
    "text": "Common Scheduling Mistakes I\nLearn from others’ errors - avoid these pitfalls!\n\nQuestion: Any idea what could be common mistakes?\n\n\nMistake #1: Ignoring Setup Times\n\nProblem: Changing from between tasks requires adjustments\nImpact: Your “optimal” SPT schedule wastes 3 hours on setups\nFix: Batch similar tasks together (hybrid rule: SPT within batches)"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#common-scheduling-mistakes-ii",
    "href": "lectures/lec_06_presentation.html#common-scheduling-mistakes-ii",
    "title": "Smart Quick Decisions",
    "section": "Common Scheduling Mistakes II",
    "text": "Common Scheduling Mistakes II\nLearn from others’ errors - avoid these pitfalls!\nMistake #2: Static Scheduling with Dynamic Arrivals\n\nProblem: Using Johnson’s algorithm at 2 PM, never adjusting when urgent orders arrive at 4 PM\nImpact: New rush order sits idle while finishing low-priority work\nFix: Re-optimize periodically or use priority thresholds"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#common-scheduling-mistakes-iii",
    "href": "lectures/lec_06_presentation.html#common-scheduling-mistakes-iii",
    "title": "Smart Quick Decisions",
    "section": "Common Scheduling Mistakes III",
    "text": "Common Scheduling Mistakes III\nLearn from others’ errors - avoid these pitfalls!\nMistake #3: Optimizing the Wrong Metric\n\nProblem: Minimizing makespan when penalty costs dominate\nImpact: You “win” on time but lose €400 on penalties\nFix: Always align algorithm choice with total cost function"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#thrashing",
    "href": "lectures/lec_06_presentation.html#thrashing",
    "title": "Smart Quick Decisions",
    "section": "Thrashing",
    "text": "Thrashing\nWhen scheduling breaks down completely\n\nWhat is Thrashing?\n\nExcessive context switching between tasks\nOrganization overhead exceeds actual productivity\nMaximum activity, minimum output\n\n\n\nQuestion: Do you know this from your personally?"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#thrashing-warning-signs",
    "href": "lectures/lec_06_presentation.html#thrashing-warning-signs",
    "title": "Smart Quick Decisions",
    "section": "Thrashing Warning Signs",
    "text": "Thrashing Warning Signs\nHow to recognize when you’re thrashing\n\nIndividual Level:\n\nConstant task switching (&lt; 15 minutes per task)\nNothing getting completed despite being “busy”\nIncreasing stress and anxiety\nDeclining quality of work\nFeeling overwhelmed despite working hard"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#preventing-thrashing",
    "href": "lectures/lec_06_presentation.html#preventing-thrashing",
    "title": "Smart Quick Decisions",
    "section": "Preventing Thrashing",
    "text": "Preventing Thrashing\nStrategic approaches to maintain productivity\n\nStrategic Solutions:\n\nTask rejection threshold: Say no to new tasks when queue exceeds capacity\nMinimum work periods: Minimum focus time per task\nBatching: Group similar tasks (all emails at once, all calls at once)\nBuffer times: Schedule gaps between major tasks\nReduced reactivity: Check email at set times, not constantly"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#today",
    "href": "lectures/lec_06_presentation.html#today",
    "title": "Smart Quick Decisions",
    "section": "Today",
    "text": "Today\n\n\nHour 2: This Lecture\n\nGreedy algorithms\nFIFO, SPT, EDD rules\nTrade-offs\nGantt charts\n\n\nHour 3: Notebook\n\nBean Counter CEO\nImplement rules\nVisualizations\nAnalyze orders\n\n\nHour 4: Competition\n\nBike Factory Crisis\n16 bicycle orders\nTwo-stage process\nMinimize total costs!"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#the-competition-challenge",
    "href": "lectures/lec_06_presentation.html#the-competition-challenge",
    "title": "Smart Quick Decisions",
    "section": "The Competition Challenge",
    "text": "The Competition Challenge\nThe Bike Factory Crisis\n\n\nSchedule 16 custom bicycle orders across 2 workstations\nOptimize Assembly → Painting workflow\nBalance overtime costs vs. late delivery penalties\nMinimize total cost (overtime + penalties)\n\n\n\n\n\n\n\n\n\nChoose the right trade-off for the business context!"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#remember-this",
    "href": "lectures/lec_06_presentation.html#remember-this",
    "title": "Smart Quick Decisions",
    "section": "Remember This!",
    "text": "Remember This!\nThe Rules of Greedy Scheduling\n\nKnow your objective - Fairness, speed, or deadlines?\nFIFO for fairness - Simple, transparent, no favoritism\nSPT for throughput - Minimizes average completion time\nEDD for deadlines - Minimizes maximum lateness\nNo single winner - Each rule optimizes different metrics\nContext matters - Match the rule to your business goal\nTwo-stage is harder - Assembly → Painting adds complexity"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#final-thought",
    "href": "lectures/lec_06_presentation.html#final-thought",
    "title": "Smart Quick Decisions",
    "section": "Final Thought",
    "text": "Final Thought\nGreedy algorithms are about smart trade-offs\n\n\n\nThe Advantage:\n\nFast O(n log n)\nEasy to implement\nExplainable decisions\nOften near-optimal\nPractical for real-time\n\n\nThe Challenge:\n\nNo global optimality guarantee\nDifferent rules, different results\nThree-stage problems are complex\nMay need hybrid approaches"
  },
  {
    "objectID": "lectures/lec_06_presentation.html#break",
    "href": "lectures/lec_06_presentation.html#break",
    "title": "Smart Quick Decisions",
    "section": "Break!",
    "text": "Break!\nTake 20 minutes, then we start the practice notebook\nNext up: You’ll become Bean Counter’s scheduler\nThen: The Bike Factory Crisis competition"
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html",
    "href": "lectures/lec_08_multi_objective.html",
    "title": "Multi-Objective Optimization",
    "section": "",
    "text": ". . .\nOperations Director’s Dilemma:\n“EU regulations demand 40% emission cuts, but we can’t sacrifice profitability, service quality, or reliability!”\n\n\n\nEcoExpress operates regional last-mile delivery across 3 cities\n\n\nEU Green Deal: 40% emission reduction by 2025\nRising fuel costs (€2.1/L diesel)\nAmazon entering our market (speed pressure)\nDriver shortage (need automation-friendly vehicles)\n\n\n. . .\nQuestion: How do we transform our fleet while staying competitive?\n\n\n\nBy the end of this lecture, you will be able to:\n\n\nExplain why most real business decisions involve multiple competing objectives\nIdentify and visualize Pareto optimal solutions in multi-objective problems\nApply normalization techniques to make objectives comparable\nImplement weighted sum and ε-constraint methods to find trade-off solutions\nChoose the appropriate MOO method for different problem types\nMake data-driven decisions from a Pareto frontier\nAnalyze real-world multi-objective trade-offs (Amazon, airlines, Tesla)\n\n\n\n\n\nLast week we optimized routes for delivery:\n\n\nStarted with greedy construction (e.g. Nearest Neighbor)\nImproved with local search (e.g. 2-opt)\nConsidered time windows\nBut: We only optimized distance\n\n\n. . .\nQuestion: What if we also care about emissions, cost, AND customer satisfaction?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#client-briefing-ecoexpress-logistics",
    "href": "lectures/lec_08_multi_objective.html#client-briefing-ecoexpress-logistics",
    "title": "Multi-Objective Optimization",
    "section": "",
    "text": ". . .\nOperations Director’s Dilemma:\n“EU regulations demand 40% emission cuts, but we can’t sacrifice profitability, service quality, or reliability!”",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#the-fleet-challenge",
    "href": "lectures/lec_08_multi_objective.html#the-fleet-challenge",
    "title": "Multi-Objective Optimization",
    "section": "",
    "text": "EcoExpress operates regional last-mile delivery across 3 cities\n\n\nEU Green Deal: 40% emission reduction by 2025\nRising fuel costs (€2.1/L diesel)\nAmazon entering our market (speed pressure)\nDriver shortage (need automation-friendly vehicles)\n\n\n. . .\nQuestion: How do we transform our fleet while staying competitive?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#todays-learning-objectives",
    "href": "lectures/lec_08_multi_objective.html#todays-learning-objectives",
    "title": "Multi-Objective Optimization",
    "section": "",
    "text": "By the end of this lecture, you will be able to:\n\n\nExplain why most real business decisions involve multiple competing objectives\nIdentify and visualize Pareto optimal solutions in multi-objective problems\nApply normalization techniques to make objectives comparable\nImplement weighted sum and ε-constraint methods to find trade-off solutions\nChoose the appropriate MOO method for different problem types\nMake data-driven decisions from a Pareto frontier\nAnalyze real-world multi-objective trade-offs (Amazon, airlines, Tesla)",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#quick-recap-local-search",
    "href": "lectures/lec_08_multi_objective.html#quick-recap-local-search",
    "title": "Multi-Objective Optimization",
    "section": "",
    "text": "Last week we optimized routes for delivery:\n\n\nStarted with greedy construction (e.g. Nearest Neighbor)\nImproved with local search (e.g. 2-opt)\nConsidered time windows\nBut: We only optimized distance\n\n\n. . .\nQuestion: What if we also care about emissions, cost, AND customer satisfaction?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#single-vs-multi-objective",
    "href": "lectures/lec_08_multi_objective.html#single-vs-multi-objective",
    "title": "Multi-Objective Optimization",
    "section": "Single vs Multi-Objective",
    "text": "Single vs Multi-Objective\nSingle Objective\n\n“Minimize total distance”\nClear winner. Easy, right!\n\n. . .\nMultiple Objectives\n\n“Minimize cost AND emissions AND maximize speed”\nNo clear answer…\n\n. . .\nQuestion: Any idea how to approach this?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#ecoexpress-vehicle-options",
    "href": "lectures/lec_08_multi_objective.html#ecoexpress-vehicle-options",
    "title": "Multi-Objective Optimization",
    "section": "EcoExpress Vehicle Options",
    "text": "EcoExpress Vehicle Options\n\n\n\n\n\nType\nPurchase Cost (€)\nOperating (€/km)\nCO2 (g/km)\nSpeed (km/h)\nCapacity (parcels)\nRange (km)\n\n\n\n\nE-Truck\n75000\n0.18\n0\n55\n300\n250\n\n\nHybrid Van\n45000\n0.25\n95\n65\n200\n600\n\n\nDiesel Van\n35000\n0.38\n185\n70\n250\n800\n\n\nE-Cargo Bike\n12000\n0.05\n0\n30\n50\n60\n\n\nAutonomous\n95000\n0.12\n0\n40\n150\n180\n\n\n\n\n\n. . .\nQuestion: Which vehicle is “best” for EcoExpress?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#trade-offs-everywhere",
    "href": "lectures/lec_08_multi_objective.html#trade-offs-everywhere",
    "title": "Multi-Objective Optimization",
    "section": "Trade-offs Everywhere",
    "text": "Trade-offs Everywhere\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nEvery vehicle excels at something different!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#real-business-constraints",
    "href": "lectures/lec_08_multi_objective.html#real-business-constraints",
    "title": "Multi-Objective Optimization",
    "section": "Real Business Constraints",
    "text": "Real Business Constraints\nBeyond the numbers, consider:\n\n\nEU regulations: Carbon tax of €100/ton CO₂ starting 2025\nCompetition: Amazon promises 2-hour delivery\nLabor market: Autonomous vehicles reduce driver dependency\nUrban zones: Zero-emission zones in city centers\nPeak times: Black Friday = 3x normal volume\n\n\n. . .\n\n\n\n\n\n\nThere is no single “optimal” solution - only trade-offs",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#dominated-solutions",
    "href": "lectures/lec_08_multi_objective.html#dominated-solutions",
    "title": "Multi-Objective Optimization",
    "section": "Dominated Solutions",
    "text": "Dominated Solutions\nA solution is dominated if another solution is:\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nBetter in at least one objective and not worse in any objective!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#the-pareto-frontier",
    "href": "lectures/lec_08_multi_objective.html#the-pareto-frontier",
    "title": "Multi-Objective Optimization",
    "section": "The Pareto Frontier",
    "text": "The Pareto Frontier\nThe Pareto frontier is the set of all non-dominated solutions\n\n\nNo solution is objectively “better”\nEach represents a different trade-off\nMoving along frontier: gain in one objective, loss in another\nDecision makers choose based on preferences\n\n\n. . .\nQuestion Do you think you get the idea?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#find-the-non-dominated",
    "href": "lectures/lec_08_multi_objective.html#find-the-non-dominated",
    "title": "Multi-Objective Optimization",
    "section": "Find the Non-Dominated",
    "text": "Find the Non-Dominated\n\n\n\n\n\n\n\n\n\n. . .\nQuestion: Which fleets are non-dominated?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#three-objectives",
    "href": "lectures/lec_08_multi_objective.html#three-objectives",
    "title": "Multi-Objective Optimization",
    "section": "Three+ Objectives",
    "text": "Three+ Objectives\nWith 3 objectives, the Pareto frontier becomes a surface:\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nHarder to visualize, but same principle applies!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#multi-objective-transportation",
    "href": "lectures/lec_08_multi_objective.html#multi-objective-transportation",
    "title": "Multi-Objective Optimization",
    "section": "Multi-Objective Transportation",
    "text": "Multi-Objective Transportation\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nLogistics decisions involve trade-offs: City traffic (slow, high emissions), Night delivery? → Highway (fast, but more distance), Customer priority? → Direct route (expensive)",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#classic-transportation",
    "href": "lectures/lec_08_multi_objective.html#classic-transportation",
    "title": "Multi-Objective Optimization",
    "section": "Classic Transportation",
    "text": "Classic Transportation\nLet’s understand the foundation\n. . .\n\n\n\n\n\nFrom/To\nZone A\nZone B\nZone C\nZone D\nSupply\n\n\n\n\nDC Berlin\n8\n10\n11\n14\n300\n\n\nDC Hamburg\n12\n9\n7\n8\n250\n\n\nDC Munich\n15\n13\n10\n9\n200\n\n\nDemand\n200\n180\n220\n150\n750\n\n\n\n\n\n\n\n\n\n\n\nCost per 100 parcels (€) in the middle of the table!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#objective-function",
    "href": "lectures/lec_08_multi_objective.html#objective-function",
    "title": "Multi-Objective Optimization",
    "section": "Objective Function",
    "text": "Objective Function\nThe foundation of the classical model\n\\[\\text{Minimize } Z = \\sum_{i} \\sum_{j} c_{ij} \\cdot x_{ij}\\]\nWhere:\n\n\\(x_{ij}\\) = parcels shipped from DC \\(i\\) to Zone \\(j\\)\n\\(c_{ij}\\) = cost per 100 parcels from \\(i\\) to \\(j\\)",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#second-objective-emissions",
    "href": "lectures/lec_08_multi_objective.html#second-objective-emissions",
    "title": "Multi-Objective Optimization",
    "section": "Second Objective: Emissions",
    "text": "Second Objective: Emissions\nNow the real challenge - each route has different emissions:\n\n\n\n\n\nFrom/To\nZone A\nZone B\nZone C\nZone D\n\n\n\n\nDC Berlin\n120\n95\n85\n70\n\n\nDC Hamburg\n45\n110\n100\n90\n\n\nDC Munich\n60\n50\n115\n105\n\n\n\n\n\n\n\n\n\n\n\nEmissions per parcel (g CO₂) in the table",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#objective-function-ii",
    "href": "lectures/lec_08_multi_objective.html#objective-function-ii",
    "title": "Multi-Objective Optimization",
    "section": "Objective Function II",
    "text": "Objective Function II\nNow with two objectives!\n\\[\\text{Minimize } Z_1 = \\sum_{i} \\sum_{j} c_{ij} \\cdot x_{ij} \\quad \\text{(Cost)}\\] \\[\\text{Minimize } Z_2 = \\sum_{i} \\sum_{j} e_{ij} \\cdot x_{ij} \\quad \\text{(Emissions)}\\]\nWhere \\(e_{ij}\\) = emissions per parcel from \\(i\\) to \\(j\\)\n. . .\nNotice: Cheapest routes ≠ Greenest routes!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#data-source",
    "href": "lectures/lec_08_multi_objective.html#data-source",
    "title": "Multi-Objective Optimization",
    "section": "Data Source",
    "text": "Data Source\nWhere Do These Numbers Come From?\n. . .\nCost Data:\n\n\nHistorical records: Your accounting system\nQuotes: Request from carriers/suppliers\n\nAPIs: Google Maps Distance Matrix (distance → cost)\n\n\n. . .\nEmissions Data:\n\n\nEU Standards or Carrier data\nFormula: Emissions = Distance × Weight × EmissionFactor",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#the-transportation-trade-off",
    "href": "lectures/lec_08_multi_objective.html#the-transportation-trade-off",
    "title": "Multi-Objective Optimization",
    "section": "The Transportation Trade-off",
    "text": "The Transportation Trade-off\n\n\n\n\n\n\n\n\n\nCost increase for greenest solution: +€26800 (42.1%)\nEmissions reduction from cheapest: -32.2 kg (39.9%)\n\n\n. . .\n\n\n\n\n\n\nEach point represents a different allocation strategy!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#multi-objective-optimization",
    "href": "lectures/lec_08_multi_objective.html#multi-objective-optimization",
    "title": "Multi-Objective Optimization",
    "section": "Multi-Objective Optimization",
    "text": "Multi-Objective Optimization\nYou can use optimization solvers or heuristics!\n. . .\n\n\nWith Optimization Solvers\n\nWeighted Sum Method\nε-Constraint Method\n\nGoal Programming\nOptimal solutions\nNeed mathematical model\n\n\nWith Heuristics\n\nWeighted Greedy Construction\nMulti-Objective Local Search\nMetaheuristics\nGood solutions, fast\nNo optimality proof\n\n\n\n. . .\n\n\n\n\n\n\nIn this lecture we use heuristic approaches!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#foundation-extreme-points",
    "href": "lectures/lec_08_multi_objective.html#foundation-extreme-points",
    "title": "Multi-Objective Optimization",
    "section": "Foundation: Extreme Points",
    "text": "Foundation: Extreme Points\nFirst step for BOTH approaches - find the boundaries:\n\n\n\n\n\n\n\n\n\n. . .\nQuestion: Why is normalization essential?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#critical-normalization",
    "href": "lectures/lec_08_multi_objective.html#critical-normalization",
    "title": "Multi-Objective Optimization",
    "section": "Critical: Normalization",
    "text": "Critical: Normalization\nWithout it, your analysis is meaningless\n\n\n\n\n\n\n\n\n\n. . .\nQuestion: Any intuition on how to do [0,1] normalization?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#how-to-normalize",
    "href": "lectures/lec_08_multi_objective.html#how-to-normalize",
    "title": "Multi-Objective Optimization",
    "section": "How to Normalize",
    "text": "How to Normalize\nThe Normalization Formula for [0,1]\n\\[\\text{Normalized}_i = \\frac{x_i - x_{min}}{x_{max} - x_{min}}\\]\n. . .\nIn Python, this is rather simple!\n. . .\ndef normalize_objectives(data):\n    return (data - data.min()) / (data.max() - data.min())\n\n# Now weights actually mean something\nweighted_score = w1 * normalize(cost) + w2 * normalize(emissions)\n. . .\n\n\n\n\n\n\nEasy, right?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#extreme-points",
    "href": "lectures/lec_08_multi_objective.html#extreme-points",
    "title": "Multi-Objective Optimization",
    "section": "Extreme Points",
    "text": "Extreme Points\nThere are several reasons why extreme points matter:\n\nTrade-off Space: Min/max values bound your Pareto frontier\nEnable Proper Normalization: Need ranges for scaling to [0,1]\nFeasibility: If single objectives not achievable, problem infeasible\nStakeholder: “Best cost is €50k, best emissions is 40kg”\n\n. . .\nImplementation Pattern:\ndef find_extreme_points(problem):\n    # Solve for minimum cost (ignore emissions)\n    min_cost_solution = minimize(cost_objective, constraints)\n    # Solve for minimum emissions (ignore cost)\n    min_emissions_solution = minimize(emissions_objective, constraints)",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#computational-complexity",
    "href": "lectures/lec_08_multi_objective.html#computational-complexity",
    "title": "Multi-Objective Optimization",
    "section": "Computational Complexity",
    "text": "Computational Complexity\nHow hard does it get with more objectives?\n. . .\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nWhy? Because there are just way more potential solutions to check!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#solver-based-methods",
    "href": "lectures/lec_08_multi_objective.html#solver-based-methods",
    "title": "Multi-Objective Optimization",
    "section": "Solver-Based Methods",
    "text": "Solver-Based Methods\nQuick overview - you won’t implement these in assignments\n\n\nWeighted Sum: Minimize \\(w_1 \\times \\text{cost} + w_2 \\times \\text{emissions}\\)\n\nSimple, fast for convex problems\n\nε-Constraint: Minimize cost subject to emissions \\(\\leq \\varepsilon\\)\n\nSystematically vary \\(\\varepsilon\\) to find complete frontier\n\nGoal Programming: Minimize deviations from targets\n\nSet target for each objective, minimize weighted deviations\n\n\n\n. . .\n\n\n\n\n\n\nFor your fleet optimization: You’ll use heuristic approaches instead!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#the-heuristic-strategy",
    "href": "lectures/lec_08_multi_objective.html#the-heuristic-strategy",
    "title": "Multi-Objective Optimization",
    "section": "The Heuristic Strategy",
    "text": "The Heuristic Strategy\nFor problems without mathematical models\n. . .\n\n\nConstruction: Build initial solutions with weighted greedy\nImprovement: Multi-objective local search\nSelection: Filter dominated solutions to find Pareto frontier\n\n\n. . .\n\n\n\n\n\n\nKey difference from solvers:\n\nSolvers: Need mathematical model, guarantee optimality\nHeuristics: Work with any evaluation function, find good solutions fast",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#why-heuristics",
    "href": "lectures/lec_08_multi_objective.html#why-heuristics",
    "title": "Multi-Objective Optimization",
    "section": "Why Heuristics?",
    "text": "Why Heuristics?\nDepending on the problem:\n\n\nCombinatorial explosion\nHuge solution space even for one problem\nEvaluating one solution might thus take too long\nNeed diverse Pareto frontier, not just one “optimal” solution\nOpen Source Solvers too slow\nCommercial solvers too expensive\n\n\n. . .\nQuestion: How do we build good solutions without a solver?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#the-three-stage-heuristic-process",
    "href": "lectures/lec_08_multi_objective.html#the-three-stage-heuristic-process",
    "title": "Multi-Objective Optimization",
    "section": "The Three-Stage Heuristic Process",
    "text": "The Three-Stage Heuristic Process\n\n\n\n\n\n\n\n\n\n. . .\nThis is what you’ll implement in your assignments!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#construction-methods-for-moo",
    "href": "lectures/lec_08_multi_objective.html#construction-methods-for-moo",
    "title": "Multi-Objective Optimization",
    "section": "Construction Methods for MOO",
    "text": "Construction Methods for MOO\nHow to build initial solutions when you have multiple objectives?\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nThree choices (for starters). Let’s check them out!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#weighted-greedy-construction",
    "href": "lectures/lec_08_multi_objective.html#weighted-greedy-construction",
    "title": "Multi-Objective Optimization",
    "section": "Weighted Greedy Construction",
    "text": "Weighted Greedy Construction\nMaking greedy choices on a weighted objective\n\n\nChoose weight vector w = (w₁, w₂)\nAt each step, pick the choice that minimizes: \\[w_1 \\cdot \\text{cost}(x) + w_2 \\cdot \\text{emissions}(x)\\]\nBuild complete solution greedily\nRepeat with different weights to explore frontier\n\n\n. . .\n\n\n\n\n\n\nDifferent weights explore different trade-offs! Easy, right?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#sequential-greedy-lexicographic",
    "href": "lectures/lec_08_multi_objective.html#sequential-greedy-lexicographic",
    "title": "Multi-Objective Optimization",
    "section": "Sequential Greedy (Lexicographic)",
    "text": "Sequential Greedy (Lexicographic)\nOptimize one objective at a time, in priority order\n\n\nRank objectives by priority\n\nE.g. cost (most important) and then emissions (tie-breaker)\n\nAt each step:\n\nFind choices that minimize primary objective\nIf tie → use secondary objective\n\nBuild one working solution\n\n\n. . .\n\n\n\n\n\n\nWe could also accept primary values within 10% of best so secondary has more influence!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#diverse-starting-pool",
    "href": "lectures/lec_08_multi_objective.html#diverse-starting-pool",
    "title": "Multi-Objective Optimization",
    "section": "Diverse Starting Pool",
    "text": "Diverse Starting Pool\nGenerate many random solutions, keep the non-dominated ones\n\n\nGenerate N random solutions (e.g., N=100)\nEvaluate all solutions on both objectives\nFilter to keep only non-dominated solutions\nResult: A diverse set of Pareto-optimal solutions\n\n\n. . .\n\n\n\n\n\n\n\nExplores entire solution space\nNo bias toward specific weights\nGreat for warm-starting local search",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#local-search-for-multi-objective",
    "href": "lectures/lec_08_multi_objective.html#local-search-for-multi-objective",
    "title": "Multi-Objective Optimization",
    "section": "Local Search for Multi-Objective",
    "text": "Local Search for Multi-Objective\nSpecial moves that improve multiple objectives:\n\n\n\n\n\n\n\n\n\n. . .\nQuestion: Which moves are acceptable?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#moo-local-search-rules",
    "href": "lectures/lec_08_multi_objective.html#moo-local-search-rules",
    "title": "Multi-Objective Optimization",
    "section": "MOO Local Search Rules",
    "text": "MOO Local Search Rules\nAccept a move if:\n\nDominance: New solution dominates current (win-win!)\nTrade-off: Improves primary, acceptable loss in secondary\nDiversity: Fills gap in current Pareto front\nProbabilistic: Use temperature (like simulated annealing)\n\n. . .\n\n\n\n\n\n\nAlways keep all your objectives in mind when making decisions.",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#how-to-choose",
    "href": "lectures/lec_08_multi_objective.html#how-to-choose",
    "title": "Multi-Objective Optimization",
    "section": "How to Choose!",
    "text": "How to Choose!\n\n\nThe Knee Point: Find the “elbow” where improvement slows\nSatisficing Levels: Set minimum acceptable thresholds\n\nCost must be &lt; €100k (budget constraint)\nEmissions must be &lt; 100 kg (regulatory limit)\nService level must be &gt; 90% (customer requirement)\n\nStakeholder Preferences: Let business priorities guide\n\nSustainability: Minimum emissions that meets constraints\nOperations: Maximum service level within budget",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#weighted-sum-along-the-frontier",
    "href": "lectures/lec_08_multi_objective.html#weighted-sum-along-the-frontier",
    "title": "Multi-Objective Optimization",
    "section": "Weighted Sum Along the Frontier",
    "text": "Weighted Sum Along the Frontier\nThe weight influences the final choice:\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nThe iso-cost lines show the trade-offs between cost and emissions.",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#weighting-has-an-impact",
    "href": "lectures/lec_08_multi_objective.html#weighting-has-an-impact",
    "title": "Multi-Objective Optimization",
    "section": "Weighting has an Impact",
    "text": "Weighting has an Impact\nThe weights thus reflect your values!\n\n\n\n\n\n\n\n\n\n. . .\n\n\n\n\n\n\nDepending on your weight, the choice will vary.",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#speed-vs-sustainability-dilemma",
    "href": "lectures/lec_08_multi_objective.html#speed-vs-sustainability-dilemma",
    "title": "Multi-Objective Optimization",
    "section": "Speed vs Sustainability Dilemma",
    "text": "Speed vs Sustainability Dilemma\nThe Three-Way Trade-off in E-Commerce\n\nMinimize Delivery Time (1-day/2-hour promise)\nMinimize Cost (fuel, labor, fulfillment)\nMinimize Environmental Impact (carbon footprint)\n\n. . .\nFaster delivery = More vehicles less full = Higher emissions\n. . .\nQuestion: What could retailers do?",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#moving-the-frontier",
    "href": "lectures/lec_08_multi_objective.html#moving-the-frontier",
    "title": "Multi-Objective Optimization",
    "section": "Moving the Frontier",
    "text": "Moving the Frontier\nInstead of point on the frontier, move the entire frontier:\n. . .\nQuestion: Any idea of examples?\n. . .\n\n\n\n\n\n\nR&D can fundamentally change what’s possible!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#today",
    "href": "lectures/lec_08_multi_objective.html#today",
    "title": "Multi-Objective Optimization",
    "section": "Today",
    "text": "Today\n\n\nHour 2: This Lecture\n\nMulti-objective\nPareto optimality\nWeighted greedy\nLocal search MOO\n\n\nHour 3: Notebook\n\nBean Counter CEO\nFind Pareto frontier\nApply weighted greedy\nNormalize objectives\n\n\nHour 4: Competition\n\nTransportation problem\nFleet selection\nCost vs emissions\nJustify choice!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#the-competition-challenge",
    "href": "lectures/lec_08_multi_objective.html#the-competition-challenge",
    "title": "Multi-Objective Optimization",
    "section": "The Competition Challenge",
    "text": "The Competition Challenge\nEcoExpress Sustainable Fleet Design\n. . .\n\nSolve multi-objective transportation (DCs → Zones)\nSelect optimal fleet mix (5 vehicle types)\nBalance cost, emissions, service quality\nMeet EU emission targets (40% reduction)\n\n. . .\n\n\n\n\n\n\nFind the best trade-off for your business priorities!",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#choosing-your-moo-approach",
    "href": "lectures/lec_08_multi_objective.html#choosing-your-moo-approach",
    "title": "Multi-Objective Optimization",
    "section": "Choosing Your MOO Approach",
    "text": "Choosing Your MOO Approach\nDifferent situations call for different methods:\n\n\n\nSituation\nBest\nWhy\n\n\n\n\nClear priorities\nSequential greedy\nFast, hierarchy\n\n\nExploring\nWeighted greedy\nDifferent solutions\n\n\nMany solutions\nDiverse pool\nBuilds frontier\n\n\nQuick solution\nSingle weighted\nOne good compromise\n\n\nImprove existing\nMulti-objective local\nRefines trade-offs\n\n\n\n. . .\n\n\n\n\n\n\nCompetition? Generate diverse pool or weigted, then improve with local search.",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#implementation-pitfalls-to-avoid",
    "href": "lectures/lec_08_multi_objective.html#implementation-pitfalls-to-avoid",
    "title": "Multi-Objective Optimization",
    "section": "Implementation Pitfalls to Avoid",
    "text": "Implementation Pitfalls to Avoid\nCommon bugs that cost you time:\n\n\nForgetting to Normalize\n\nAlways normalize to [0,1] first!\n\nOptimizing Too Many Objectives\n\n2-3: Manageable, 4+: Exponentially harder\nCombine related objectives or use constraints\n\nNot Checking Solution Feasibility\n\nAlways verify constraints after optimization",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#summary",
    "href": "lectures/lec_08_multi_objective.html#summary",
    "title": "Multi-Objective Optimization",
    "section": "Summary",
    "text": "Summary\nKey Takeaways:\n\n\nReal decisions have multiple conflicting objectives\nPareto frontier shows all rational trade-offs\nNormalization is essential for fair comparison\nWeighted sum works for convex frontiers\nε-constraint handles non-convex cases\nWeights reflect values, make them explicit\nVisualization crucial for decision-making",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_multi_objective.html#break",
    "href": "lectures/lec_08_multi_objective.html#break",
    "title": "Multi-Objective Optimization",
    "section": "Break!",
    "text": "Break!\nTake 20 minutes, then we start the practice notebook\nNext up: You’ll become Bean Counter’s expert\nThen: The Sustainability competition",
    "crumbs": [
      "08 Multi Objective",
      "08 Lecture"
    ]
  },
  {
    "objectID": "lectures/lec_08_presentation.html#client-briefing-ecoexpress-logistics",
    "href": "lectures/lec_08_presentation.html#client-briefing-ecoexpress-logistics",
    "title": "Multi-Objective Optimization",
    "section": "Client Briefing: EcoExpress Logistics",
    "text": "Client Briefing: EcoExpress Logistics\n\nOperations Director’s Dilemma:\n“EU regulations demand 40% emission cuts, but we can’t sacrifice profitability, service quality, or reliability!”"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#the-fleet-challenge",
    "href": "lectures/lec_08_presentation.html#the-fleet-challenge",
    "title": "Multi-Objective Optimization",
    "section": "The Fleet Challenge",
    "text": "The Fleet Challenge\nEcoExpress operates regional last-mile delivery across 3 cities\n\nEU Green Deal: 40% emission reduction by 2025\nRising fuel costs (€2.1/L diesel)\nAmazon entering our market (speed pressure)\nDriver shortage (need automation-friendly vehicles)\n\n\nQuestion: How do we transform our fleet while staying competitive?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#todays-learning-objectives",
    "href": "lectures/lec_08_presentation.html#todays-learning-objectives",
    "title": "Multi-Objective Optimization",
    "section": "Today’s Learning Objectives",
    "text": "Today’s Learning Objectives\nBy the end of this lecture, you will be able to:\n\nExplain why most real business decisions involve multiple competing objectives\nIdentify and visualize Pareto optimal solutions in multi-objective problems\nApply normalization techniques to make objectives comparable\nImplement weighted sum and ε-constraint methods to find trade-off solutions\nChoose the appropriate MOO method for different problem types\nMake data-driven decisions from a Pareto frontier\nAnalyze real-world multi-objective trade-offs (Amazon, airlines, Tesla)"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#quick-recap-local-search",
    "href": "lectures/lec_08_presentation.html#quick-recap-local-search",
    "title": "Multi-Objective Optimization",
    "section": "Quick Recap: Local Search",
    "text": "Quick Recap: Local Search\nLast week we optimized routes for delivery:\n\nStarted with greedy construction (e.g. Nearest Neighbor)\nImproved with local search (e.g. 2-opt)\nConsidered time windows\nBut: We only optimized distance\n\n\nQuestion: What if we also care about emissions, cost, AND customer satisfaction?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#single-vs-multi-objective",
    "href": "lectures/lec_08_presentation.html#single-vs-multi-objective",
    "title": "Multi-Objective Optimization",
    "section": "Single vs Multi-Objective",
    "text": "Single vs Multi-Objective\nSingle Objective\n\n“Minimize total distance”\nClear winner. Easy, right!\n\n\nMultiple Objectives\n\n“Minimize cost AND emissions AND maximize speed”\nNo clear answer…\n\n\n\nQuestion: Any idea how to approach this?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#ecoexpress-vehicle-options",
    "href": "lectures/lec_08_presentation.html#ecoexpress-vehicle-options",
    "title": "Multi-Objective Optimization",
    "section": "EcoExpress Vehicle Options",
    "text": "EcoExpress Vehicle Options\n\n\n\n\n\nType\nPurchase Cost (€)\nOperating (€/km)\nCO2 (g/km)\nSpeed (km/h)\nCapacity (parcels)\nRange (km)\n\n\n\n\nE-Truck\n75000\n0.18\n0\n55\n300\n250\n\n\nHybrid Van\n45000\n0.25\n95\n65\n200\n600\n\n\nDiesel Van\n35000\n0.38\n185\n70\n250\n800\n\n\nE-Cargo Bike\n12000\n0.05\n0\n30\n50\n60\n\n\nAutonomous\n95000\n0.12\n0\n40\n150\n180\n\n\n\n\n\n\nQuestion: Which vehicle is “best” for EcoExpress?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#trade-offs-everywhere",
    "href": "lectures/lec_08_presentation.html#trade-offs-everywhere",
    "title": "Multi-Objective Optimization",
    "section": "Trade-offs Everywhere",
    "text": "Trade-offs Everywhere\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvery vehicle excels at something different!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#real-business-constraints",
    "href": "lectures/lec_08_presentation.html#real-business-constraints",
    "title": "Multi-Objective Optimization",
    "section": "Real Business Constraints",
    "text": "Real Business Constraints\nBeyond the numbers, consider:\n\nEU regulations: Carbon tax of €100/ton CO₂ starting 2025\nCompetition: Amazon promises 2-hour delivery\nLabor market: Autonomous vehicles reduce driver dependency\nUrban zones: Zero-emission zones in city centers\nPeak times: Black Friday = 3x normal volume\n\n\n\n\n\n\n\n\nThere is no single “optimal” solution - only trade-offs"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#dominated-solutions",
    "href": "lectures/lec_08_presentation.html#dominated-solutions",
    "title": "Multi-Objective Optimization",
    "section": "Dominated Solutions",
    "text": "Dominated Solutions\nA solution is dominated if another solution is:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBetter in at least one objective and not worse in any objective!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#the-pareto-frontier",
    "href": "lectures/lec_08_presentation.html#the-pareto-frontier",
    "title": "Multi-Objective Optimization",
    "section": "The Pareto Frontier",
    "text": "The Pareto Frontier\nThe Pareto frontier is the set of all non-dominated solutions\n\nNo solution is objectively “better”\nEach represents a different trade-off\nMoving along frontier: gain in one objective, loss in another\nDecision makers choose based on preferences\n\n\nQuestion Do you think you get the idea?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#find-the-non-dominated",
    "href": "lectures/lec_08_presentation.html#find-the-non-dominated",
    "title": "Multi-Objective Optimization",
    "section": "Find the Non-Dominated",
    "text": "Find the Non-Dominated\n\n\n\n\n\n\n\n\n\n\nQuestion: Which fleets are non-dominated?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#three-objectives",
    "href": "lectures/lec_08_presentation.html#three-objectives",
    "title": "Multi-Objective Optimization",
    "section": "Three+ Objectives",
    "text": "Three+ Objectives\nWith 3 objectives, the Pareto frontier becomes a surface:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHarder to visualize, but same principle applies!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#multi-objective-transportation",
    "href": "lectures/lec_08_presentation.html#multi-objective-transportation",
    "title": "Multi-Objective Optimization",
    "section": "Multi-Objective Transportation",
    "text": "Multi-Objective Transportation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLogistics decisions involve trade-offs: City traffic (slow, high emissions), Night delivery? → Highway (fast, but more distance), Customer priority? → Direct route (expensive)"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#classic-transportation",
    "href": "lectures/lec_08_presentation.html#classic-transportation",
    "title": "Multi-Objective Optimization",
    "section": "Classic Transportation",
    "text": "Classic Transportation\nLet’s understand the foundation\n\n\n\n\n\n\nFrom/To\nZone A\nZone B\nZone C\nZone D\nSupply\n\n\n\n\nDC Berlin\n8\n10\n11\n14\n300\n\n\nDC Hamburg\n12\n9\n7\n8\n250\n\n\nDC Munich\n15\n13\n10\n9\n200\n\n\nDemand\n200\n180\n220\n150\n750\n\n\n\n\n\n\n\n\n\n\n\nCost per 100 parcels (€) in the middle of the table!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#objective-function",
    "href": "lectures/lec_08_presentation.html#objective-function",
    "title": "Multi-Objective Optimization",
    "section": "Objective Function",
    "text": "Objective Function\nThe foundation of the classical model\n\\[\\text{Minimize } Z = \\sum_{i} \\sum_{j} c_{ij} \\cdot x_{ij}\\]\nWhere:\n\n\\(x_{ij}\\) = parcels shipped from DC \\(i\\) to Zone \\(j\\)\n\\(c_{ij}\\) = cost per 100 parcels from \\(i\\) to \\(j\\)"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#second-objective-emissions",
    "href": "lectures/lec_08_presentation.html#second-objective-emissions",
    "title": "Multi-Objective Optimization",
    "section": "Second Objective: Emissions",
    "text": "Second Objective: Emissions\nNow the real challenge - each route has different emissions:\n\n\n\n\n\nFrom/To\nZone A\nZone B\nZone C\nZone D\n\n\n\n\nDC Berlin\n120\n95\n85\n70\n\n\nDC Hamburg\n45\n110\n100\n90\n\n\nDC Munich\n60\n50\n115\n105\n\n\n\n\n\n\n\n\n\n\n\nEmissions per parcel (g CO₂) in the table"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#objective-function-ii",
    "href": "lectures/lec_08_presentation.html#objective-function-ii",
    "title": "Multi-Objective Optimization",
    "section": "Objective Function II",
    "text": "Objective Function II\nNow with two objectives!\n\\[\\text{Minimize } Z_1 = \\sum_{i} \\sum_{j} c_{ij} \\cdot x_{ij} \\quad \\text{(Cost)}\\] \\[\\text{Minimize } Z_2 = \\sum_{i} \\sum_{j} e_{ij} \\cdot x_{ij} \\quad \\text{(Emissions)}\\]\nWhere \\(e_{ij}\\) = emissions per parcel from \\(i\\) to \\(j\\)\n\nNotice: Cheapest routes ≠ Greenest routes!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#data-source",
    "href": "lectures/lec_08_presentation.html#data-source",
    "title": "Multi-Objective Optimization",
    "section": "Data Source",
    "text": "Data Source\nWhere Do These Numbers Come From?\n\nCost Data:\n\nHistorical records: Your accounting system\nQuotes: Request from carriers/suppliers\n\nAPIs: Google Maps Distance Matrix (distance → cost)\n\n\n\nEmissions Data:\n\nEU Standards or Carrier data\nFormula: Emissions = Distance × Weight × EmissionFactor"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#the-transportation-trade-off",
    "href": "lectures/lec_08_presentation.html#the-transportation-trade-off",
    "title": "Multi-Objective Optimization",
    "section": "The Transportation Trade-off",
    "text": "The Transportation Trade-off\n\n\n\n\n\n\n\n\n\nCost increase for greenest solution: +€26800 (42.1%)\nEmissions reduction from cheapest: -32.2 kg (39.9%)\n\n\n\n\n\n\n\n\n\nEach point represents a different allocation strategy!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#multi-objective-optimization",
    "href": "lectures/lec_08_presentation.html#multi-objective-optimization",
    "title": "Multi-Objective Optimization",
    "section": "Multi-Objective Optimization",
    "text": "Multi-Objective Optimization\nYou can use optimization solvers or heuristics!\n\n\n\nWith Optimization Solvers\n\nWeighted Sum Method\nε-Constraint Method\n\nGoal Programming\nOptimal solutions\nNeed mathematical model\n\n\nWith Heuristics\n\nWeighted Greedy Construction\nMulti-Objective Local Search\nMetaheuristics\nGood solutions, fast\nNo optimality proof\n\n\n\n\n\n\n\n\n\n\nIn this lecture we use heuristic approaches!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#foundation-extreme-points",
    "href": "lectures/lec_08_presentation.html#foundation-extreme-points",
    "title": "Multi-Objective Optimization",
    "section": "Foundation: Extreme Points",
    "text": "Foundation: Extreme Points\nFirst step for BOTH approaches - find the boundaries:\n\n\n\n\n\n\n\n\n\n\nQuestion: Why is normalization essential?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#critical-normalization",
    "href": "lectures/lec_08_presentation.html#critical-normalization",
    "title": "Multi-Objective Optimization",
    "section": "Critical: Normalization",
    "text": "Critical: Normalization\nWithout it, your analysis is meaningless\n\n\n\n\n\n\n\n\n\n\nQuestion: Any intuition on how to do [0,1] normalization?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#how-to-normalize",
    "href": "lectures/lec_08_presentation.html#how-to-normalize",
    "title": "Multi-Objective Optimization",
    "section": "How to Normalize",
    "text": "How to Normalize\nThe Normalization Formula for [0,1]\n\\[\\text{Normalized}_i = \\frac{x_i - x_{min}}{x_{max} - x_{min}}\\]\n\nIn Python, this is rather simple!\n\n\ndef normalize_objectives(data):\n    return (data - data.min()) / (data.max() - data.min())\n\n# Now weights actually mean something\nweighted_score = w1 * normalize(cost) + w2 * normalize(emissions)\n\n\n\n\n\n\n\n\nEasy, right?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#extreme-points",
    "href": "lectures/lec_08_presentation.html#extreme-points",
    "title": "Multi-Objective Optimization",
    "section": "Extreme Points",
    "text": "Extreme Points\nThere are several reasons why extreme points matter:\n\nTrade-off Space: Min/max values bound your Pareto frontier\nEnable Proper Normalization: Need ranges for scaling to [0,1]\nFeasibility: If single objectives not achievable, problem infeasible\nStakeholder: “Best cost is €50k, best emissions is 40kg”\n\n\nImplementation Pattern:\ndef find_extreme_points(problem):\n    # Solve for minimum cost (ignore emissions)\n    min_cost_solution = minimize(cost_objective, constraints)\n    # Solve for minimum emissions (ignore cost)\n    min_emissions_solution = minimize(emissions_objective, constraints)"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#computational-complexity",
    "href": "lectures/lec_08_presentation.html#computational-complexity",
    "title": "Multi-Objective Optimization",
    "section": "Computational Complexity",
    "text": "Computational Complexity\nHow hard does it get with more objectives?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy? Because there are just way more potential solutions to check!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#solver-based-methods",
    "href": "lectures/lec_08_presentation.html#solver-based-methods",
    "title": "Multi-Objective Optimization",
    "section": "Solver-Based Methods",
    "text": "Solver-Based Methods\nQuick overview - you won’t implement these in assignments\n\nWeighted Sum: Minimize \\(w_1 \\times \\text{cost} + w_2 \\times \\text{emissions}\\)\n\nSimple, fast for convex problems\n\nε-Constraint: Minimize cost subject to emissions \\(\\leq \\varepsilon\\)\n\nSystematically vary \\(\\varepsilon\\) to find complete frontier\n\nGoal Programming: Minimize deviations from targets\n\nSet target for each objective, minimize weighted deviations\n\n\n\n\n\n\n\n\n\nFor your fleet optimization: You’ll use heuristic approaches instead!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#the-heuristic-strategy",
    "href": "lectures/lec_08_presentation.html#the-heuristic-strategy",
    "title": "Multi-Objective Optimization",
    "section": "The Heuristic Strategy",
    "text": "The Heuristic Strategy\nFor problems without mathematical models\n\n\nConstruction: Build initial solutions with weighted greedy\nImprovement: Multi-objective local search\nSelection: Filter dominated solutions to find Pareto frontier\n\n\n\n\n\n\n\n\n\nKey difference from solvers:\n\nSolvers: Need mathematical model, guarantee optimality\nHeuristics: Work with any evaluation function, find good solutions fast"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#why-heuristics",
    "href": "lectures/lec_08_presentation.html#why-heuristics",
    "title": "Multi-Objective Optimization",
    "section": "Why Heuristics?",
    "text": "Why Heuristics?\nDepending on the problem:\n\nCombinatorial explosion\nHuge solution space even for one problem\nEvaluating one solution might thus take too long\nNeed diverse Pareto frontier, not just one “optimal” solution\nOpen Source Solvers too slow\nCommercial solvers too expensive\n\n\nQuestion: How do we build good solutions without a solver?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#the-three-stage-heuristic-process",
    "href": "lectures/lec_08_presentation.html#the-three-stage-heuristic-process",
    "title": "Multi-Objective Optimization",
    "section": "The Three-Stage Heuristic Process",
    "text": "The Three-Stage Heuristic Process\n\n\n\n\n\n\n\n\n\n\nThis is what you’ll implement in your assignments!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#construction-methods-for-moo",
    "href": "lectures/lec_08_presentation.html#construction-methods-for-moo",
    "title": "Multi-Objective Optimization",
    "section": "Construction Methods for MOO",
    "text": "Construction Methods for MOO\nHow to build initial solutions when you have multiple objectives?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThree choices (for starters). Let’s check them out!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#weighted-greedy-construction",
    "href": "lectures/lec_08_presentation.html#weighted-greedy-construction",
    "title": "Multi-Objective Optimization",
    "section": "Weighted Greedy Construction",
    "text": "Weighted Greedy Construction\nMaking greedy choices on a weighted objective\n\nChoose weight vector w = (w₁, w₂)\nAt each step, pick the choice that minimizes: \\[w_1 \\cdot \\text{cost}(x) + w_2 \\cdot \\text{emissions}(x)\\]\nBuild complete solution greedily\nRepeat with different weights to explore frontier\n\n\n\n\n\n\n\n\nDifferent weights explore different trade-offs! Easy, right?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#sequential-greedy-lexicographic",
    "href": "lectures/lec_08_presentation.html#sequential-greedy-lexicographic",
    "title": "Multi-Objective Optimization",
    "section": "Sequential Greedy (Lexicographic)",
    "text": "Sequential Greedy (Lexicographic)\nOptimize one objective at a time, in priority order\n\nRank objectives by priority\n\nE.g. cost (most important) and then emissions (tie-breaker)\n\nAt each step:\n\nFind choices that minimize primary objective\nIf tie → use secondary objective\n\nBuild one working solution\n\n\n\n\n\n\n\n\nWe could also accept primary values within 10% of best so secondary has more influence!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#diverse-starting-pool",
    "href": "lectures/lec_08_presentation.html#diverse-starting-pool",
    "title": "Multi-Objective Optimization",
    "section": "Diverse Starting Pool",
    "text": "Diverse Starting Pool\nGenerate many random solutions, keep the non-dominated ones\n\nGenerate N random solutions (e.g., N=100)\nEvaluate all solutions on both objectives\nFilter to keep only non-dominated solutions\nResult: A diverse set of Pareto-optimal solutions\n\n\n\n\n\n\n\n\n\nExplores entire solution space\nNo bias toward specific weights\nGreat for warm-starting local search"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#local-search-for-multi-objective",
    "href": "lectures/lec_08_presentation.html#local-search-for-multi-objective",
    "title": "Multi-Objective Optimization",
    "section": "Local Search for Multi-Objective",
    "text": "Local Search for Multi-Objective\nSpecial moves that improve multiple objectives:\n\n\n\n\n\n\n\n\n\n\nQuestion: Which moves are acceptable?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#moo-local-search-rules",
    "href": "lectures/lec_08_presentation.html#moo-local-search-rules",
    "title": "Multi-Objective Optimization",
    "section": "MOO Local Search Rules",
    "text": "MOO Local Search Rules\nAccept a move if:\n\nDominance: New solution dominates current (win-win!)\nTrade-off: Improves primary, acceptable loss in secondary\nDiversity: Fills gap in current Pareto front\nProbabilistic: Use temperature (like simulated annealing)\n\n\n\n\n\n\n\n\nAlways keep all your objectives in mind when making decisions."
  },
  {
    "objectID": "lectures/lec_08_presentation.html#how-to-choose",
    "href": "lectures/lec_08_presentation.html#how-to-choose",
    "title": "Multi-Objective Optimization",
    "section": "How to Choose!",
    "text": "How to Choose!\n\nThe Knee Point: Find the “elbow” where improvement slows\nSatisficing Levels: Set minimum acceptable thresholds\n\nCost must be &lt; €100k (budget constraint)\nEmissions must be &lt; 100 kg (regulatory limit)\nService level must be &gt; 90% (customer requirement)\n\nStakeholder Preferences: Let business priorities guide\n\nSustainability: Minimum emissions that meets constraints\nOperations: Maximum service level within budget"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#weighted-sum-along-the-frontier",
    "href": "lectures/lec_08_presentation.html#weighted-sum-along-the-frontier",
    "title": "Multi-Objective Optimization",
    "section": "Weighted Sum Along the Frontier",
    "text": "Weighted Sum Along the Frontier\nThe weight influences the final choice:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe iso-cost lines show the trade-offs between cost and emissions."
  },
  {
    "objectID": "lectures/lec_08_presentation.html#weighting-has-an-impact",
    "href": "lectures/lec_08_presentation.html#weighting-has-an-impact",
    "title": "Multi-Objective Optimization",
    "section": "Weighting has an Impact",
    "text": "Weighting has an Impact\nThe weights thus reflect your values!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDepending on your weight, the choice will vary."
  },
  {
    "objectID": "lectures/lec_08_presentation.html#speed-vs-sustainability-dilemma",
    "href": "lectures/lec_08_presentation.html#speed-vs-sustainability-dilemma",
    "title": "Multi-Objective Optimization",
    "section": "Speed vs Sustainability Dilemma",
    "text": "Speed vs Sustainability Dilemma\nThe Three-Way Trade-off in E-Commerce\n\nMinimize Delivery Time (1-day/2-hour promise)\nMinimize Cost (fuel, labor, fulfillment)\nMinimize Environmental Impact (carbon footprint)\n\n\nFaster delivery = More vehicles less full = Higher emissions\n\n\nQuestion: What could retailers do?"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#moving-the-frontier",
    "href": "lectures/lec_08_presentation.html#moving-the-frontier",
    "title": "Multi-Objective Optimization",
    "section": "Moving the Frontier",
    "text": "Moving the Frontier\nInstead of point on the frontier, move the entire frontier:\n\nQuestion: Any idea of examples?\n\n\n\n\n\n\n\n\nR&D can fundamentally change what’s possible!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#today",
    "href": "lectures/lec_08_presentation.html#today",
    "title": "Multi-Objective Optimization",
    "section": "Today",
    "text": "Today\n\n\nHour 2: This Lecture\n\nMulti-objective\nPareto optimality\nWeighted greedy\nLocal search MOO\n\n\nHour 3: Notebook\n\nBean Counter CEO\nFind Pareto frontier\nApply weighted greedy\nNormalize objectives\n\n\nHour 4: Competition\n\nTransportation problem\nFleet selection\nCost vs emissions\nJustify choice!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#the-competition-challenge",
    "href": "lectures/lec_08_presentation.html#the-competition-challenge",
    "title": "Multi-Objective Optimization",
    "section": "The Competition Challenge",
    "text": "The Competition Challenge\nEcoExpress Sustainable Fleet Design\n\n\nSolve multi-objective transportation (DCs → Zones)\nSelect optimal fleet mix (5 vehicle types)\nBalance cost, emissions, service quality\nMeet EU emission targets (40% reduction)\n\n\n\n\n\n\n\n\n\nFind the best trade-off for your business priorities!"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#choosing-your-moo-approach",
    "href": "lectures/lec_08_presentation.html#choosing-your-moo-approach",
    "title": "Multi-Objective Optimization",
    "section": "Choosing Your MOO Approach",
    "text": "Choosing Your MOO Approach\nDifferent situations call for different methods:\n\n\n\nSituation\nBest\nWhy\n\n\n\n\nClear priorities\nSequential greedy\nFast, hierarchy\n\n\nExploring\nWeighted greedy\nDifferent solutions\n\n\nMany solutions\nDiverse pool\nBuilds frontier\n\n\nQuick solution\nSingle weighted\nOne good compromise\n\n\nImprove existing\nMulti-objective local\nRefines trade-offs\n\n\n\n\n\n\n\n\n\n\nCompetition? Generate diverse pool or weigted, then improve with local search."
  },
  {
    "objectID": "lectures/lec_08_presentation.html#implementation-pitfalls-to-avoid",
    "href": "lectures/lec_08_presentation.html#implementation-pitfalls-to-avoid",
    "title": "Multi-Objective Optimization",
    "section": "Implementation Pitfalls to Avoid",
    "text": "Implementation Pitfalls to Avoid\nCommon bugs that cost you time:\n\nForgetting to Normalize\n\nAlways normalize to [0,1] first!\n\nOptimizing Too Many Objectives\n\n2-3: Manageable, 4+: Exponentially harder\nCombine related objectives or use constraints\n\nNot Checking Solution Feasibility\n\nAlways verify constraints after optimization"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#summary",
    "href": "lectures/lec_08_presentation.html#summary",
    "title": "Multi-Objective Optimization",
    "section": "Summary",
    "text": "Summary\nKey Takeaways:\n\nReal decisions have multiple conflicting objectives\nPareto frontier shows all rational trade-offs\nNormalization is essential for fair comparison\nWeighted sum works for convex frontiers\nε-constraint handles non-convex cases\nWeights reflect values, make them explicit\nVisualization crucial for decision-making"
  },
  {
    "objectID": "lectures/lec_08_presentation.html#break",
    "href": "lectures/lec_08_presentation.html#break",
    "title": "Multi-Objective Optimization",
    "section": "Break!",
    "text": "Break!\nTake 20 minutes, then we start the practice notebook\nNext up: You’ll become Bean Counter’s expert\nThen: The Sustainability competition"
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html",
    "href": "tutorials/nb_01_02_lists_loops.html",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "",
    "text": "Welcome to your second interactive Python tutorial!\nThe Weekly Sales Analyzer Problem\nYou’ve been promoted at Bean Counter coffee shop! The manager is impressed with your calculator skills and now wants you to analyze the shop’s sales data. Every day, the shop records its total sales, and at the end of the week, management needs to know: What was our best day? What’s our average? Are we improving?\nWith just variables, you’d need hundreds of them to track a month’s worth of data. That’s where lists and loops come in - they’re the perfect tools for handling collections of data!\nIn this tutorial, we’ll learn about lists and loops to build a sales analysis system that can handle any amount of data and give you insights at a glance.\n\n\n\n\n\n\nIf a cell is marked with YOUR CODE BELOW, you are expected to write your code in that cell.",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html#exercise-1.1---create-your-sales-list",
    "href": "tutorials/nb_01_02_lists_loops.html#exercise-1.1---create-your-sales-list",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "Exercise 1.1 - Create Your Sales List",
    "text": "Exercise 1.1 - Create Your Sales List\nCreate a list called weekend_sales with Saturday’s sales of $2340.50 and Sunday’s sales of $1890.25. Then access and store Sunday’s sales in a variable called sunday_total.\n\n\n\n\n\n\nRemember: Lists are indexed starting from 0, so Saturday is index 0 and Sunday is index 1.\n\n\n\n\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nassert weekend_sales == [2340.50, 1890.25], \"weekend_sales should be [2340.50, 1890.25]\"\nassert sunday_total == 1890.25, \"sunday_total should be 1890.25 (the second element)\"\nprint(\"Great! You've created your first list and accessed its elements!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html#exercise-1.2---list-slicing",
    "href": "tutorials/nb_01_02_lists_loops.html#exercise-1.2---list-slicing",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "Exercise 1.2 - List Slicing",
    "text": "Exercise 1.2 - List Slicing\nList slicing lets you grab multiple elements at once. Given the weekly sales:\nweek_sales = [1250.50, 1380.25, 1425.00, 1890.75, 2150.00, 2340.50, 1890.25]\nExtract:\n\nmidweek (Tuesday through Thursday - indices 1, 2, 3)\nlast_three (the last three days)\n\n\n# YOUR CODE BELOW\nweek_sales = [1250.50, 1380.25, 1425.00, 1890.75, 2150.00, 2340.50, 1890.25]\n\n\n\nCode\n# Test your answer\nassert midweek == [1380.25, 1425.00, 1890.75], \"midweek should contain Tuesday through Thursday\"\nassert last_three == [2150.00, 2340.50, 1890.25], \"last_three should contain the last three days\"\nprint(\"Excellent! You've mastered list slicing!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html#exercise-2.1---building-a-customer-count-list",
    "href": "tutorials/nb_01_02_lists_loops.html#exercise-2.1---building-a-customer-count-list",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "Exercise 2.1 - Building a Customer Count List",
    "text": "Exercise 2.1 - Building a Customer Count List\nStart with an empty list and build up hourly customer counts for the morning shift:\n\n8 AM: 15 customers\n9 AM: 32 customers\n10 AM: 28 customers\n11 AM: 41 customers\n\nAlso store the total number of hours tracked as hours_tracked.\n\n\n\n\n\n\nYou can use the len() function to find the length of the list.\n\n\n\n\ncustomer_counts = []\nhours_tracked = 0\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nassert customer_counts == [15, 32, 28, 41], \"customer_counts should be [15, 32, 28, 41]\"\nassert hours_tracked == 4, \"hours_tracked should be 4\"\nprint(\"Perfect! You can build lists dynamically and check their length!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html#exercise-2.2---combining-lists",
    "href": "tutorials/nb_01_02_lists_loops.html#exercise-2.2---combining-lists",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "Exercise 2.2 - Combining Lists",
    "text": "Exercise 2.2 - Combining Lists\nYou have morning and afternoon sales. Combine them into a full day’s record called full_day and compute the total number of transactions as total_transactions.\n\n\n\n\n\n\nTo combine lists, you can simply use the + operator.\n\n\n\n\nmorning_sales = [245.50, 189.25, 156.00]\nafternoon_sales = [312.75, 298.50, 401.25, 389.00]\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nassert full_day == [245.50, 189.25, 156.00, 312.75, 298.50, 401.25, 389.00], \"full_day should combine both lists\"\nassert total_transactions == 7, \"total_transactions should be 7\"\nprint(\"✓ Excellent! You can combine lists and track their size!\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html#the-accumulation-pattern",
    "href": "tutorials/nb_01_02_lists_loops.html#the-accumulation-pattern",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "The Accumulation Pattern",
    "text": "The Accumulation Pattern\nOne of the most important patterns in programming is accumulation - building up a result by repeatedly adding to it. This is essential for calculating totals, averages, and counts.\n\n# Example: Calculate total of all sales\ndaily_sales = [245.50, 189.25, 312.75, 298.50]\n\n# Start with a total of 0\ntotal = 0\n\n# Add each sale to the running total\nfor sale in daily_sales:\n    total = total + sale  # This is the accumulation step!\n    print(f\"  Added ${sale}, running total: ${total}\")\n\nprint(f\"\\nFinal total: ${total}\")\n\n# We can also count items this way\ncount = 0\nfor sale in daily_sales:\n    count = count + 1\n\nprint(f\"Number of sales: {count}\")\n\n  Added $245.5, running total: $245.5\n  Added $189.25, running total: $434.75\n  Added $312.75, running total: $747.5\n  Added $298.5, running total: $1046.0\n\nFinal total: $1046.0\nNumber of sales: 4\n\n\n\n\n\n\n\n\nImportantAccumulation Pattern Steps:\n\n\n\n\nInitialize a variable to 0 (or empty list) before the loop\nUpdate the variable inside the loop (add, append, etc.)\nUse the final result after the loop completes\n\nThis pattern is fundamental to data analysis!",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html#exercise-3.1---calculate-total-sales",
    "href": "tutorials/nb_01_02_lists_loops.html#exercise-3.1---calculate-total-sales",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "Exercise 3.1 - Calculate Total Sales",
    "text": "Exercise 3.1 - Calculate Total Sales\nCalculate the total of all prices in a list and also count how many items there are.\n\nprices = [15.99, 24.50, 8.75, 32.00, 19.99, 45.25]\ntotal_cost = 0\nitem_count = 0\n\n# Use a for loop to:\n#   - Add each price to total_cost\n#   - Increment item_count by 1 each time\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nassert abs(total_cost - 146.48) &lt; 0.01, \"total_cost should be 146.48\"\nassert item_count == 6, \"item_count should be 6\"\nprint(f\"Perfect! Total cost: ${total_cost:.2f} for {item_count} items\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html#exercise-4.1---day-by-day-changes",
    "href": "tutorials/nb_01_02_lists_loops.html#exercise-4.1---day-by-day-changes",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "Exercise 4.1 - Day-by-Day Changes",
    "text": "Exercise 4.1 - Day-by-Day Changes\nCalculate the change in sales from each day to the next and store them in a list.\n\nsales = [1250, 1380, 1125, 1890, 1650]\ndaily_changes = []\n\nprint(\"Day-to-day changes:\")\n# Use range(1, len(sales)) to start from index 1\n# For each day, calculate: sales[i] - sales[i-1]\n# Append each change to daily_changes\n# Print the change for each day\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your answer\nexpected_changes = [130, -255, 765, -240]\nassert daily_changes == expected_changes, f\"daily_changes should be {expected_changes}\"\nassert len(daily_changes) == 4, \"Should have 4 changes (for days 2-5)\"\nprint(\"Excellent! You calculated the daily changes correctly!\")\nprint(f\"Daily changes: {daily_changes}\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_01_02_lists_loops.html#exercise-5.1---customer-satisfaction-analysis",
    "href": "tutorials/nb_01_02_lists_loops.html#exercise-5.1---customer-satisfaction-analysis",
    "title": "Notebook 1.2 - Lists & Basic Loops",
    "section": "Exercise 5.1 - Customer Satisfaction Analysis",
    "text": "Exercise 5.1 - Customer Satisfaction Analysis\nCalculate the total of all ratings and the average rating. Also count how many total ratings there are.\n\n# YOUR CODE BELOW\nratings = [5, 4, 3, 5, 5, 2, 4, 5, 3, 4, 5, 5, 4, 3, 5]\n\n# Steps:\n# 1. Initialize total_rating to 0\n# 2. Initialize rating_count to 0\n# 3. Loop through ratings and:\n#    - Add each rating to total_rating\n#    - Increment rating_count\n# 4. Calculate average_rating = total_rating / rating_count\n\ntotal_rating = 0\nrating_count = 0\n\n# YOUR LOOP HERE\n\n\n\nCode\n# Test your answer\nassert total_rating == 62, \"total_rating should be 62\"\nassert rating_count == 15, \"rating_count should be 15\"\nassert abs(average_rating - 4.13) &lt; 0.01, \"average_rating should be approximately 4.13\"\nprint(\"✓ Perfect! You've mastered aggregation calculations!\")\nprint(f\"Total: {total_rating}, Count: {rating_count}, Average: {average_rating:.2f} stars\")",
    "crumbs": [
      "01 Let's Start",
      "NB-01-02 Lists"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html",
    "href": "tutorials/nb_02_01_functions.html",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "",
    "text": "Welcome to your new role at Bean Counter!\nCongratulations on your promotion to Assistant Manager!\nAfter your excellent work with inventory tracking and customer queue management, the CEO of Bean Counter has noticed your talent. She’s planning to expand from our flagship store to 10 locations across the city, and she needs your help!\nThe Challenge: Each of our baristas currently calculates prices, applies discounts, and prepares drinks their own way. This leads to:\n\nInconsistent pricing between stores\nErrors in discount calculations\nDifferent drink quality at each location\nFrustrated customers who get charged differently at each store\n\nYour Task: Create standardized functions that every Bean Counter location will use. These functions will ensure consistency, reduce errors, and make training new baristas much easier.\nIn this tutorial, we’ll learn how to use functions - reusable blocks of code that standardize operations across all Bean Counter locations.\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nCells marked with “YOUR CODE BELOW” expect you to write your own code. Test blocks will verify your solutions.",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html#exercise-1.1---standardize-drink-pricing",
    "href": "tutorials/nb_02_01_functions.html#exercise-1.1---standardize-drink-pricing",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "Exercise 1.1 - Standardize Drink Pricing",
    "text": "Exercise 1.1 - Standardize Drink Pricing\nCreate a function called calculate_drink_price that takes the drink size and type, then returns the price.\nBean Counter’s pricing:\n\nEspresso: Medium $3.00, Large $3.50\nLatte: Medium $4.75, Large $5.50\nCappuccino: Medium $4.25, Large $5.00\n\n\n\n\n\n\n\nNoteBefore You Start\n\n\n\n\nUse if/elif statements to handle different drink types\nMake sure to return (not print) the price\nConsider what to return if an invalid drink type is given\n\n\n\n\n# YOUR CODE BELOW\ndef calculate_drink_price(size, drink_type):\n    # Your pricing logic here\n\n\n\nCode\n# Test your drink pricing function\nassert calculate_drink_price(\"large\", \"espresso\") == 3.50, \"Large espresso should be 3.50\"\nassert calculate_drink_price(\"medium\", \"latte\") == 4.75, \"Medium latte should be 4.75\"\nassert calculate_drink_price(\"large\", \"cappuccino\") == 5.00, \"Large cappuccino should be 5.00\"\nprint(\"Excellent! Your pricing function works perfectly. No more pricing chaos at Bean Counter!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html#exercise-1.2---loyalty-points-calculator",
    "href": "tutorials/nb_02_01_functions.html#exercise-1.2---loyalty-points-calculator",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "Exercise 1.2 - Loyalty Points Calculator",
    "text": "Exercise 1.2 - Loyalty Points Calculator\nBean Counter rewards customer loyalty! Create a function calculate_loyalty_points that takes the purchase amount and returns points earned.\nRules:\n\nCustomers earn 1 point per dollar spent (rounded down)\nPurchases over $10 earn 1.5x points\nPurchases over $20 earn 2x points\n\n\n\n\n\n\n\nIf you convert the purchase amount to an integer with int() before calculating points, you’ll get an integer (round number) that is rounded down.\n\n\n\n\n# YOUR CODE BELOW\ndef calculate_loyalty_points(purchase_amount):\n    # Calculate points based on purchase amount\n\n\n\nCode\n# Test your loyalty points calculator\nassert calculate_loyalty_points(5.50) == 5, \"Should earn 5 points for $5.50\"\nassert calculate_loyalty_points(12.00) == 18, \"Should earn 18 points for $12 (1.5x bonus)\"\nassert calculate_loyalty_points(25.00) == 50, \"Should earn 50 points for $25 (2x bonus)\"\nprint(\"Perfect! The loyalty program is now standardized across all locations!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html#exercise-2.1---bean-freshness-checker",
    "href": "tutorials/nb_02_01_functions.html#exercise-2.1---bean-freshness-checker",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "Exercise 2.1 - Bean Freshness Checker",
    "text": "Exercise 2.1 - Bean Freshness Checker\nCreate a function check_bean_freshness that determines if coffee beans are fresh enough to use.\nBean Counter’s freshness standards:\n\nBeans are fresh for 14 days after roasting\nBeans are acceptable for 21 days (but need manager approval)\nAfter 21 days, beans must be discarded\nReturn: “fresh”, “manager_approval”, or “discard”\n\n\n# YOUR CODE BELOW\ndef check_bean_freshness(days_since_roasting):\n    # Check freshness and return status as string\n\n\n\nCode\n# Test your freshness checker\nassert check_bean_freshness(10) == \"fresh\", \"10-day old beans should be fresh\"\nassert check_bean_freshness(18) == \"manager_approval\", \"18-day old beans need approval\"\nassert check_bean_freshness(25) == \"discard\", \"25-day old beans must be discarded\"\nprint(\"Excellent! Quality control is now standardized!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html#exercise-2.2---smart-discount-function",
    "href": "tutorials/nb_02_01_functions.html#exercise-2.2---smart-discount-function",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "Exercise 2.2 - Smart Discount Function",
    "text": "Exercise 2.2 - Smart Discount Function\nCreate a function apply_discount that applies Bean Counter’s discount policies:\n\nHappy hour (use 24-hour format): 15% off\nSenior discount (age 65+): 10% off\nStudent discount (with valid ID): 10% off\nDiscounts don’t stack - apply the best one!\n\nReturn the discounted price rounded to two decimals.\n\n\n\n\n\n\nTo round a number to two decimals, use the round() function. For example, to round the result of a division or multiplacation that results in 2.14159 to two decimals, use round(2.14159, 2).\n\n\n\n\n# YOUR CODE BELOW\ndef apply_discount(original_price, hour, senior_age, is_student):\n    # Apply the best available discount\n    # Tip: Use a variable to keep track of the best discount and start with the lowest\n\n\n\nCode\n# Test your discount function\nassert apply_discount(10.00, 16, 18, False) == 8.50, \"Happy hour should give 15% off\"\nassert apply_discount(10.00, 12, 80, False) == 9.00, \"Senior discount should give 10% off\"\nassert apply_discount(10.00, 16, 23, False) == 8.50, \"Should apply best discount (happy hour 15%)\"\nassert apply_discount(10.00, 12, 42, False) == 10.00, \"No discount applies\"\nprint(\"Great work! Your discount system is working perfectly!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html#exercise-3.1---order-validation-system",
    "href": "tutorials/nb_02_01_functions.html#exercise-3.1---order-validation-system",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "Exercise 3.1 - Order Validation System",
    "text": "Exercise 3.1 - Order Validation System\nCreate a function validate_order that checks if an order can be fulfilled:\n\nCheck bean freshness (use your check_bean_freshness function)\nVerify the drink type is valid (espresso, latte, or cappuccino)\nReturn a boolean (True or False) stating if we can_fulfill the order\n\n\n\n\n\n\n\nTipUsing Previous Functions\n\n\n\nYou can use the check_bean_freshness() function you created in Exercise 2.1. Just call it inside your new function! Note, that you will have to check what it returns to determine if the order can be fulfilled.\n\n\n\n# YOUR CODE BELOW\ndef validate_order(drink_type, days_since_roasting):\n    # Validate the order and return can_fulfill\n\n\n\nCode\n# Test your validation system\nresult = validate_order(\"latte\", 10)\nassert result == True, \"Fresh beans should approve order\"\nresult = validate_order(\"espresso\", 19)\nassert result == True, \"Should need manager approval\"\nresult = validate_order(\"mocha\", 5)\nassert result == False, \"Should reject invalid drinks\"\nprint(\"Perfect! Your validation system ensures quality at every Bean Counter location!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html#exercise-4.1---order-queue-manager",
    "href": "tutorials/nb_02_01_functions.html#exercise-4.1---order-queue-manager",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "Exercise 4.1 - Order Queue Manager",
    "text": "Exercise 4.1 - Order Queue Manager\nCreate a function that manages Bean Counter’s morning rush order queue using list methods.\n\n# YOUR CODE BELOW\ndef manage_order_queue(current_queue, new_order, completed_order):\n    \"\"\"\n    Manage the order queue during morning rush\n    - Add new order to the end of queue\n    - Remove completed order from queue\n    - Return the updated queue length\n    \"\"\"\n    # Step 1: Add new_order to the queue using .append()\n\n    # Step 2: Remove completed_order from queue using .remove()\n\n    # Step 3: Return the queue length (use len() function)\n\n    return queue_length\n\n\n\nCode\n# Test queue manager\nqueue = [\"latte\", \"espresso\", \"cappuccino\"]\ninitial_length = len(queue)\n\n# First test\nlength1 = manage_order_queue(queue, \"americano\", \"latte\")\nassert \"americano\" in queue, \"Should add americano to queue\"\nassert \"latte\" not in queue, \"Should remove latte from queue\"\nassert length1 == 3, \"Queue should still have 3 items\"\n\n# Second test\nlength2 = manage_order_queue(queue, \"mocha\", \"espresso\")\nassert \"mocha\" in queue, \"Should add mocha to queue\"\nassert \"espresso\" not in queue, \"Should remove espresso from queue\"\nassert length2 == 3, \"Queue should still have 3 items\"\n\nprint(\"Excellent! Your order queue system keeps the morning rush flowing smoothly!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html#exercise-5.1---daily-sales-analytics",
    "href": "tutorials/nb_02_01_functions.html#exercise-5.1---daily-sales-analytics",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "Exercise 5.1 - Daily Sales Analytics",
    "text": "Exercise 5.1 - Daily Sales Analytics\nCreate a function analyze_daily_sales that takes a list of sale amounts and returns three values as a tuple:\n\nTotal sales for the day\nAverage sale amount\nNumber of transactions\n\n\n# YOUR CODE BELOW\ndef analyze_daily_sales(sales_list):\n    # Calculate and return (total, average, count) as tuple\n\n\n\nCode\n# Test your sales analytics function\nsales = [12.50, 8.75, 15.00, 6.25, 22.00]\ntotal, avg, count = analyze_daily_sales(sales)\nassert total == 64.50, \"Total should be $64.50\"\nassert avg == 12.90, \"Average should be $12.90\"\nassert count == 5, \"Should have 5 transactions\"\nprint(\"Excellent analytics! You can now track Bean Counter's performance across all locations!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_01_functions.html#exercise-5.2---barista-performance-evaluation",
    "href": "tutorials/nb_02_01_functions.html#exercise-5.2---barista-performance-evaluation",
    "title": "Notebook 2.1 - Functions at Bean Counter",
    "section": "Exercise 5.2 - Barista Performance Evaluation",
    "text": "Exercise 5.2 - Barista Performance Evaluation\nCreate a function evaluate_barista_performance that takes:\n\nList of drink preparation times (in seconds)\nList of customer ratings (1-5 as integter (customer stars))\n\nReturns a tuple with:\n\nAverage preparation time\nAverage customer rating\nPerformance level (“excellent”, “good”, “needs_improvement”)\n\nPerformance levels:\n\n“excellent”: avg time &lt; 90 seconds AND rating &gt;= 4.5\n“good”: avg time &lt; 120 seconds AND rating &gt;= 4.0\n“needs_improvement”: otherwise\n\n\n\n\n\n\n\nFor robustness, it is nice to handle the case where the input lists might be empty. For example, if empty, return (0, 0, “needs_improvement”).\n\n\n\n\n# YOUR CODE BELOW\ndef evaluate_barista_performance(prep_times, ratings):\n    # Calculate metrics and determine performance level\n\n\n\nCode\n# Test your barista evaluation function\ntimes = [85, 92, 78, 88, 95]\nratings = [4.5, 5, 4.5, 5, 4.5]\navg_time, avg_rating, level = evaluate_barista_performance(times, ratings)\nassert avg_time == 87.6, \"Average time should be 87.6 seconds\"\nassert avg_rating == 4.7, \"Average rating should be 4.7\"\nassert level == \"excellent\", \"Should be excellent performance\"\n\n# Test a barista who needs improvement\nslow_times = [150, 140, 160, 145]\nlow_ratings = [3, 3.5, 3, 4]\ntime2, rating2, level2 = evaluate_barista_performance(slow_times, low_ratings)\nassert level2 == \"needs_improvement\", \"Slow service should need improvement\"\n\nprint(\"Great job! You can now evaluate and coach baristas across all Bean Counter locations!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-01 Functions"
    ]
  },
  {
    "objectID": "tutorials/nb_02_03_sorting.html",
    "href": "tutorials/nb_02_03_sorting.html",
    "title": "Notebook 2.3 - Sorting & Finding Best Options",
    "section": "",
    "text": "Welcome to your role as Operations Director at Bean Counter!\nCongratulations on becoming Operations Director!\nYour regional management skills were so impressive that the CEO has promoted you to Operations Director! You now oversee operations for the entire Bean Counter empire - 10 locations, 150+ employees, and thousands of daily decisions.\nThe Challenge: Every day brings countless decisions:\n\nWhich stores should receive limited supplies first?\nWhich tasks should baristas prioritize during rush hour?\nWhich locations need emergency support?\nHow do we schedule deliveries efficiently?\n\nMaking the wrong choice costs time, money, and customer satisfaction. You need systematic ways to find the best options!\nYour Mission: Understand sorting and optimization - Python’s tools for finding the best (or worst) options among many choices. You’ll learn to rank, prioritize, and optimize.\nIn this tutorial, we’ll explore how to make data-driven decisions that optimize Bean Counter’s entire operation.\n\n\n\n\n\n\nNoteHow to Use This Tutorial\n\n\n\nCells marked with “YOUR CODE BELOW” expect you to write your own code. Test blocks will verify your solutions.",
    "crumbs": [
      "02 Advances",
      "NB-02-03 Sorting"
    ]
  },
  {
    "objectID": "tutorials/nb_02_03_sorting.html#exercise-1.1---rank-store-wait-times",
    "href": "tutorials/nb_02_03_sorting.html#exercise-1.1---rank-store-wait-times",
    "title": "Notebook 2.3 - Sorting & Finding Best Options",
    "section": "Exercise 1.1 - Rank Store Wait Times",
    "text": "Exercise 1.1 - Rank Store Wait Times\nBean Counter tracks average wait times (in seconds) for each location. Sort them to identify which stores need improvement.\nCreate two lists:\n\nfastest_first - sorted from fastest to slowest\nslowest_first - sorted from slowest to fastest\n\n\nwait_times = [95, 120, 85, 150, 110, 90, 135, 88, 125, 105]\n\n# YOUR CODE BELOW\n\n\n\nCode\n# Test your sorting\nassert fastest_first[0] == 85, \"Fastest time should be 85 seconds\"\nassert fastest_first[-1] == 150, \"Last in fastest_first should be 150\"\nassert slowest_first[0] == 150, \"First in slowest_first should be 150\"\nassert slowest_first[-1] == 85, \"Last in slowest_first should be 85\"\nprint(f\"Fastest to slowest: {fastest_first}\")\nprint(f\"Slowest to fastest: {slowest_first}\")\nprint(\"Perfect! You can now identify which stores need operational improvements!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-03 Sorting"
    ]
  },
  {
    "objectID": "tutorials/nb_02_03_sorting.html#exercise-1.2---alphabetical-store-directory",
    "href": "tutorials/nb_02_03_sorting.html#exercise-1.2---alphabetical-store-directory",
    "title": "Notebook 2.3 - Sorting & Finding Best Options",
    "section": "Exercise 1.2 - Alphabetical Store Directory",
    "text": "Exercise 1.2 - Alphabetical Store Directory\nCreate an alphabetically sorted list of store names for the company directory. It should be called alphabetical.\n\nstore_names = [\"Plaza\", \"Downtown\", \"Airport\", \"University\", \"Beach\", \"Station\", \"Mall\", \"Park\"]\n\n# YOUR CODE BELOW\n# Sort alphabetically (A to Z)\n\n\n\nCode\n# Test your alphabetical sorting\nassert alphabetical[0] == \"Airport\", \"First store should be Airport\"\nassert alphabetical[-1] == \"University\", \"Last store should be University\"\nassert len(alphabetical) == 8, \"Should still have 8 stores\"\nprint(f\"Store directory: {alphabetical}\")\nprint(\"Great! Your store directory is professionally organized!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-03 Sorting"
    ]
  },
  {
    "objectID": "tutorials/nb_02_03_sorting.html#exercise-2.1---daily-operations-extremes",
    "href": "tutorials/nb_02_03_sorting.html#exercise-2.1---daily-operations-extremes",
    "title": "Notebook 2.3 - Sorting & Finding Best Options",
    "section": "Exercise 2.1 - Daily Operations Extremes",
    "text": "Exercise 2.1 - Daily Operations Extremes\nFind the operational extremes for Bean Counter’s daily metrics:\n\nHighest and lowest sales figures\nFastest and slowest delivery times\nThe difference between best and worst sales (the range)\n\n\ndaily_sales = [4250, 6100, 3900, 5200, 4800, 5500, 4100]\ndelivery_times = [25, 35, 18, 42, 30, 28, 38]  # in minutes\n\n# YOUR CODE BELOW\n\n# Find sales extremes\nhighest_sales =\nlowest_sales =\nsales_range =\n\n# Find delivery extremes\nfastest_delivery =\nslowest_delivery =\n\n\n\nCode\n# Test your extremes\nassert highest_sales == 6100, \"Highest sales should be 6100\"\nassert lowest_sales == 3900, \"Lowest sales should be 3900\"\nassert sales_range == 2200, \"Sales range should be 2200\"\nassert fastest_delivery == 18, \"Fastest delivery should be 18 minutes\"\nassert slowest_delivery == 42, \"Slowest delivery should be 42 minutes\"\nprint(f\"Sales: ${lowest_sales} to ${highest_sales} (range: ${sales_range})\")\nprint(f\"Delivery: {fastest_delivery} to {slowest_delivery} minutes\")\nprint(\"Excellent! You can quickly identify operational extremes for decision-making!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-03 Sorting"
    ]
  },
  {
    "objectID": "tutorials/nb_02_03_sorting.html#exercise-3.1---rank-stores-by-efficiency",
    "href": "tutorials/nb_02_03_sorting.html#exercise-3.1---rank-stores-by-efficiency",
    "title": "Notebook 2.3 - Sorting & Finding Best Options",
    "section": "Exercise 3.1 - Rank Stores by Efficiency",
    "text": "Exercise 3.1 - Rank Stores by Efficiency\nSort Bean Counter stores by efficiency (customers served per staff member). Create two rankings:\n\nMost efficient to least efficient\nLeast efficient to most efficient\n\n\nstore_efficiency = [\n    {\"location\": \"Plaza\", \"customers\": 450, \"staff\": 6},      # 75 per staff\n    {\"location\": \"Airport\", \"customers\": 680, \"staff\": 12},   # 56.7 per staff\n    {\"location\": \"Downtown\", \"customers\": 520, \"staff\": 8},   # 65 per staff\n    {\"location\": \"Beach\", \"customers\": 280, \"staff\": 4},      # 70 per staff\n    {\"location\": \"Station\", \"customers\": 410, \"staff\": 7}     # 58.6 per staff\n]\n\n# First, we calculate efficiency for each store\nfor store in store_efficiency:\n    store[\"efficiency\"] = store[\"customers\"] / store[\"staff\"]\n\n# YOUR CODE BELOW\n\n# Sort by efficiency (most efficient first)\nmost_efficient =\n\n# Sort by efficiency (least efficient first)\nleast_efficient =\n\n\n\nCode\n# Test your efficiency ranking\nassert most_efficient[0][\"location\"] == \"Plaza\", \"Plaza should be most efficient\"\nassert most_efficient[-1][\"location\"] == \"Airport\", \"Airport should be least efficient\"\nassert least_efficient[0][\"location\"] == \"Airport\", \"Airport should be first in least efficient\"\nprint(\"Most to least efficient:\")\nfor store in most_efficient:\n    print(f\"  {store['location']}: {store['efficiency']:.1f} customers/staff\")\nprint(\"Perfect! You can now identify which stores operate most efficiently!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-03 Sorting"
    ]
  },
  {
    "objectID": "tutorials/nb_02_03_sorting.html#exercise-4.1---critical-supply-allocation",
    "href": "tutorials/nb_02_03_sorting.html#exercise-4.1---critical-supply-allocation",
    "title": "Notebook 2.3 - Sorting & Finding Best Options",
    "section": "Exercise 4.1 - Critical Supply Allocation",
    "text": "Exercise 4.1 - Critical Supply Allocation\nBean Counter has limited specialty coffee beans. Find which store should receive them based on different criteria:\n\nThe store with the lowest current inventory (most urgent need)\nThe store with the highest daily bean usage (highest demand)\n\n\nsupply_data = [\n    {\"store\": \"Plaza\", \"inventory_kg\": 15, \"daily_usage\": 8},\n    {\"store\": \"Downtown\", \"inventory_kg\": 8, \"daily_usage\": 12},\n    {\"store\": \"Airport\", \"inventory_kg\": 25, \"daily_usage\": 15},\n    {\"store\": \"Beach\", \"inventory_kg\": 5, \"daily_usage\": 6},\n    {\"store\": \"University\", \"inventory_kg\": 18, \"daily_usage\": 10}\n]\n\n# YOUR CODE BELOW\n# Find store with lowest inventory\nmost_urgent =\n\n# Find store with highest daily usage\nhighest_demand =\n\n\n\nCode\n# Test your supply allocation\nassert most_urgent[\"store\"] == \"Beach\", \"Beach has lowest inventory\"\nassert highest_demand[\"store\"] == \"Airport\", \"Airport has highest daily usage\"\nprint(f\"Most urgent (lowest inventory): {most_urgent['store']}\")\nprint(f\"Highest demand: {highest_demand['store']}\")\nprint(\"Excellent decision-making! You've allocated supplies optimally!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-03 Sorting"
    ]
  },
  {
    "objectID": "tutorials/nb_02_03_sorting.html#exercise-5.1---morning-rush-scheduling",
    "href": "tutorials/nb_02_03_sorting.html#exercise-5.1---morning-rush-scheduling",
    "title": "Notebook 2.3 - Sorting & Finding Best Options",
    "section": "Exercise 5.1 - Morning Rush Scheduling",
    "text": "Exercise 5.1 - Morning Rush Scheduling\nIt’s 7 AM at Bean Counter Plaza, and you have multiple drink orders to schedule. Apply both SPT and EDD rules to determine the order sequence.\nCreate:\n\nspt_sequence - List of order IDs in SPT order\nedd_sequence - List of order IDs in EDD order\n\n\nrush_orders = [\n    {\"id\": \"Latte1\", \"prep_time\": 4, \"promised_time\": 7.15},\n    {\"id\": \"Espresso1\", \"prep_time\": 2, \"promised_time\": 7.10},\n    {\"id\": \"Cappuccino1\", \"prep_time\": 5, \"promised_time\": 7.20},\n    {\"id\": \"Americano1\", \"prep_time\": 3, \"promised_time\": 7.12},\n    {\"id\": \"Latte2\", \"prep_time\": 4, \"promised_time\": 7.18}\n]\n\n# YOUR CODE BELOW\n# Apply SPT rule (sort by prep_time)\n\n# Extract just the IDs using list comprehension\n\n# Apply EDD rule (sort by promised_time)\n\n# Extract just the IDs using list comprehension\n\n\n\nCode\n# Test your scheduling\nassert spt_sequence[0] == \"Espresso1\", \"Espresso1 should be first in SPT\"\nassert spt_sequence[-1] == \"Cappuccino1\", \"Cappuccino1 should be last in SPT\"\nassert edd_sequence[0] == \"Espresso1\", \"Espresso1 should be first in EDD\"\nassert edd_sequence[1] == \"Americano1\", \"Americano1 should be second in EDD\"\nprint(f\"SPT sequence: {spt_sequence}\")\nprint(f\"EDD sequence: {edd_sequence}\")\nprint(\"Outstanding! You've mastered basic scheduling optimization!\")",
    "crumbs": [
      "02 Advances",
      "NB-02-03 Sorting"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html",
    "href": "tutorials/nb_03_01_numpy.html",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "",
    "text": "Welcome to your role as CEO of Bean Counter!\nCongratulations, Chief Executive Officer!\nAfter your outstanding performance as Operations Director, the board has unanimously appointed you as CEO of Bean Counter! You now lead a coffee empire with:\n\n50+ locations across the country\n1,000+ employees\nMillions of transactions per month\nThousands of products and suppliers\n\nThe Challenge: As CEO, you’re drowning in data. Your Python lists take minutes to process sales reports. Board meetings are tomorrow, and you need answers NOW!\nYour new Tool: NumPy - a Python library that processes numerical data fast. What takes minutes with regular Python takes seconds with NumPy.",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#what-are-packages",
    "href": "tutorials/nb_03_01_numpy.html#what-are-packages",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "What are Packages?",
    "text": "What are Packages?\nAs CEO, you wouldn’t build every tool from scratch - you’d use the best tools available. The same applies to Python!\n\nPackages are collections of pre-written code that solve common problems\nThey’re created by experts and shared with the community\nThink of them as apps you can add to Python to extend its capabilities\n\n\n\n\n\n\n\nTipWhy Use Packages?\n\n\n\nInstead of writing thousands of lines of code yourself, you can install a package in seconds and get professional-grade functionality. It’s like the difference between building your own espresso machine vs. buying a professional one!",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#installing-numpy-with-uv",
    "href": "tutorials/nb_03_01_numpy.html#installing-numpy-with-uv",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "Installing NumPy with uv",
    "text": "Installing NumPy with uv\nTo use NumPy (or any package), we first need to install it. We’ll use uv, which we already used to install Python at the start. Do the following in the terminal where you have all your notebooks as well as the files that uv added during its initialization. Not in the notebook!\n# Install NumPy for numerical computing\nuv add numpy\n# While we're at it, let's also install pandas for next session\nuv add pandas\n\n\n\n\n\n\nNoteHow to Install\n\n\n\n\nOpen your terminal (or use the terminal in your IDE)\nType uv add numpy pandas and press Enter\nWait a few seconds for installation to complete\nThat’s it! You can now use NumPy in your code",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#using-installed-packages",
    "href": "tutorials/nb_03_01_numpy.html#using-installed-packages",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "Using Installed Packages",
    "text": "Using Installed Packages\nOnce installed, you can import and use packages in your Python code:\nimport numpy as np  # Import NumPy with alias 'np' (standard convention)\nThe as np part creates a shorthand. Instead of typing numpy.array() later, you can type np.array() and access numpy functions.\nNow let’s see why NumPy is essential!\n\n\n\n\n\n\nWarningPrerequisites\n\n\n\nMake sure you’ve installed NumPy using uv add numpy in your terminal before starting the next section!",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#creating-and-using-numpy-arrays",
    "href": "tutorials/nb_03_01_numpy.html#creating-and-using-numpy-arrays",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "Creating and Using NumPy Arrays",
    "text": "Creating and Using NumPy Arrays\nA NumPy array is like a Python list, but optimized for numerical operations. Here’s how to work with them:\n\nimport numpy as np\n\n# Creating arrays from Python lists\nprices = [4.50, 3.25, 5.00, 2.75, 4.00]\nprices_array = np.array(prices)  # Convert list to NumPy array\nprint(f\"Original list: {prices}\")\nprint(f\"NumPy array: {prices_array}\")\nprint(f\"Array type: {type(prices_array)}\")\n\n# Accessing elements (just like lists!)\nprint(f\"\\nFirst price: ${prices_array[0]}\")\nprint(f\"Last price: ${prices_array[-1]}\")\nprint(f\"Prices 2-4: {prices_array[1:4]}\")\n\n# The magic: operations on entire arrays at once!\n# Increase all prices by 10%\nincreased_prices = prices_array * 1.10\nprint(f\"\\nAfter 10% increase: {increased_prices}\")\n\n# Add $0.50 service charge to all\nwith_service = prices_array + 0.50\nprint(f\"With service charge: {with_service}\")\n\n# Calculate total revenue if we sell 100 of each\nquantities = np.array([100, 150, 80, 200, 120])\nrevenues = prices_array * quantities  # Element-wise multiplication!\nprint(f\"\\nRevenues: {revenues}\")\nprint(f\"Total revenue: ${np.sum(revenues)}\")\n\nOriginal list: [4.5, 3.25, 5.0, 2.75, 4.0]\nNumPy array: [4.5  3.25 5.   2.75 4.  ]\nArray type: &lt;class 'numpy.ndarray'&gt;\n\nFirst price: $4.5\nLast price: $4.0\nPrices 2-4: [3.25 5.   2.75]\n\nAfter 10% increase: [4.95  3.575 5.5   3.025 4.4  ]\nWith service charge: [5.   3.75 5.5  3.25 4.5 ]\n\nRevenues: [450.  487.5 400.  550.  480. ]\nTotal revenue: $2367.5\n\n\n\n\n\n\n\n\nTipKey NumPy Array Operations\n\n\n\n\nCreate: np.array([1, 2, 3]) - Convert list to array\nMath: array * 2, array + 5 - Operations apply to ALL elements\nAccess: array[0], array[1:3] - Works like lists\nAggregate: np.sum(array), np.mean(array) - Quick statistics",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#exercise-3.1---your-first-analysis",
    "href": "tutorials/nb_03_01_numpy.html#exercise-3.1---your-first-analysis",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "Exercise 3.1 - Your First Analysis",
    "text": "Exercise 3.1 - Your First Analysis\nCreate a NumPy array of this week’s daily revenues and calculate the total.\n\nimport numpy as np\n\n# Daily revenues for the week (in thousands)\ndaily_revenues = [125.5, 132.8, 118.9, 145.2, 155.7, 189.3, 176.4]\n\n# YOUR CODE BELOW\n# Convert to NumPy array\nrevenues_array =\n\n# Calculate total weekly revenue\ntotal_revenue =\n\n\n\nCode\n# Test your revenue calculation\nassert isinstance(revenues_array, np.ndarray), \"Should be a NumPy array\"\nassert int(total_revenue) == int(1043.8), f\"Total should be 1043.8, got {total_revenue}\"\nprint(f\"Weekly revenue: ${total_revenue:.1f}k\")\nprint(\"Excellent! You've made your first CEO-level analysis with NumPy!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#exercise-4.1---initialize-company-metrics",
    "href": "tutorials/nb_03_01_numpy.html#exercise-4.1---initialize-company-metrics",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "Exercise 4.1 - Initialize Company Metrics",
    "text": "Exercise 4.1 - Initialize Company Metrics\nAs CEO, set up arrays for tracking various company metrics.\n\nimport numpy as np\n\n# YOUR CODE BELOW\n# 1. Create an array of 50 zeros for tracking store profits\nstore_profits =\n\n# 2. Create an array with store IDs from 101 to 150 (50 stores)\nstore_codes =\n\n# 3. Create an array of 12 months, each starting with budget of 100000\nmonthly_budgets =\n\n\n\nCode\n# Test your arrays\nassert store_profits.shape == (50,), \"Should have 50 stores\"\nassert store_codes[0] == 101 and store_codes[-1] == 150, \"Store codes should be 101-150\"\nassert np.sum(monthly_budgets[:3]) == 300000, \"Q1 budget should be 300000\"\nprint(f\"Profit tracking shape: {store_profits.shape}\")\nprint(f\"First 5 store codes: {store_codes[:5]}\")\nprint(f\"Q1 budget total: ${np.sum(monthly_budgets[:3]):,}\")\nprint(\"Perfect! Your metric tracking system is initialized!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#exercise-5.1---company-wide-financial-calculations",
    "href": "tutorials/nb_03_01_numpy.html#exercise-5.1---company-wide-financial-calculations",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "Exercise 5.1 - Company-Wide Financial Calculations",
    "text": "Exercise 5.1 - Company-Wide Financial Calculations\nPerform mass calculations across all Bean Counter stores.\n\nimport numpy as np\n\n# Monthly data for 50 stores\nrevenues = np.array([125000, 98000, 145000, 87000, 156000, 134000, 92000, 167000,\n                    118000, 143000, 99000, 175000, 132000, 89000, 154000, 121000,\n                    138000, 95000, 162000, 108000, 147000, 131000, 88000, 159000,\n                    126000, 141000, 93000, 168000, 115000, 152000, 128000, 86000,\n                    144000, 119000, 137000, 96000, 171000, 113000, 149000, 124000,\n                    135000, 91000, 164000, 107000, 146000, 129000, 85000, 158000,\n                    122000, 140000])\n\n# Cost is 65% of revenue for each store\ncosts = revenues * 0.65\n\n# YOUR CODE BELOW\n# 1. Calculate profit for each store (revenue - costs)\nprofits =\n\n# 2. Calculate profit margin for each store (profit / revenue * 100)\nprofit_margins =\n\n# 3. Apply 25% corporate tax to get after-tax profit\nprofits_after_tax =\n\nprint(f\"Total monthly profit (before tax): ${profits.sum():,.2f}\")\nprint(f\"Total monthly profit (after tax): ${profits_after_tax.sum():,.2f}\")\n\n\n\nCode\n# Test your calculations\nassert np.isclose(profits.sum(), 2240700), \"Total profit before tax should be 2,240,700\"\nassert np.isclose(profit_margins.mean(), 35.0), \"Average margin should be 35%\"\nassert np.isclose(profits_after_tax.sum(), 1680525), \"After-tax profit should be 1,680,525\"\nprint(f\"Total monthly profit (before tax): ${profits.sum():,.2f}\")\nprint(f\"Total monthly profit (after tax): ${profits_after_tax.sum():,.2f}\")\nprint(\"Fantastic! You've learned company-wide financial calculations!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#d-arrays",
    "href": "tutorials/nb_03_01_numpy.html#d-arrays",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "2D Arrays",
    "text": "2D Arrays\nSo far, we’ve worked with 1D arrays (like a single row or column). As CEO, you often need 2D arrays. Think of them as tables with rows and columns!\n\nimport numpy as np\n\n# Example: Sales data for 5 stores over 7 days\n# Rows = stores, Columns = days\nsales_table = np.array([\n    [125, 132, 128, 145, 155, 189, 176],  # Store 1\n    [98, 102, 95, 108, 115, 142, 138],    # Store 2\n    [156, 162, 159, 171, 178, 198, 192],  # Store 3\n    [87, 91, 88, 95, 102, 125, 118],      # Store 4\n    [134, 139, 136, 148, 153, 178, 165]   # Store 5\n])\n\nprint(\"Sales Table (5 stores × 7 days):\")\nprint(sales_table)\nprint(f\"\\nShape: {sales_table.shape} (rows, columns)\")\n\n# Calculate statistics along different axes\ntotal_per_store = np.sum(sales_table, axis=1)  # Sum across columns (days) for each store\ntotal_per_day = np.sum(sales_table, axis=0)    # Sum across rows (stores) for each day\n\nprint(f\"\\nTotal sales per store: {total_per_store}\")\nprint(f\"Total sales per day: {total_per_day}\")\n\nSales Table (5 stores × 7 days):\n[[125 132 128 145 155 189 176]\n [ 98 102  95 108 115 142 138]\n [156 162 159 171 178 198 192]\n [ 87  91  88  95 102 125 118]\n [134 139 136 148 153 178 165]]\n\nShape: (5, 7) (rows, columns)\n\nTotal sales per store: [1050  798 1216  706 1053]\nTotal sales per day: [600 626 606 667 703 832 789]\n\n\n\n\n\n\n\n\nTipUnderstanding axis Parameter\n\n\n\nIn 2D arrays:\n\naxis=0 operates DOWN the rows (along columns)\naxis=1 operates ACROSS the columns (along rows)\n\nThink of it this way:\n\naxis=1 gives you one value per row (e.g., average per store)\naxis=0 gives you one value per column (e.g., average per day)",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#boolean-filtering-and-binary-vectors",
    "href": "tutorials/nb_03_01_numpy.html#boolean-filtering-and-binary-vectors",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "Boolean Filtering and Binary Vectors",
    "text": "Boolean Filtering and Binary Vectors\nAn important concept: when you filter with a condition, NumPy creates a boolean (True/False) array, also called a binary vector!\n\nimport numpy as np\n\n# Sample satisfaction scores\nscores = np.array([4.8, 3.2, 4.5, 2.8, 4.9, 3.7, 4.2, 5.0])\n\n# When we apply a condition, we get a boolean array (binary vector)\nhigh_scores_mask = scores &gt;= 4.0\nprint(f\"Original scores: {scores}\")\nprint(f\"Boolean mask (&gt;= 4.0): {high_scores_mask}\")\nprint(f\"Type: {type(high_scores_mask)}\")\n\n# We can use this binary vector in several ways:\n\n# 1. Count True values (treating True=1, False=0)\ncount_high = np.sum(high_scores_mask)\nprint(f\"\\nNumber of high scores: {count_high}\")\n\n# 2. Filter to get only values that are True\nfiltered_scores = scores[high_scores_mask]\nprint(f\"High scores only: {filtered_scores}\")\n\n# 3. Do it all in one line (common pattern)\ncount_directly = np.sum(scores &gt;= 4.0)\nprint(f\"Count directly: {count_directly}\")\n\nOriginal scores: [4.8 3.2 4.5 2.8 4.9 3.7 4.2 5. ]\nBoolean mask (&gt;= 4.0): [ True False  True False  True False  True  True]\nType: &lt;class 'numpy.ndarray'&gt;\n\nNumber of high scores: 5\nHigh scores only: [4.8 4.5 4.9 4.2 5. ]\nCount directly: 5\n\n\n\n\n\n\n\n\nImportantBoolean Arrays (Binary Vectors)\n\n\n\nWhen you write array &gt;= value, NumPy creates a boolean array: - True (=1) where condition is met - False (=0) where condition is not met\nThis binary vector can be used to: - Count: np.sum(condition) - sums up the 1s and 0s - Filter: array[condition] - returns only True values - Analyze: Check what percentage meets criteria\n\n\nLet’s see another practical example:\n\nimport numpy as np\n\n# Daily sales for 10 stores\ndaily_sales = np.array([125, 98, 156, 87, 134, 145, 92, 167, 118, 143])\n\n# Find stores exceeding target of 120\ntarget = 120\nexceeds_target = daily_sales &gt; target\n\nprint(f\"Sales: {daily_sales}\")\nprint(f\"Exceeds {target}: {exceeds_target}\")\nprint(f\"\\nStores meeting target: {np.sum(exceeds_target)}\")\nprint(f\"Percentage meeting target: {np.sum(exceeds_target) / len(daily_sales) * 100:.1f}%\")\nprint(f\"Actual sales above target: {daily_sales[exceeds_target]}\")\n\nSales: [125  98 156  87 134 145  92 167 118 143]\nExceeds 120: [ True False  True False  True  True False  True False  True]\n\nStores meeting target: 6\nPercentage meeting target: 60.0%\nActual sales above target: [125 156 134 145 167 143]",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_01_numpy.html#exercise-6.1---analyze-company-performance",
    "href": "tutorials/nb_03_01_numpy.html#exercise-6.1---analyze-company-performance",
    "title": "Notebook 3.1 - NumPy for CEO Analytics",
    "section": "Exercise 6.1 - Analyze Company Performance",
    "text": "Exercise 6.1 - Analyze Company Performance\nAnalyze performance metrics across all Bean Counter locations using 2D arrays.\n\nimport numpy as np\n\n# Daily customer counts for 50 stores over 30 days\n# This creates a 2D array: rows = stores, columns = days\nnp.random.seed(100)\ndaily_customers = np.random.randint(150, 500, size=(50, 30))  # 50 stores, 30 days\n\nprint(f\"Data shape: {daily_customers.shape}\")\nprint(f\"First store's first 5 days: {daily_customers[0, :5]}\")\n\n# YOUR CODE BELOW\n# 1. Calculate total customers served across all stores in the month\ntotal_customers =\n\n# 2. Calculate average daily customers per store (across all stores and days)\navg_daily_per_store =\n\n# 3. Find the busiest single day (max customers in one store on one day)\nbusiest_day =\n\n# 4. Find stores that averaged over 350 customers per day\n# Hint: Use np.mean(daily_customers, axis=1) to get average per store\n# Then count how many stores have average &gt; 350\nstore_averages =\nhigh_traffic_stores =\n\n\n\nCode\n# Test your analysis\nassert total_customers == 492171, f\"Total should be 492,171 , got {total_customers}\"\nassert np.isclose(avg_daily_per_store, 328.1, atol=0.1), f\"Average should be ~328.1\"\nassert busiest_day == 499, f\"Busiest day should be 499, got {busiest_day}\"\nprint(f\"Total customers served: {total_customers:,}\")\nprint(f\"Average daily customers per store: {avg_daily_per_store:.1f}\")\nprint(f\"Busiest single day: {busiest_day} customers\")\nprint(f\"High-traffic stores (&gt;350/day): {high_traffic_stores}\")\nprint(\"Excellent CEO-level analysis! You understand your company's traffic patterns!\")",
    "crumbs": [
      "03 Foundation",
      "NB-03-01 Numpy"
    ]
  },
  {
    "objectID": "tutorials/nb_03_03_visualization.html",
    "href": "tutorials/nb_03_03_visualization.html",
    "title": "Notebook 3.3 - Visualization & Integration",
    "section": "",
    "text": "Welcome to your final CEO challenge at Bean Counter!\nThe Board Meeting Challenge\nTomorrow morning, you’re presenting Bean Counter’s annual performance to the board of directors and potential investors. You have:\n\nMassive datasets analyzed with NumPy\nComplex reports created with Pandas\nIncredible insights about the business\n\nThe Problem: Numbers alone don’t convince boards. They need to SEE the story! A table with 1000 rows won’t inspire investment, but a compelling chart will.\nYour Solution: Data Visualization - turning your analyses into powerful visual stories that drive decisions and secure funding.\nIn this tutorial, you’ll create the visualizations that will secure Bean Counter’s future and cement your legacy as CEO.\n\n\n\n\n\n\nWarningHow to Use This Tutorial\n\n\n\nImport matplotlib along with pandas and numpy. Remember, we work with uv, so just use uv add matplotlib in the terminal. Now you can create compelling charts for your board presentation!\n\n\n\n\n\n\n\n\nTipStart practicing generate AI\n\n\n\nThe creation of plots is a perfect opportunity to start practicing generate AI. Usually you need a lot of code for nice visualizations and most of it is repetitive.",
    "crumbs": [
      "03 Foundation",
      "NB-03-03 Plotting"
    ]
  },
  {
    "objectID": "tutorials/nb_03_03_visualization.html#exercise-1.1---product-performance-bar-chart",
    "href": "tutorials/nb_03_03_visualization.html#exercise-1.1---product-performance-bar-chart",
    "title": "Notebook 3.3 - Visualization & Integration",
    "section": "Exercise 1.1 - Product Performance Bar Chart",
    "text": "Exercise 1.1 - Product Performance Bar Chart\nCreate a bar chart showing Bean Counter’s product sales for the board meeting.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Product sales data\nproducts_df = pd.DataFrame({\n    'product': ['Latte', 'Espresso', 'Cappuccino', 'Americano', 'Mocha', 'Macchiato'],\n    'units_sold': [3200, 4500, 2800, 2100, 1900, 1500]\n})\n\n# YOUR CODE BELOW\n# 1. Sort products by units_sold (highest first)\nproducts_sorted =\n\n# 2. Create a bar chart",
    "crumbs": [
      "03 Foundation",
      "NB-03-03 Plotting"
    ]
  },
  {
    "objectID": "tutorials/nb_03_03_visualization.html#exercise-2.1---customer-growth-trend",
    "href": "tutorials/nb_03_03_visualization.html#exercise-2.1---customer-growth-trend",
    "title": "Notebook 3.3 - Visualization & Integration",
    "section": "Exercise 2.1 - Customer Growth Trend",
    "text": "Exercise 2.1 - Customer Growth Trend\nShow the board Bean Counter’s customer growth over the past 8 months.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Customer data (in thousands)\nmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug']\ncustomers = [145, 152, 158, 165, 174, 182, 195, 208]\n\n# YOUR CODE BELOW\n# Create a line plot showing customer growth",
    "crumbs": [
      "03 Foundation",
      "NB-03-03 Plotting"
    ]
  },
  {
    "objectID": "tutorials/nb_03_03_visualization.html#exercise-3.1---store-efficiency-distribution",
    "href": "tutorials/nb_03_03_visualization.html#exercise-3.1---store-efficiency-distribution",
    "title": "Notebook 3.3 - Visualization & Integration",
    "section": "Exercise 3.1 - Store Efficiency Distribution",
    "text": "Exercise 3.1 - Store Efficiency Distribution\nShow the board how store efficiency is distributed across all locations.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Simulate efficiency scores for 50 stores\nnp.random.seed(100)\nefficiency_scores = np.random.normal(75, 12, 50)  # Mean 75, std 12\n\n# YOUR CODE BELOW\n# Create histogram of efficiency distribution",
    "crumbs": [
      "03 Foundation",
      "NB-03-03 Plotting"
    ]
  },
  {
    "objectID": "tutorials/nb_03_03_visualization.html#exercise-4.1---complete-ceo-dashboard",
    "href": "tutorials/nb_03_03_visualization.html#exercise-4.1---complete-ceo-dashboard",
    "title": "Notebook 3.3 - Visualization & Integration",
    "section": "Exercise 4.1 - Complete CEO Dashboard",
    "text": "Exercise 4.1 - Complete CEO Dashboard\nCreate an integrated dashboard combining NumPy simulation with Pandas analysis and visualization. Create revenue projections for the company:\n\nStart at $6M in January\nGrow approximately 2% each month\nAdd random variation (±25%) to simulate market fluctuations\n\n\n\n\n\n\n\nTo create realistic monthly growth:\n\nStart with base revenue of 6.0M\nEach month, apply 2% growth: revenue = previous_revenue * 1.02\nAdd random variation: multiply by np.random.uniform(0.75, 1.25)\n\n\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Simulate next year's projections\nnp.random.seed(42)\nmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\n# YOUR CODE BELOW\n# 1. Create revenue projections for the company\n# Start with 6.0M, grow each month by 2% with random variation\nrevenue_projection = []\ncurrent_revenue = 6.0  # Starting revenue in millions\n\n# Loop through 12 months\n\n\n# 2. Create DataFrame with months and revenue\n\n\n# 3. Calculate cumulative revenue\n\n\n# 4. Create visualization with two subplots",
    "crumbs": [
      "03 Foundation",
      "NB-03-03 Plotting"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html",
    "href": "tutorials/nb_04_02_techventure.html",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "",
    "text": "TechVenture Innovation Fund is a venture capital firm specializing in early-stage technology investments. Founded in 2018, the fund has successfully backed 23 startups with an average return of 32% per year. The partners pride themselves on data-driven decision making and sophisticated risk analysis.\nYour Role: You’ve been hired as consultants to analyze their latest investment opportunity.\n\n\n\nTechVenture has €2 million available for immediate deployment. After extensive due diligence, they’ve narrowed their options to four promising startups. Due to diversification requirements and partnership agreements, they must invest in exactly two startups, allocating €1 million to each.\n\n\n\n\n\nIndustry: Enterprise AI/SaaS\nProduct: AI-powered business intelligence platform\nMarket Size: €45B growing at 25% annually\nCompetition: Moderate (established players but room for innovation)\nReturn Distribution: Normal distribution\n\nMean return: 25% per year\nStandard deviation: 15%\n\nKey Risk: Technology adoption speed, enterprise sales cycles\n\n\n\n\n\nIndustry: Renewable Energy Technology\nProduct: Next-generation solar panel storage systems\nMarket Size: €30B growing at 18% annually\nCompetition: High (many players, commoditization risk)\nReturn Distribution: Normal distribution\n\nMean return: 18% per year\nStandard deviation: 8%\n\nKey Risk: Regulatory changes, commodity price fluctuations\n\n\n\n\n\nIndustry: Medical Devices / Wearables\nProduct: FDA-approved continuous health monitoring wearable\nMarket Size: €20B growing at 35% annually\nCompetition: Low (first-mover in specific medical conditions)\nReturn Distribution: Normal distribution\n\nMean return: 30% per year\nStandard deviation: 25%\n\nKey Risk: Regulatory approval delays, clinical trial outcomes\n\n\n\n\n\nIndustry: B2B Fintech\nProduct: Automated payment reconciliation for enterprises\nMarket Size: €15B growing at 20% annually\nCompetition: Moderate (fragmented market)\nReturn Distribution: Uniform distribution\n\nMinimum return: 10% per year\nMaximum return: 35% per year\n\nKey Risk: Customer acquisition cost, banking partnerships\n\n\n\n\n\n\nThe fund evaluates investments based on multiple criteria:\n\nExpected Total Return: The mean return across all scenarios\nRisk-Adjusted Return: Return relative to volatility\nDownside Protection: Probability of loss (return &lt; 0%)\nUpside Potential: Probability of exceptional returns (&gt;50% total)\nWorst-Case Scenario: Expected shortfall in bottom 10% of outcomes\n\n\n\n\n\nMust select exactly 2 startups\nMust invest €1 million in each selected startup\nCannot invest in more or fewer than 2 startups\nInvestment horizon is 1 year for this analysis\nAssume startups’ returns are independent (no correlation)",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#company-background",
    "href": "tutorials/nb_04_02_techventure.html#company-background",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "",
    "text": "TechVenture Innovation Fund is a venture capital firm specializing in early-stage technology investments. Founded in 2018, the fund has successfully backed 23 startups with an average return of 32% per year. The partners pride themselves on data-driven decision making and sophisticated risk analysis.\nYour Role: You’ve been hired as consultants to analyze their latest investment opportunity.",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#the-investment-opportunity",
    "href": "tutorials/nb_04_02_techventure.html#the-investment-opportunity",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "",
    "text": "TechVenture has €2 million available for immediate deployment. After extensive due diligence, they’ve narrowed their options to four promising startups. Due to diversification requirements and partnership agreements, they must invest in exactly two startups, allocating €1 million to each.\n\n\n\n\n\nIndustry: Enterprise AI/SaaS\nProduct: AI-powered business intelligence platform\nMarket Size: €45B growing at 25% annually\nCompetition: Moderate (established players but room for innovation)\nReturn Distribution: Normal distribution\n\nMean return: 25% per year\nStandard deviation: 15%\n\nKey Risk: Technology adoption speed, enterprise sales cycles\n\n\n\n\n\nIndustry: Renewable Energy Technology\nProduct: Next-generation solar panel storage systems\nMarket Size: €30B growing at 18% annually\nCompetition: High (many players, commoditization risk)\nReturn Distribution: Normal distribution\n\nMean return: 18% per year\nStandard deviation: 8%\n\nKey Risk: Regulatory changes, commodity price fluctuations\n\n\n\n\n\nIndustry: Medical Devices / Wearables\nProduct: FDA-approved continuous health monitoring wearable\nMarket Size: €20B growing at 35% annually\nCompetition: Low (first-mover in specific medical conditions)\nReturn Distribution: Normal distribution\n\nMean return: 30% per year\nStandard deviation: 25%\n\nKey Risk: Regulatory approval delays, clinical trial outcomes\n\n\n\n\n\nIndustry: B2B Fintech\nProduct: Automated payment reconciliation for enterprises\nMarket Size: €15B growing at 20% annually\nCompetition: Moderate (fragmented market)\nReturn Distribution: Uniform distribution\n\nMinimum return: 10% per year\nMaximum return: 35% per year\n\nKey Risk: Customer acquisition cost, banking partnerships",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#success-metrics",
    "href": "tutorials/nb_04_02_techventure.html#success-metrics",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "",
    "text": "The fund evaluates investments based on multiple criteria:\n\nExpected Total Return: The mean return across all scenarios\nRisk-Adjusted Return: Return relative to volatility\nDownside Protection: Probability of loss (return &lt; 0%)\nUpside Potential: Probability of exceptional returns (&gt;50% total)\nWorst-Case Scenario: Expected shortfall in bottom 10% of outcomes",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#constraints-and-requirements",
    "href": "tutorials/nb_04_02_techventure.html#constraints-and-requirements",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "",
    "text": "Must select exactly 2 startups\nMust invest €1 million in each selected startup\nCannot invest in more or fewer than 2 startups\nInvestment horizon is 1 year for this analysis\nAssume startups’ returns are independent (no correlation)",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#your-mission",
    "href": "tutorials/nb_04_02_techventure.html#your-mission",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "Your Mission",
    "text": "Your Mission\nUse Monte Carlo simulation to determine which pair of startups TechVenture should invest in. Your analysis should:\n\nSimulate at least 10,000 scenarios for each startup\nEvaluate all possible pairs (there are 6 combinations)\nCompare portfolios using multiple risk metrics\nRecommend the optimal investment pair\nJustify your recommendation with data",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#evaluation-criteria",
    "href": "tutorials/nb_04_02_techventure.html#evaluation-criteria",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "Evaluation Criteria",
    "text": "Evaluation Criteria\nYour presentation will be evaluated on:\n\nCorrectness (50%): Accurate simulation and calculations\nBusiness Reasoning (25%): Clear justification aligned with fund goals\nPresentation (25%): Clear, professional one-slide summary",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#time-limit",
    "href": "tutorials/nb_04_02_techventure.html#time-limit",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "Time Limit",
    "text": "Time Limit\nYou have until next session to complete your analysis and prepare your presentation.",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#helpful-functions-optional-use",
    "href": "tutorials/nb_04_02_techventure.html#helpful-functions-optional-use",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "Helpful Functions (Optional Use)",
    "text": "Helpful Functions (Optional Use)\n\ndef calculate_portfolio_metrics(returns_1, returns_2, investment=1_000_000):\n    \"\"\"\n    Calculate metrics for a portfolio of two startups\n\n    Parameters:\n    - returns_1: array of returns for startup 1 (as decimals, e.g., 0.25 for 25%)\n    - returns_2: array of returns for startup 2\n    - investment: amount invested in each startup\n\n    Returns:\n    - Dictionary with portfolio metrics\n    \"\"\"\n    # Portfolio returns (equal weight)\n    portfolio_returns = 0.5 * returns_1 + 0.5 * returns_2\n\n    # Calculate absolute returns in euros\n    absolute_returns = portfolio_returns * 2 * investment\n\n    metrics = {\n        'mean_return': portfolio_returns.mean(),\n        'std_dev': portfolio_returns.std(),\n        'prob_loss': (portfolio_returns &lt; 0).mean(),\n        'prob_high_return': (portfolio_returns &gt; 0.5).mean(),\n        'var_5': np.percentile(portfolio_returns, 5),\n        'expected_profit': absolute_returns.mean()\n    }\n\n    return metrics\n\ndef expected_shortfall(returns, percentile=10):\n    \"\"\"\n    Calculate the expected shortfall (conditional VaR)\n\n    Parameters:\n    - returns: array of returns\n    - percentile: percentile for worst-case scenarios\n\n    Returns:\n    - Average return in the worst X% of scenarios\n    \"\"\"\n    threshold = np.percentile(returns, percentile)\n    worst_returns = returns[returns &lt;= threshold]\n    return worst_returns.mean() if len(worst_returns) &gt; 0 else 0\n\n# Example usage (delete or modify as needed):\nprint(\"Helper functions loaded and ready to use!\")\n\nHelper functions loaded and ready to use!",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#required-deliverables",
    "href": "tutorials/nb_04_02_techventure.html#required-deliverables",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "Required Deliverables",
    "text": "Required Deliverables\n\n1. One-Slide Recommendation\nCreate one-slide (PDF) containing:\n\nRecommendation: Which 2 startups to invest in (clearly stated)\nExpected Return: Total expected return in € and %\nRisk Assessment: Your personal risk assessment\nJustification: 2-3 bullet points explaining why this pair\nVisual: One chart comparing the 6 portfolio options (optional but recommended)\n\n\n\n2. Presentation Preparation\nBe ready to present your recommendation in 3 minutes:\n\n1 minute: State recommendation and key metrics\n1 minute: Explain your analysis approach\n1 minute: Justify why this is the best choice for TechVenture",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#strategy-suggestions",
    "href": "tutorials/nb_04_02_techventure.html#strategy-suggestions",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "Strategy Suggestions",
    "text": "Strategy Suggestions\n\nStart Simple: Get one startup simulation working before scaling\nVerify Distributions: Plot histograms to check your simulations look correct\nThink Like an Investor: Consider both return AND risk\nUse Vectorization: NumPy operations are faster than loops\nDocument Assumptions: Be clear about any choices you make",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_04_02_techventure.html#common-pitfalls-to-avoid",
    "href": "tutorials/nb_04_02_techventure.html#common-pitfalls-to-avoid",
    "title": "Competition 01 - TechVenture Investment Challenge",
    "section": "Common Pitfalls to Avoid",
    "text": "Common Pitfalls to Avoid\n\nDon’t forget to convert percentages to decimals (25% = 0.25)\nRemember you’re investing €2M total (€1M each in 2 startups)\nCheck that your uniform distribution is implemented correctly\nConsider that high return often comes with high risk",
    "crumbs": [
      "04 Monte Carlo",
      "NB-04-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html",
    "href": "tutorials/nb_05_02_predictor.html",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "",
    "text": "MegaMart is a major European retail chain with 250 stores across 8 countries. Founded in 1985, they’ve grown to €4.2B in annual revenue. Their motto: “Everything you need, when you need it.”\nYour Role: You’ve been hired as forecasting consultants for their critical Christmas season planning.\n\n\n\nLast Year’s Disaster:\n\nGaming Console X: Sold out December 10th, missed €1.2M in sales\nFitness Tracker Pro: 500 units unsold, €150K clearance loss\nSmart Speaker Mini: Perfect stock, but pure luck\n\nOperations Director: “We can’t afford another Christmas like last year. Every stockout means disappointed customers and lost revenue. Every overstock means clearance losses and tied-up capital. We need accurate forecasts!”\n\n\n\n\n\nForecast December 2025 sales (weeks 1-4) for three key products using 3 years of historical weekly data.\n\n\n\n\n\n\nCategory: Consumer Electronics\nPrice: €199\nMargin: €80 per unit\nStorage cost: €2 per unit per week\nLead time: 3 weeks from supplier\nLast year: Strong growth, some seasonality\n\n\n\n\n\nCategory: Health & Wellness\nPrice: €149\nMargin: €55 per unit\nStorage cost: €1.50 per unit per week\nLead time: 4 weeks from supplier\nLast year: Volatile, New Year resolution spike\n\n\n\n\n\nCategory: Home & Living\nPrice: €79\nMargin: €30 per unit\nStorage cost: €3 per unit per week (bulky)\nLead time: 6 weeks from supplier\nLast year: Highly seasonal, winter peak\n\n\n\n\n\nYour forecasts will be evaluated on:\n\nAccuracy (60%): Mean Absolute Error (MAE) across all 12 forecasts\nBusiness Logic (20%): Reasonable patterns, seasonality considered\nMethod Clarity (20%): Clear explanation of approach\n\n\n\n\nCost of Errors:\n\nUnderforecast: Lost profit margin + customer disappointment\nOverforecast: Storage costs + clearance losses (assume 30% markdown)\n\nExample: If you forecast 1000 units but actual is 1200: - Lost profit: 200 × €80 = €16,000 (for TechPod Pro)",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#company-background",
    "href": "tutorials/nb_05_02_predictor.html#company-background",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "",
    "text": "MegaMart is a major European retail chain with 250 stores across 8 countries. Founded in 1985, they’ve grown to €4.2B in annual revenue. Their motto: “Everything you need, when you need it.”\nYour Role: You’ve been hired as forecasting consultants for their critical Christmas season planning.",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#the-christmas-crisis",
    "href": "tutorials/nb_05_02_predictor.html#the-christmas-crisis",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "",
    "text": "Last Year’s Disaster:\n\nGaming Console X: Sold out December 10th, missed €1.2M in sales\nFitness Tracker Pro: 500 units unsold, €150K clearance loss\nSmart Speaker Mini: Perfect stock, but pure luck\n\nOperations Director: “We can’t afford another Christmas like last year. Every stockout means disappointed customers and lost revenue. Every overstock means clearance losses and tied-up capital. We need accurate forecasts!”",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#the-challenge",
    "href": "tutorials/nb_05_02_predictor.html#the-challenge",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "",
    "text": "Forecast December 2025 sales (weeks 1-4) for three key products using 3 years of historical weekly data.\n\n\n\n\n\n\nCategory: Consumer Electronics\nPrice: €199\nMargin: €80 per unit\nStorage cost: €2 per unit per week\nLead time: 3 weeks from supplier\nLast year: Strong growth, some seasonality\n\n\n\n\n\nCategory: Health & Wellness\nPrice: €149\nMargin: €55 per unit\nStorage cost: €1.50 per unit per week\nLead time: 4 weeks from supplier\nLast year: Volatile, New Year resolution spike\n\n\n\n\n\nCategory: Home & Living\nPrice: €79\nMargin: €30 per unit\nStorage cost: €3 per unit per week (bulky)\nLead time: 6 weeks from supplier\nLast year: Highly seasonal, winter peak\n\n\n\n\n\nYour forecasts will be evaluated on:\n\nAccuracy (60%): Mean Absolute Error (MAE) across all 12 forecasts\nBusiness Logic (20%): Reasonable patterns, seasonality considered\nMethod Clarity (20%): Clear explanation of approach\n\n\n\n\nCost of Errors:\n\nUnderforecast: Lost profit margin + customer disappointment\nOverforecast: Storage costs + clearance losses (assume 30% markdown)\n\nExample: If you forecast 1000 units but actual is 1200: - Lost profit: 200 × €80 = €16,000 (for TechPod Pro)",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#data-exploration-tools",
    "href": "tutorials/nb_05_02_predictor.html#data-exploration-tools",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Data Exploration Tools",
    "text": "Data Exploration Tools\n\n# Quick statistics\nprint(\"Product Statistics (weekly sales):\")\nprint(\"-\" * 40)\nfor product in ['techpod_pro', 'fitband_ultra', 'cozythrow_deluxe']:\n    mean_sales = historical_data[product].mean()\n    std_sales = historical_data[product].std()\n    max_sales = historical_data[product].max()\n    min_sales = historical_data[product].min()\n    print(f\"\\n{product.upper()}:\")\n    print(f\"  Average: {mean_sales:.0f} units/week\")\n    print(f\"  Std Dev: {std_sales:.0f} units\")\n    print(f\"  Range: {min_sales} - {max_sales} units\")\n\n# Visualize the full history\nfig, axes = plt.subplots(3, 1, figsize=(14, 10))\n\nproducts = ['techpod_pro', 'fitband_ultra', 'cozythrow_deluxe']\ncolors = ['#537E8F', '#F6B265', '#DB6B6B']\n\nfor idx, (product, color) in enumerate(zip(products, colors)):\n    axes[idx].plot(historical_data['week'], historical_data[product],\n                   color=color, linewidth=1.5, alpha=0.8)\n    axes[idx].set_ylabel('Weekly Sales')\n    axes[idx].set_title(f'{product.replace(\"_\", \" \").title()} - 3 Year History')\n    axes[idx].grid(True, alpha=0.2)\n    axes[idx].axvline(x=pd.Timestamp('2023-12-01'), color='red',\n                      linestyle='--', alpha=0.5, label='December Start')\n    if idx == 0:\n        axes[idx].legend()\n\naxes[-1].set_xlabel('Week')\nplt.tight_layout()\nplt.show()\n\nProduct Statistics (weekly sales):\n----------------------------------------\n\nTECHPOD_PRO:\n  Average: 333 units/week\n  Std Dev: 58 units\n  Range: 218 - 489 units\n\nFITBAND_ULTRA:\n  Average: 179 units/week\n  Std Dev: 54 units\n  Range: 75 - 345 units\n\nCOZYTHROW_DELUXE:\n  Average: 118 units/week\n  Std Dev: 48 units\n  Range: 50 - 244 units",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#december-weeks-to-forecast",
    "href": "tutorials/nb_05_02_predictor.html#december-weeks-to-forecast",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "December Weeks to Forecast",
    "text": "December Weeks to Forecast\n\n# Define the December 2025 weeks we need to forecast (exactly 4 weeks)\ndecember_weeks = pd.date_range(start='2025-12-01', periods=4, freq='W-MON')\nprint(\"December 2025 weeks to forecast:\")\nfor i, week in enumerate(december_weeks, 1):\n    print(f\"  Week {i}: {week.date()} (Monday start)\")\n\n# Create a template for your submission\nforecast_template = pd.DataFrame({\n    'week': december_weeks,\n    'week_num': [1, 2, 3, 4],\n    'techpod_pro': [0, 0, 0, 0],        # Your forecasts here\n    'fitband_ultra': [0, 0, 0, 0],      # Your forecasts here\n    'cozythrow_deluxe': [0, 0, 0, 0]    # Your forecasts here\n})\n\nprint(\"\\nForecast template (you'll fill this):\")\nprint(forecast_template)\n\nprint(\"\\nExample: How to fill your forecasts:\")\nprint(\"  forecast_template.loc[0, 'techpod_pro'] = your_week1_forecast\")\nprint(\"  forecast_template.loc[1, 'techpod_pro'] = your_week2_forecast\")\nprint(\"  ... and so on for all products and weeks\")\n\nDecember 2025 weeks to forecast:\n  Week 1: 2025-12-01 (Monday start)\n  Week 2: 2025-12-08 (Monday start)\n  Week 3: 2025-12-15 (Monday start)\n  Week 4: 2025-12-22 (Monday start)\n\nForecast template (you'll fill this):\n        week  week_num  techpod_pro  fitband_ultra  cozythrow_deluxe\n0 2025-12-01         1            0              0                 0\n1 2025-12-08         2            0              0                 0\n2 2025-12-15         3            0              0                 0\n3 2025-12-22         4            0              0                 0\n\nExample: How to fill your forecasts:\n  forecast_template.loc[0, 'techpod_pro'] = your_week1_forecast\n  forecast_template.loc[1, 'techpod_pro'] = your_week2_forecast\n  ... and so on for all products and weeks",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#example-basic-forecast-implementation",
    "href": "tutorials/nb_05_02_predictor.html#example-basic-forecast-implementation",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Example: Basic Forecast Implementation",
    "text": "Example: Basic Forecast Implementation\n\n# Example forecast for TechPod Pro using simple moving average\nprint(\"Example Forecast: TechPod Pro\")\nprint(\"-\" * 40)\n\n# Method 1: Simple 4-week moving average\ntechpod_ma4 = simple_moving_average(historical_data['techpod_pro'], window=4)\nprint(f\"4-week MA forecast: {techpod_ma4:.0f} units/week\")\n\n# Method 2: Same week last year\ntechpod_seasonal = seasonal_naive(historical_data['techpod_pro'], season_length=52)\nprint(f\"Last year same week: {techpod_seasonal:.0f} units/week\")\n\nprint(\"\\nYou can use any of these methods or create your own!\")\n\nExample Forecast: TechPod Pro\n----------------------------------------\n4-week MA forecast: 402 units/week\nLast year same week: 408 units/week\n\nYou can use any of these methods or create your own!",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#step-1-analyze-each-product",
    "href": "tutorials/nb_05_02_predictor.html#step-1-analyze-each-product",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Step 1: Analyze Each Product",
    "text": "Step 1: Analyze Each Product\nStudy the patterns, trends, and seasonality for each product. Consider:\n\nIs there a clear trend (growing/declining)?\nIs there seasonality? When are the peaks?\nHow volatile is the demand?\nWhat happened last December?",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#step-2-choose-your-methods",
    "href": "tutorials/nb_05_02_predictor.html#step-2-choose-your-methods",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Step 2: Choose Your Methods",
    "text": "Step 2: Choose Your Methods\nSelect appropriate forecasting methods for each product. You might use:\n\nDifferent methods for different products\nCombination of methods\nAdjusted forecasts based on December patterns\nYour own creative approach",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#step-3-generate-forecasts",
    "href": "tutorials/nb_05_02_predictor.html#step-3-generate-forecasts",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Step 3: Generate Forecasts",
    "text": "Step 3: Generate Forecasts\nCreate your forecasts for the 4 December weeks for each product.\n\n# YOUR SOLUTION HERE\n# This is where you'll implement your forecasting approach\n\n# Step 1: Analyze patterns (add your analysis code)\n\n# Step 2: Choose and implement methods\n\n# Step 3: Generate December forecasts\n\n# Step 4: Validate your forecasts are reasonable",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#step-4-create-your-submission",
    "href": "tutorials/nb_05_02_predictor.html#step-4-create-your-submission",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Step 4: Create Your Submission",
    "text": "Step 4: Create Your Submission\nPrepare a one-slide presentation (PDF) containing:\n\nYour Forecasts: Clear visualization of all 12 predictions\nMethod Summary: 2-3 sentences explaining your approach\nKey Insights: What patterns did you find?\nConfidence Level: How confident are you in these forecasts?",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#strategy-suggestions",
    "href": "tutorials/nb_05_02_predictor.html#strategy-suggestions",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Strategy Suggestions",
    "text": "Strategy Suggestions\n\nStart Simple: Get a baseline forecast working first\nLook for Patterns: December might be special for some products\nConsider Product Types: Electronics vs. seasonal items behave differently\nValidate Reasonableness: Do your forecasts make business sense?",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#common-pitfalls",
    "href": "tutorials/nb_05_02_predictor.html#common-pitfalls",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\n\nUsing the same method for all products without considering their differences\nIgnoring obvious seasonality\nForecasts way outside historical ranges without justification\nOverly complex methods when simple ones work better",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_05_02_predictor.html#final-checklist",
    "href": "tutorials/nb_05_02_predictor.html#final-checklist",
    "title": "Competition 02 - The Christmas Predictor Challenge",
    "section": "Final Checklist",
    "text": "Final Checklist\n\nAll 12 forecasts completed (3 products × 4 weeks)\nForecasts seem reasonable given history\nOne-slide PDF ready for presentation",
    "crumbs": [
      "05 Forecasting",
      "NB-05-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html",
    "href": "tutorials/nb_06_02_scheduler.html",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "",
    "text": "Custom Cycles Manufacturing is a premium bicycle manufacturer based in Hamburg, Germany. Founded in 1998, they’ve built a reputation for high-quality custom builds with a loyal customer base of cycling enthusiasts and professional riders. Annual revenue: 8.5M with 35% coming from holiday rush orders.\nYour Role: You’ve been hired as the weekend operations manager to handle a critical scheduling crisis.\n\n\n\nIt’s Friday at 06:00 in the morning. The production manager just quit unexpectedly, leaving you with a major problem:\n\n16 custom bicycle orders received this week - all promised for delivery this Friday\n2 workstations available: Assembly Station and Painting Station\nSequential process: Every bike MUST go through Assembly first, then Painting\nSkeleton crew: Staffing is minimal - only one technician per station\nCost pressures:\n\nOvertime costs €100/hour for any work after Friday 19:00 (minute 780)\nLate delivery penalties ranging from €50 to €150 per order\nThese are one time fees for missed deadlines, the bikes still have to be completed till saturday morning as customers with missed deadlines will collect them then\n\n\nCEO’s Message: “We can’t afford to lose these customers before the holiday season. Figure out the optimal schedule and minimize our costs. Our reputation depends on it!”",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#company-background",
    "href": "tutorials/nb_06_02_scheduler.html#company-background",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "",
    "text": "Custom Cycles Manufacturing is a premium bicycle manufacturer based in Hamburg, Germany. Founded in 1998, they’ve built a reputation for high-quality custom builds with a loyal customer base of cycling enthusiasts and professional riders. Annual revenue: 8.5M with 35% coming from holiday rush orders.\nYour Role: You’ve been hired as the weekend operations manager to handle a critical scheduling crisis.",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#the-friday-afternoon-crisis",
    "href": "tutorials/nb_06_02_scheduler.html#the-friday-afternoon-crisis",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "",
    "text": "It’s Friday at 06:00 in the morning. The production manager just quit unexpectedly, leaving you with a major problem:\n\n16 custom bicycle orders received this week - all promised for delivery this Friday\n2 workstations available: Assembly Station and Painting Station\nSequential process: Every bike MUST go through Assembly first, then Painting\nSkeleton crew: Staffing is minimal - only one technician per station\nCost pressures:\n\nOvertime costs €100/hour for any work after Friday 19:00 (minute 780)\nLate delivery penalties ranging from €50 to €150 per order\nThese are one time fees for missed deadlines, the bikes still have to be completed till saturday morning as customers with missed deadlines will collect them then\n\n\nCEO’s Message: “We can’t afford to lose these customers before the holiday season. Figure out the optimal schedule and minimize our costs. Our reputation depends on it!”",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#competition-orders",
    "href": "tutorials/nb_06_02_scheduler.html#competition-orders",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Competition Orders",
    "text": "Competition Orders\n\n# DON'T MODIFY THIS DATA - These are your actual orders!\nbike_orders = [\n    {'id': 'B01', 'type': 'Standard', 'assembly': 45, 'painting': 30, 'due': 480, 'penalty': 50},\n    {'id': 'B02', 'type': 'Rush', 'assembly': 60, 'painting': 45, 'due': 360, 'penalty': 150},\n    {'id': 'B03', 'type': 'Standard', 'assembly': 30, 'painting': 25, 'due': 540, 'penalty': 50},\n    {'id': 'B04', 'type': 'Rush', 'assembly': 50, 'painting': 40, 'due': 300, 'penalty': 150},\n    {'id': 'B05', 'type': 'Custom', 'assembly': 90, 'painting': 60, 'due': 720, 'penalty': 100},\n    {'id': 'B06', 'type': 'Standard', 'assembly': 40, 'painting': 30, 'due': 600, 'penalty': 50},\n    {'id': 'B07', 'type': 'Rush', 'assembly': 35, 'painting': 25, 'due': 240, 'penalty': 150},\n    {'id': 'B08', 'type': 'Standard', 'assembly': 55, 'painting': 35, 'due': 660, 'penalty': 50},\n    {'id': 'B09', 'type': 'Custom', 'assembly': 75, 'painting': 50, 'due': 640, 'penalty': 100},\n    {'id': 'B10', 'type': 'Standard', 'assembly': 45, 'painting': 30, 'due': 520, 'penalty': 50},\n    {'id': 'B11', 'type': 'Rush', 'assembly': 40, 'painting': 35, 'due': 280, 'penalty': 150},\n    {'id': 'B12', 'type': 'Standard', 'assembly': 50, 'painting': 40, 'due': 580, 'penalty': 50},\n    {'id': 'B13', 'type': 'Custom', 'assembly': 85, 'painting': 55, 'due': 780, 'penalty': 100},\n    {'id': 'B14', 'type': 'Rush', 'assembly': 45, 'painting': 30, 'due': 320, 'penalty': 150},\n    {'id': 'B15', 'type': 'Standard', 'assembly': 35, 'painting': 25, 'due': 640, 'penalty': 50},\n    {'id': 'B16', 'type': 'Standard', 'assembly': 60, 'painting': 45, 'due': 700, 'penalty': 50}\n]\n\n# Convert to DataFrame for analysis\ndf_bikes = pd.DataFrame(bike_orders)\n\nprint(\"Custom Cycles - Rush Orders\")\nprint(\"=\" * 50)\nprint(f\"Total orders: {len(df_bikes)}\")\nprint(f\"\\nOrder breakdown by type:\")\nprint(df_bikes['type'].value_counts().to_string())\nprint(f\"\\nWorkload analysis:\")\nprint(f\"  Total assembly time: {df_bikes['assembly'].sum()} minutes ({df_bikes['assembly'].sum()/60:.1f} hours)\")\nprint(f\"  Total painting time: {df_bikes['painting'].sum()} minutes ({df_bikes['painting'].sum()/60:.1f} hours)\")\nprint(f\"  Average assembly: {df_bikes['assembly'].mean():.1f} minutes\")\nprint(f\"  Average painting: {df_bikes['painting'].mean():.1f} minutes\")\nprint(f\"\\nTime constraints:\")\nprint(f\"  Work starts: Friday 6:00 (minute 0)\")\nprint(f\"  Regular hours end: Friday 19:00 (minute 780)\")\nprint(f\"  Overtime rate: €100/hour after minute 780\")\nprint(f\"\\nPenalty exposure:\")\nprint(f\"  Total if ALL orders late: €{df_bikes['penalty'].sum():,}\")\n# DON'T MODIFY ABOVE!\n\nCustom Cycles - Rush Orders\n==================================================\nTotal orders: 16\n\nOrder breakdown by type:\ntype\nStandard    8\nRush        5\nCustom      3\n\nWorkload analysis:\n  Total assembly time: 840 minutes (14.0 hours)\n  Total painting time: 600 minutes (10.0 hours)\n  Average assembly: 52.5 minutes\n  Average painting: 37.5 minutes\n\nTime constraints:\n  Work starts: Friday 6:00 (minute 0)\n  Regular hours end: Friday 19:00 (minute 780)\n  Overtime rate: €100/hour after minute 780\n\nPenalty exposure:\n  Total if ALL orders late: €1,450",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#initial-data-exploration",
    "href": "tutorials/nb_06_02_scheduler.html#initial-data-exploration",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Initial Data Exploration",
    "text": "Initial Data Exploration\n\n# Visualize order characteristics\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\n# 1. Processing times by order\nax = axes[0, 0]\nx = np.arange(len(df_bikes))\nwidth = 0.35\nax.bar(x - width/2, df_bikes['assembly'], width, label='Assembly', color='#537E8F', alpha=0.7)\nax.bar(x + width/2, df_bikes['painting'], width, label='Painting', color='#F6B265', alpha=0.7)\nax.set_xlabel('Order ID')\nax.set_ylabel('Time (minutes)')\nax.set_title('Processing Times by Order', fontweight='bold')\nax.set_xticks(x)\nax.set_xticklabels(df_bikes['id'], rotation=45)\nax.legend()\nax.grid(axis='y', alpha=0.3)\n\n# 2. Due dates timeline\nax = axes[0, 1]\ncolors = {'Rush': '#DB6B6B', 'Standard': '#537E8F', 'Custom': '#F6B265'}\nfor order_type in ['Rush', 'Standard', 'Custom']:\n    subset = df_bikes[df_bikes['type'] == order_type]\n    ax.scatter(subset['due'], subset.index, label=order_type,\n              color=colors[order_type], s=100, alpha=0.7)\nax.axvline(x=780, color='red', linestyle='--', label='Overtime starts', linewidth=2)\nax.set_xlabel('Due Time (minutes)')\nax.set_ylabel('Order Index')\nax.set_title('Due Dates and Overtime Threshold', fontweight='bold')\nax.legend()\nax.grid(alpha=0.3)\n\n# 3. Order type distribution\nax = axes[1, 0]\ntype_counts = df_bikes['type'].value_counts()\ncolors_pie = [colors[t] for t in type_counts.index]\nax.pie(type_counts.values, labels=type_counts.index, autopct='%1.0f%%',\n       colors=colors_pie, startangle=90)\nax.set_title('Order Mix', fontweight='bold')\n\n# 4. Penalty distribution\nax = axes[1, 1]\npenalty_by_type = df_bikes.groupby('type')['penalty'].agg(['sum', 'mean', 'count'])\nx_pos = np.arange(len(penalty_by_type))\nax.bar(x_pos, penalty_by_type['sum'], color=[colors[t] for t in penalty_by_type.index], alpha=0.7)\nax.set_xlabel('Order Type')\nax.set_ylabel('Total Penalty Exposure (€)')\nax.set_title('Maximum Penalty Risk by Type', fontweight='bold')\nax.set_xticks(x_pos)\nax.set_xticklabels(penalty_by_type.index)\nax.grid(axis='y', alpha=0.3)\n\n# Add value labels\nfor i, v in enumerate(penalty_by_type['sum']):\n    ax.text(i, v, f'€{v:.0f}', ha='center', va='bottom', fontweight='bold')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"\\nKey Insights:\")\nprint(f\"  - Tightest deadline: Order {df_bikes.loc[df_bikes['due'].idxmin(), 'id']} (due at {df_bikes['due'].min()} min)\")\nprint(f\"  - Longest processing: Order {df_bikes.loc[(df_bikes['assembly']+df_bikes['painting']).idxmax(), 'id']} ({(df_bikes['assembly']+df_bikes['painting']).max()} min total)\")\nprint(f\"  - Rush orders have {df_bikes[df_bikes['type']=='Rush']['penalty'].iloc[0]/df_bikes[df_bikes['type']=='Standard']['penalty'].iloc[0]:.0f}x higher penalties\")\n\n\n\n\n\n\n\n\n\nKey Insights:\n  - Tightest deadline: Order B07 (due at 240 min)\n  - Longest processing: Order B05 (150 min total)\n  - Rush orders have 3x higher penalties",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#example-testing-a-simple-schedule",
    "href": "tutorials/nb_06_02_scheduler.html#example-testing-a-simple-schedule",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Example: Testing a Simple Schedule",
    "text": "Example: Testing a Simple Schedule\n\n# Example: Schedule in original order (FIFO approach)\nprint(\"Example: FIFO Schedule (Original Order)\")\n\n# Create sequence in original order\nfifo_sequence = [o['id'] for o in bike_orders]\nprint(f\"Order sequence: {fifo_sequence}\")\n\n# Schedule the orders (function just takes the schedule created)\n# Hint: Print `fifo_sequence` to see what's expected for the function to work\nfifo_schedule = two_stage_schedule(bike_orders, fifo_sequence)\n\n# Calculate costs (this)\nfifo_costs = calculate_schedule_cost(fifo_schedule)\n\nprint(f\"\\nResults:\")\nprint(f\"  Total Cost: €{fifo_costs['total_cost']:.2f}\")\nprint(f\"  Breakdown:\")\nprint(f\"    - Overtime: €{fifo_costs['overtime_cost']:.2f}\")\nprint(f\"    - Penalties: €{fifo_costs['penalty_cost']:.2f}\")\nprint(f\"  Late orders: {fifo_costs['late_count']} out of {len(bike_orders)}\")\nprint(f\"  Final completion: {fifo_schedule[-1]['completion']} minutes ({fifo_schedule[-1]['completion']/60:.1f} hours)\")\n\nprint(\"\\nThis is just ONE possible schedule. Can you do better?\")\n\nExample: FIFO Schedule (Original Order)\nOrder sequence: ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B09', 'B10', 'B11', 'B12', 'B13', 'B14', 'B15', 'B16']\n\nResults:\n  Total Cost: €883.33\n  Breakdown:\n    - Overtime: €233.33\n    - Penalties: €650.00\n  Late orders: 7 out of 16\n  Final completion: 885 minutes (14.8 hours)\n\nThis is just ONE possible schedule. Can you do better?",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#step-1-understand-the-problem",
    "href": "tutorials/nb_06_02_scheduler.html#step-1-understand-the-problem",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Step 1: Understand the Problem",
    "text": "Step 1: Understand the Problem\nBefore coding, think through these questions:\n\nWhat makes a “good” schedule for this problem?\nHow does the two-stage constraint affect your choices?",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#step-2-implement-different-scheduling-rules",
    "href": "tutorials/nb_06_02_scheduler.html#step-2-implement-different-scheduling-rules",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Step 2: Implement Different Scheduling Rules",
    "text": "Step 2: Implement Different Scheduling Rules\nTry multiple approaches and compare them to select the best one.\n\n# YOUR SOLUTION HERE",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#step-3-visualize-your-best-solution",
    "href": "tutorials/nb_06_02_scheduler.html#step-3-visualize-your-best-solution",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Step 3: Visualize Your Best Solution",
    "text": "Step 3: Visualize Your Best Solution\n\n# Create Gantt chart for your best solution\n# YOUR SOLUTION HERE",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#step-4-create-your-submission",
    "href": "tutorials/nb_06_02_scheduler.html#step-4-create-your-submission",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Step 4: Create Your Submission",
    "text": "Step 4: Create Your Submission\nPrepare a one-slide presentation (PDF) containing:\n\nYour Best Schedule: Total cost achieved (prominently displayed)\nApproach: Which scheduling rule(s) did you use?\nGantt Chart: Visual showing your two-stage schedule (optional but recommended)\nCost Breakdown: Overtime vs. penalties\nStrategy Justification: 2-3 sentences explaining why your approach works",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#strategy-suggestions",
    "href": "tutorials/nb_06_02_scheduler.html#strategy-suggestions",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Strategy Suggestions",
    "text": "Strategy Suggestions\n\nStart with Simple Rules: Get FIFO and EDD working first\nUnderstand Two-Stage Logic: The painting station often has idle time - that’s normal!\nConsider Trade-offs: Sometimes accepting overtime prevents expensive penalties\nJohnson’s Algorithm: It minimizes makespan, but that might not minimize costs!\nCustom Rules: Think about penalty-weighted priorities or hybrid approaches",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#common-pitfalls-to-avoid",
    "href": "tutorials/nb_06_02_scheduler.html#common-pitfalls-to-avoid",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Common Pitfalls to Avoid",
    "text": "Common Pitfalls to Avoid\n\nForgetting the two-stage constraint: Painting MUST wait for assembly to finish\nOvertime calculation: Only count minutes AFTER 1800, not total time\nPenalty logic: Only charge penalties if completion &gt; due time\nIgnoring order types: Rush orders have 3x the penalty of standard orders!",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_06_02_scheduler.html#final-checklist",
    "href": "tutorials/nb_06_02_scheduler.html#final-checklist",
    "title": "Competition 03 - The Bike Factory Crisis",
    "section": "Final Checklist",
    "text": "Final Checklist\n\nAll bikes scheduled through both stations\nPainting never starts before assembly ends\nNo negative times\nOvertime only charged after minute 1800\nPenalties only for late orders (completion &gt; due)\nTotal cost = overtime + penalties",
    "crumbs": [
      "06 Greedy Search",
      "NB-06-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html",
    "href": "tutorials/nb_07_02_routing_competition.html",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "“Every morning at 5 AM, our delivery van leaves with fresh bread for 16 cafés across the city. Our driver currently takes much too long using his ‘intuition’ for the route. The fuel costs are killing us, and worse, some cafés get their bread late.\nThree of our premium clients open early at 6:30 AM and absolutely MUST have their bread by then. The others open at 8:00 AM or later. We’re spending way too much daily in excess fuel and labor costs.\nCan you optimize our morning delivery route? We need a solution that handles our early-bird cafés and minimizes total distance. Help us deliver happiness more efficiently!“\n\n\n\n\n\n\nCurrent situation: driver’s intuition, frequent late deliveries\nCost structure:\n\nFuel: €1.80 per km\nDriver: €35 per hour\nLate penalty: €50 per late delivery (damages reputation)\n\nVehicle: One delivery van, 20 km/h average speed in morning traffic\nService Time: 2 minutes at each café\n\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport math\nfrom datetime import datetime, timedelta\n\n# DON'T MODIFY THIS DATA \nnp.random.seed(2025)\n\n# Bakery location (city center)\nbakery_location = (3.0, 1.0)\n\n# Generate 16 café locations randomly in a 10x10 km area\ncafe_locations = []\nfor i in range(16):\n    x = np.random.uniform(0.5, 9.5)\n    y = np.random.uniform(0.5, 9.5)\n    cafe_locations.append((x, y))\n\n# Café names and opening times\ncafe_info = pd.DataFrame({\n    'cafe_id': range(1, 17),\n    'name': [\n        'Sunrise Bistro', 'The Daily Grind', 'Café Europa', 'Corner Coffee',\n        'South Side Café', 'West End Espresso', 'Riverside Roast', 'Morning Glory',\n        'Hilltop Haven', 'Central Perk', 'Midtown Munch', 'Old Town Oven',\n        'Eastside Express', 'Downtown Deli', 'Westpark Café', 'Plaza Perks'\n    ],\n    'x': [loc[0] for loc in cafe_locations],\n    'y': [loc[1] for loc in cafe_locations],\n    'opening_time': [\n        '06:30', '08:00', '06:30', '08:00',  # Cafés 1-4\n        '08:00', '08:00', '08:00', '06:30',  # Cafés 5-8\n        '08:00', '08:00', '08:00', '08:00',  # Cafés 9-12\n        '08:00', '08:00', '08:00', '08:00'   # Cafés 13-16\n    ],\n    'time_window': [\n        'EARLY', 'Regular', 'EARLY', 'Regular',  # Cafés 1-4\n        'Regular', 'Regular', 'Regular', 'EARLY',  # Cafés 5-8\n        'Regular', 'Regular', 'Regular', 'Regular',  # Cafés 9-12\n        'Regular', 'Regular', 'Regular', 'Regular'   # Cafés 13-16\n    ]\n})\n\n# Display the café information\nprint(\"CAFÉ INFORMATION:\")\nprint(\"=\" * 60)\nprint(cafe_info.to_string(index=False))\nprint(\"\\n\" + \"=\" * 60)\nprint(f\"Bakery location: {bakery_location}\")\nprint(f\"Departure time: 5:00 AM\")\nprint(f\"Average speed: 40 km/h\")\nprint(\"\\nEARLY cafés (must arrive before opening):\")\nfor _, row in cafe_info[cafe_info['time_window'] == 'EARLY'].iterrows():\n    print(f\"  - {row['name']} (Café {row['cafe_id']}): Opens at {row['opening_time']}\")\n# DON'T MODIFY THIS DATA \n\nCAFÉ INFORMATION:\n============================================================\n cafe_id              name        x        y opening_time time_window\n       1    Sunrise Bistro 1.719393 8.490665        06:30       EARLY\n       2   The Daily Grind 8.893451 4.510113        08:00     Regular\n       3       Café Europa 3.994120 2.818368        06:30       EARLY\n       4     Corner Coffee 6.416308 4.933552        08:00     Regular\n       5   South Side Café 9.178146 7.708860        08:00     Regular\n       6 West End Espresso 4.596848 7.709523        08:00     Regular\n       7   Riverside Roast 0.875462 7.425121        08:00     Regular\n       8     Morning Glory 0.528540 3.135285        06:30       EARLY\n       9     Hilltop Haven 5.998229 8.717247        08:00     Regular\n      10      Central Perk 3.201035 2.737388        08:00     Regular\n      11     Midtown Munch 6.497529 9.387796        08:00     Regular\n      12     Old Town Oven 4.714434 1.609586        08:00     Regular\n      13  Eastside Express 8.744282 9.015292        08:00     Regular\n      14     Downtown Deli 2.999276 5.176883        08:00     Regular\n      15     Westpark Café 1.892705 0.631646        08:00     Regular\n      16       Plaza Perks 3.418189 9.418086        08:00     Regular\n\n============================================================\nBakery location: (3.0, 1.0)\nDeparture time: 5:00 AM\nAverage speed: 40 km/h\n\nEARLY cafés (must arrive before opening):\n  - Sunrise Bistro (Café 1): Opens at 06:30\n  - Café Europa (Café 3): Opens at 06:30\n  - Morning Glory (Café 8): Opens at 06:30\n\n\n\n\n\n\ndef calculate_distance(point1, point2):\n    \"\"\"Calculate Euclidean distance between two points.\"\"\"\n    return np.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n\ndef create_distance_matrix(bakery_loc, cafe_locs):\n    \"\"\"Create a distance matrix for all locations.\"\"\"\n    all_locations = [bakery_loc] + cafe_locs\n    n = len(all_locations)\n    distances = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distances[i][j] = calculate_distance(all_locations[i], all_locations[j])\n\n    return distances\n\ndef calculate_route_distance(route, distance_matrix):\n    \"\"\"\n    Calculate total distance for a route (returns to start).\n    \n    Args:\n        route: List of café indices in visit order (1-16)\n        distance_matrix: Distance matrix (17x17, index 0 is bakery)\n    \n    Returns:\n        Total distance in km\n    \"\"\"\n    total = distance_matrix[0][route[0]]  # Bakery to first café\n    for i in range(len(route) - 1):\n        total += distance_matrix[route[i]][route[i+1]]  # Between cafés\n    total += distance_matrix[route[-1]][0]  # Last café back to bakery\n    return total\n\ndef calculate_arrival_times(route, distance_matrix, start_time=\"05:00\", speed_kmh=20):\n    \"\"\"Calculate arrival time at each café.\"\"\"\n    arrivals = []\n    current_time = datetime.strptime(start_time, \"%H:%M\")\n\n    # Time to first café\n    travel_minutes = (distance_matrix[0][route[0]] / speed_kmh) * 60\n    current_time += timedelta(minutes=travel_minutes)\n    arrivals.append(current_time.strftime(\"%H:%M\"))\n\n    # Time between cafés\n    for i in range(len(route) - 1):\n        travel_minutes = (distance_matrix[route[i]][route[i+1]] / speed_kmh) * 60\n        current_time += timedelta(minutes=travel_minutes + 2)  # 2 min service time\n        arrivals.append(current_time.strftime(\"%H:%M\"))\n\n    return arrivals\n\ndef check_time_windows(route, distance_matrix, cafe_info):\n    \"\"\"Check if route meets time window constraints.\"\"\"\n    arrivals = calculate_arrival_times(route, distance_matrix)\n    violations = []\n\n    for i, cafe_idx in enumerate(route):\n        cafe = cafe_info.iloc[cafe_idx - 1]\n        arrival = arrivals[i]\n        opening = cafe['opening_time']\n\n        if cafe['time_window'] == 'EARLY' and arrival &gt; opening:\n            violations.append({\n                'cafe': cafe['name'],\n                'arrival': arrival,\n                'opening': opening,\n                'late_by': (datetime.strptime(arrival, \"%H:%M\") -\n                          datetime.strptime(opening, \"%H:%M\")).seconds // 60\n            })\n\n    return violations\n\n# Create distance matrix\ndistance_matrix = create_distance_matrix(bakery_location, cafe_locations)\nprint(\"\\nDistance matrix created. Ready to optimize!\")\n\n\nDistance matrix created. Ready to optimize!\n\n\n\n\n\n\ndef visualize_route(route, cafe_info, bakery_loc, title=\"Delivery Route\"):\n    \"\"\"Visualize the delivery route on a map.\"\"\"\n    plt.figure()\n\n    # Plot cafés\n    for _, cafe in cafe_info.iterrows():\n        color = '#D73502' if cafe['time_window'] == 'EARLY' else '#537E8F'\n        plt.scatter(cafe['x'], cafe['y'], s=200, c=color, zorder=3)\n        plt.annotate(f\"{cafe['cafe_id']}\", (cafe['x'], cafe['y']),\n                    ha='center', va='center', color='white', fontweight='bold')\n\n    # Plot bakery\n    plt.scatter(bakery_loc[0], bakery_loc[1], s=400, c='#F4A582',\n               marker='s', zorder=3, label='Bakery')\n\n    # Plot route if provided\n    if route:\n        route_x = [bakery_loc[0]]\n        route_y = [bakery_loc[1]]\n        for cafe_id in route:\n            cafe = cafe_info.iloc[cafe_id - 1]\n            route_x.append(cafe['x'])\n            route_y.append(cafe['y'])\n        route_x.append(bakery_loc[0])\n        route_y.append(bakery_loc[1])\n\n        plt.plot(route_x, route_y, 'o-', color='gray', linewidth=2,\n                markersize=0, alpha=0.6)\n\n        # Add route order annotations\n        for i, cafe_id in enumerate(route, 1):\n            cafe = cafe_info.iloc[cafe_id - 1]\n            plt.annotate(f\"#{i}\", (cafe['x'], cafe['y']),\n                        xytext=(10, 10), textcoords='offset points',\n                        fontsize=8, color='black')\n\n    plt.xlabel('Distance East-West (km)')\n    plt.ylabel('Distance North-South (km)')\n    plt.title(title, fontsize=14, fontweight='bold')\n    plt.grid(True, alpha=0.3)\n\n    # Legend\n    from matplotlib.patches import Patch\n    legend_elements = [\n        Patch(facecolor='#D73502', label='Early Café (6:30-6:45 AM)'),\n        Patch(facecolor='#537E8F', label='Regular Café (7:00+ AM)'),\n        Patch(facecolor='#F4A582', label='Bakery')\n    ]\n    plt.legend(handles=legend_elements, loc='upper right')\n\n    plt.tight_layout()\n    plt.show()\n\n# Show the initial problem\nvisualize_route([], cafe_info, bakery_location, \"Artisan Bakery Delivery Network\")\n\n\n\n\n\n\n\n\n\n\n\nIn the lecture, you learned that optimization problems can be solved using local search by defining four components:\n\nSearch Space: All possible routes visiting 16 cafés\nInitial Solution: Your construction algorithm creates a starting route\nObjective Function: Total distance traveled (minimize this!)\nNeighborhood: How to create “nearby” solutions (2-opt swaps, Or-opt moves, etc.)\n\nYour task is to implement these components for the bakery delivery problem.\n\n\n\n\n\n\n\nEnsure early cafés are visited before their opening times\nYou may need to modify your algorithm to prioritize these\nUse the provided check_time_windows() function to verify feasibility\n\n\n\n\n\n\n\n\n\n\nIf time windows are too difficult for you, ignore them and just optimized the route. You will have to pay some penalty then, but it is potentially still better than the current route based on the drivers intuition.\n\n\n\n\n\n\nTry one or multiple approaches to create your initial solution.\n\n# YOUR SOLUTION HERE\n\n\n\n\nUse one or multiple local search algorithms to improve your initial solution.\n\n# YOUR SOLUTION HERE\n\n\n\n\n\n# YOUR SOLUTION HERE\n\n\n\n\n\n# YOUR SOLUTION HERE\n\n\n\n\nPrepare a one-slide presentation (PDF) containing:\n\nYour Best Route: Total cost (potentially compared to random route)\nApproach: Which initial construction and local search methods did you use?\nMap: Visual showing routes (optional but recommended)\nStrategy Justification: 2-3 sentences explaining why your approach works\n\n\n\n\n\n\n\nQuick Win: Start with nearest neighbor, it’s simple and often good enough\n\nYou practiced this in the tutorial with Bean Counter’s 10 franchises\n\nTime Windows First: Consider visiting early cafés first, even if slightly suboptimal\n\nThe lecture showed how to modify construction algorithms for time constraints\n\nImprovement Focus: Even basic 2-opt can save 10-20% distance\n\nRemember to check feasibility after each swap\n\nValidation: Always check time windows!\n\nUse check_time_windows() to verify your solution\n\n\n\n\n\n\nForgetting to return to bakery\nNot checking time windows until the end\nOver-optimizing distance at the expense of deadlines\nStarting from a café instead of the bakery\n\n\n\n\n“The early bird cafés are my premium clients. I’d rather drive an extra kilometer than be late to them!”\n“My current driver always does the early cafés first, then figures out the rest. Maybe he’s onto something?”\n“Sometimes the ‘shortest’ route isn’t the best route when you factor in traffic patterns and delivery windows.”\n\n\n\n\nBefore presenting your solution, verify:\n\nAll 16 cafés visited exactly once\nRoute starts and ends at the bakery\nEarly cafés (1, 3, 8) arrive before their opening times (if possible!)\nNo time window violations reported by check_time_windows()\nRoute distance calculated correctly (includes return to bakery)\nImprovement shown from initial to final solution\nOne-slide presentation ready with visualization and metrics",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#the-morning-delivery-crisis",
    "href": "tutorials/nb_07_02_routing_competition.html#the-morning-delivery-crisis",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "“Every morning at 5 AM, our delivery van leaves with fresh bread for 16 cafés across the city. Our driver currently takes much too long using his ‘intuition’ for the route. The fuel costs are killing us, and worse, some cafés get their bread late.\nThree of our premium clients open early at 6:30 AM and absolutely MUST have their bread by then. The others open at 8:00 AM or later. We’re spending way too much daily in excess fuel and labor costs.\nCan you optimize our morning delivery route? We need a solution that handles our early-bird cafés and minimizes total distance. Help us deliver happiness more efficiently!“",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#the-challenge",
    "href": "tutorials/nb_07_02_routing_competition.html#the-challenge",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "Current situation: driver’s intuition, frequent late deliveries\nCost structure:\n\nFuel: €1.80 per km\nDriver: €35 per hour\nLate penalty: €50 per late delivery (damages reputation)\n\nVehicle: One delivery van, 20 km/h average speed in morning traffic\nService Time: 2 minutes at each café",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#data-starter-code",
    "href": "tutorials/nb_07_02_routing_competition.html#data-starter-code",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport math\nfrom datetime import datetime, timedelta\n\n# DON'T MODIFY THIS DATA \nnp.random.seed(2025)\n\n# Bakery location (city center)\nbakery_location = (3.0, 1.0)\n\n# Generate 16 café locations randomly in a 10x10 km area\ncafe_locations = []\nfor i in range(16):\n    x = np.random.uniform(0.5, 9.5)\n    y = np.random.uniform(0.5, 9.5)\n    cafe_locations.append((x, y))\n\n# Café names and opening times\ncafe_info = pd.DataFrame({\n    'cafe_id': range(1, 17),\n    'name': [\n        'Sunrise Bistro', 'The Daily Grind', 'Café Europa', 'Corner Coffee',\n        'South Side Café', 'West End Espresso', 'Riverside Roast', 'Morning Glory',\n        'Hilltop Haven', 'Central Perk', 'Midtown Munch', 'Old Town Oven',\n        'Eastside Express', 'Downtown Deli', 'Westpark Café', 'Plaza Perks'\n    ],\n    'x': [loc[0] for loc in cafe_locations],\n    'y': [loc[1] for loc in cafe_locations],\n    'opening_time': [\n        '06:30', '08:00', '06:30', '08:00',  # Cafés 1-4\n        '08:00', '08:00', '08:00', '06:30',  # Cafés 5-8\n        '08:00', '08:00', '08:00', '08:00',  # Cafés 9-12\n        '08:00', '08:00', '08:00', '08:00'   # Cafés 13-16\n    ],\n    'time_window': [\n        'EARLY', 'Regular', 'EARLY', 'Regular',  # Cafés 1-4\n        'Regular', 'Regular', 'Regular', 'EARLY',  # Cafés 5-8\n        'Regular', 'Regular', 'Regular', 'Regular',  # Cafés 9-12\n        'Regular', 'Regular', 'Regular', 'Regular'   # Cafés 13-16\n    ]\n})\n\n# Display the café information\nprint(\"CAFÉ INFORMATION:\")\nprint(\"=\" * 60)\nprint(cafe_info.to_string(index=False))\nprint(\"\\n\" + \"=\" * 60)\nprint(f\"Bakery location: {bakery_location}\")\nprint(f\"Departure time: 5:00 AM\")\nprint(f\"Average speed: 40 km/h\")\nprint(\"\\nEARLY cafés (must arrive before opening):\")\nfor _, row in cafe_info[cafe_info['time_window'] == 'EARLY'].iterrows():\n    print(f\"  - {row['name']} (Café {row['cafe_id']}): Opens at {row['opening_time']}\")\n# DON'T MODIFY THIS DATA \n\nCAFÉ INFORMATION:\n============================================================\n cafe_id              name        x        y opening_time time_window\n       1    Sunrise Bistro 1.719393 8.490665        06:30       EARLY\n       2   The Daily Grind 8.893451 4.510113        08:00     Regular\n       3       Café Europa 3.994120 2.818368        06:30       EARLY\n       4     Corner Coffee 6.416308 4.933552        08:00     Regular\n       5   South Side Café 9.178146 7.708860        08:00     Regular\n       6 West End Espresso 4.596848 7.709523        08:00     Regular\n       7   Riverside Roast 0.875462 7.425121        08:00     Regular\n       8     Morning Glory 0.528540 3.135285        06:30       EARLY\n       9     Hilltop Haven 5.998229 8.717247        08:00     Regular\n      10      Central Perk 3.201035 2.737388        08:00     Regular\n      11     Midtown Munch 6.497529 9.387796        08:00     Regular\n      12     Old Town Oven 4.714434 1.609586        08:00     Regular\n      13  Eastside Express 8.744282 9.015292        08:00     Regular\n      14     Downtown Deli 2.999276 5.176883        08:00     Regular\n      15     Westpark Café 1.892705 0.631646        08:00     Regular\n      16       Plaza Perks 3.418189 9.418086        08:00     Regular\n\n============================================================\nBakery location: (3.0, 1.0)\nDeparture time: 5:00 AM\nAverage speed: 40 km/h\n\nEARLY cafés (must arrive before opening):\n  - Sunrise Bistro (Café 1): Opens at 06:30\n  - Café Europa (Café 3): Opens at 06:30\n  - Morning Glory (Café 8): Opens at 06:30",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#starter-code-helper-functions",
    "href": "tutorials/nb_07_02_routing_competition.html#starter-code-helper-functions",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "def calculate_distance(point1, point2):\n    \"\"\"Calculate Euclidean distance between two points.\"\"\"\n    return np.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)\n\ndef create_distance_matrix(bakery_loc, cafe_locs):\n    \"\"\"Create a distance matrix for all locations.\"\"\"\n    all_locations = [bakery_loc] + cafe_locs\n    n = len(all_locations)\n    distances = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distances[i][j] = calculate_distance(all_locations[i], all_locations[j])\n\n    return distances\n\ndef calculate_route_distance(route, distance_matrix):\n    \"\"\"\n    Calculate total distance for a route (returns to start).\n    \n    Args:\n        route: List of café indices in visit order (1-16)\n        distance_matrix: Distance matrix (17x17, index 0 is bakery)\n    \n    Returns:\n        Total distance in km\n    \"\"\"\n    total = distance_matrix[0][route[0]]  # Bakery to first café\n    for i in range(len(route) - 1):\n        total += distance_matrix[route[i]][route[i+1]]  # Between cafés\n    total += distance_matrix[route[-1]][0]  # Last café back to bakery\n    return total\n\ndef calculate_arrival_times(route, distance_matrix, start_time=\"05:00\", speed_kmh=20):\n    \"\"\"Calculate arrival time at each café.\"\"\"\n    arrivals = []\n    current_time = datetime.strptime(start_time, \"%H:%M\")\n\n    # Time to first café\n    travel_minutes = (distance_matrix[0][route[0]] / speed_kmh) * 60\n    current_time += timedelta(minutes=travel_minutes)\n    arrivals.append(current_time.strftime(\"%H:%M\"))\n\n    # Time between cafés\n    for i in range(len(route) - 1):\n        travel_minutes = (distance_matrix[route[i]][route[i+1]] / speed_kmh) * 60\n        current_time += timedelta(minutes=travel_minutes + 2)  # 2 min service time\n        arrivals.append(current_time.strftime(\"%H:%M\"))\n\n    return arrivals\n\ndef check_time_windows(route, distance_matrix, cafe_info):\n    \"\"\"Check if route meets time window constraints.\"\"\"\n    arrivals = calculate_arrival_times(route, distance_matrix)\n    violations = []\n\n    for i, cafe_idx in enumerate(route):\n        cafe = cafe_info.iloc[cafe_idx - 1]\n        arrival = arrivals[i]\n        opening = cafe['opening_time']\n\n        if cafe['time_window'] == 'EARLY' and arrival &gt; opening:\n            violations.append({\n                'cafe': cafe['name'],\n                'arrival': arrival,\n                'opening': opening,\n                'late_by': (datetime.strptime(arrival, \"%H:%M\") -\n                          datetime.strptime(opening, \"%H:%M\")).seconds // 60\n            })\n\n    return violations\n\n# Create distance matrix\ndistance_matrix = create_distance_matrix(bakery_location, cafe_locations)\nprint(\"\\nDistance matrix created. Ready to optimize!\")\n\n\nDistance matrix created. Ready to optimize!",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#visualization-function",
    "href": "tutorials/nb_07_02_routing_competition.html#visualization-function",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "def visualize_route(route, cafe_info, bakery_loc, title=\"Delivery Route\"):\n    \"\"\"Visualize the delivery route on a map.\"\"\"\n    plt.figure()\n\n    # Plot cafés\n    for _, cafe in cafe_info.iterrows():\n        color = '#D73502' if cafe['time_window'] == 'EARLY' else '#537E8F'\n        plt.scatter(cafe['x'], cafe['y'], s=200, c=color, zorder=3)\n        plt.annotate(f\"{cafe['cafe_id']}\", (cafe['x'], cafe['y']),\n                    ha='center', va='center', color='white', fontweight='bold')\n\n    # Plot bakery\n    plt.scatter(bakery_loc[0], bakery_loc[1], s=400, c='#F4A582',\n               marker='s', zorder=3, label='Bakery')\n\n    # Plot route if provided\n    if route:\n        route_x = [bakery_loc[0]]\n        route_y = [bakery_loc[1]]\n        for cafe_id in route:\n            cafe = cafe_info.iloc[cafe_id - 1]\n            route_x.append(cafe['x'])\n            route_y.append(cafe['y'])\n        route_x.append(bakery_loc[0])\n        route_y.append(bakery_loc[1])\n\n        plt.plot(route_x, route_y, 'o-', color='gray', linewidth=2,\n                markersize=0, alpha=0.6)\n\n        # Add route order annotations\n        for i, cafe_id in enumerate(route, 1):\n            cafe = cafe_info.iloc[cafe_id - 1]\n            plt.annotate(f\"#{i}\", (cafe['x'], cafe['y']),\n                        xytext=(10, 10), textcoords='offset points',\n                        fontsize=8, color='black')\n\n    plt.xlabel('Distance East-West (km)')\n    plt.ylabel('Distance North-South (km)')\n    plt.title(title, fontsize=14, fontweight='bold')\n    plt.grid(True, alpha=0.3)\n\n    # Legend\n    from matplotlib.patches import Patch\n    legend_elements = [\n        Patch(facecolor='#D73502', label='Early Café (6:30-6:45 AM)'),\n        Patch(facecolor='#537E8F', label='Regular Café (7:00+ AM)'),\n        Patch(facecolor='#F4A582', label='Bakery')\n    ]\n    plt.legend(handles=legend_elements, loc='upper right')\n\n    plt.tight_layout()\n    plt.show()\n\n# Show the initial problem\nvisualize_route([], cafe_info, bakery_location, \"Artisan Bakery Delivery Network\")",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#your-task",
    "href": "tutorials/nb_07_02_routing_competition.html#your-task",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "In the lecture, you learned that optimization problems can be solved using local search by defining four components:\n\nSearch Space: All possible routes visiting 16 cafés\nInitial Solution: Your construction algorithm creates a starting route\nObjective Function: Total distance traveled (minimize this!)\nNeighborhood: How to create “nearby” solutions (2-opt swaps, Or-opt moves, etc.)\n\nYour task is to implement these components for the bakery delivery problem.\n\n\n\n\n\n\n\nEnsure early cafés are visited before their opening times\nYou may need to modify your algorithm to prioritize these\nUse the provided check_time_windows() function to verify feasibility\n\n\n\n\n\n\n\n\n\n\nIf time windows are too difficult for you, ignore them and just optimized the route. You will have to pay some penalty then, but it is potentially still better than the current route based on the drivers intuition.",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#step-1-initial-solution",
    "href": "tutorials/nb_07_02_routing_competition.html#step-1-initial-solution",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "Try one or multiple approaches to create your initial solution.\n\n# YOUR SOLUTION HERE",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#step-2-apply-local-search",
    "href": "tutorials/nb_07_02_routing_competition.html#step-2-apply-local-search",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "Use one or multiple local search algorithms to improve your initial solution.\n\n# YOUR SOLUTION HERE",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#step-3-visualize-your-best-solution",
    "href": "tutorials/nb_07_02_routing_competition.html#step-3-visualize-your-best-solution",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "# YOUR SOLUTION HERE",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#step-4-compute-the-financial-impact",
    "href": "tutorials/nb_07_02_routing_competition.html#step-4-compute-the-financial-impact",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "# YOUR SOLUTION HERE",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#step-5-create-your-submission",
    "href": "tutorials/nb_07_02_routing_competition.html#step-5-create-your-submission",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "Prepare a one-slide presentation (PDF) containing:\n\nYour Best Route: Total cost (potentially compared to random route)\nApproach: Which initial construction and local search methods did you use?\nMap: Visual showing routes (optional but recommended)\nStrategy Justification: 2-3 sentences explaining why your approach works",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#tips-for-success",
    "href": "tutorials/nb_07_02_routing_competition.html#tips-for-success",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "Quick Win: Start with nearest neighbor, it’s simple and often good enough\n\nYou practiced this in the tutorial with Bean Counter’s 10 franchises\n\nTime Windows First: Consider visiting early cafés first, even if slightly suboptimal\n\nThe lecture showed how to modify construction algorithms for time constraints\n\nImprovement Focus: Even basic 2-opt can save 10-20% distance\n\nRemember to check feasibility after each swap\n\nValidation: Always check time windows!\n\nUse check_time_windows() to verify your solution\n\n\n\n\n\n\nForgetting to return to bakery\nNot checking time windows until the end\nOver-optimizing distance at the expense of deadlines\nStarting from a café instead of the bakery\n\n\n\n\n“The early bird cafés are my premium clients. I’d rather drive an extra kilometer than be late to them!”\n“My current driver always does the early cafés first, then figures out the rest. Maybe he’s onto something?”\n“Sometimes the ‘shortest’ route isn’t the best route when you factor in traffic patterns and delivery windows.”",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_07_02_routing_competition.html#final-checklist",
    "href": "tutorials/nb_07_02_routing_competition.html#final-checklist",
    "title": "Competition 04 - The Bakery Delivery Route",
    "section": "",
    "text": "Before presenting your solution, verify:\n\nAll 16 cafés visited exactly once\nRoute starts and ends at the bakery\nEarly cafés (1, 3, 8) arrive before their opening times (if possible!)\nNo time window violations reported by check_time_windows()\nRoute distance calculated correctly (includes return to bakery)\nImprovement shown from initial to final solution\nOne-slide presentation ready with visualization and metrics",
    "crumbs": [
      "07 Local Search",
      "NB-07-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html",
    "href": "tutorials/nb_08_02_fleet_optimization.html",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "",
    "text": "EcoExpress Logistics needs your consulting expertise to design a sustainable delivery fleet.\nOperations Director’s Dilemma: “EU regulations demand 40% emission cuts, but we can’t sacrifice profitability, service quality, or reliability!”\n\n\nThe current fleet of 80 diesel vans faces critical challenges:\n\nEU Green Deal: 40% emission reduction mandate by 2025\nRising fuel costs (€2.1/L diesel)\nCompetition entering market with 2-hour delivery promise\nDriver shortage (15% unfilled positions)\n\n\n\n\nThe current fleet of 80 diesel vans must be replaced to meet EU regulations and remain competitive.\nYour task: Design the optimal fleet composition balancing:\n\nMinimize Total Cost (purchase + annual operating costs)\nMaximize Service Score (capacity + reliability + speed)\nHard Constraint: Average CO2 emissions ≤ 111 g/km\n\n\n\n\n\nDaily demand: 22,000 parcels across 3 cities\nAverage daily distance: 1,200 km\nOperating days per year: 360\nBudget guideline: ~€35M capital investment",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#client-briefing",
    "href": "tutorials/nb_08_02_fleet_optimization.html#client-briefing",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "",
    "text": "EcoExpress Logistics needs your consulting expertise to design a sustainable delivery fleet.\nOperations Director’s Dilemma: “EU regulations demand 40% emission cuts, but we can’t sacrifice profitability, service quality, or reliability!”\n\n\nThe current fleet of 80 diesel vans faces critical challenges:\n\nEU Green Deal: 40% emission reduction mandate by 2025\nRising fuel costs (€2.1/L diesel)\nCompetition entering market with 2-hour delivery promise\nDriver shortage (15% unfilled positions)\n\n\n\n\nThe current fleet of 80 diesel vans must be replaced to meet EU regulations and remain competitive.\nYour task: Design the optimal fleet composition balancing:\n\nMinimize Total Cost (purchase + annual operating costs)\nMaximize Service Score (capacity + reliability + speed)\nHard Constraint: Average CO2 emissions ≤ 111 g/km\n\n\n\n\n\nDaily demand: 22,000 parcels across 3 cities\nAverage daily distance: 1,200 km\nOperating days per year: 360\nBudget guideline: ~€35M capital investment",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#available-vehicles",
    "href": "tutorials/nb_08_02_fleet_optimization.html#available-vehicles",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Available Vehicles",
    "text": "Available Vehicles\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom typing import Dict, List, Tuple\n\n# Set random seed\nnp.random.seed(2025)\n\n# Vehicle specifications\nvehicles = pd.DataFrame({\n    'Type': ['Electric Truck', 'Hybrid Van', 'Diesel Van', 'E-Cargo Bike', 'Autonomous Pod'],\n    'Purchase_Cost': [75000, 45000, 35000, 12000, 95000],  # €\n    'Operating_Cost_per_km': [0.18, 0.25, 0.38, 0.05, 0.12],  # €/km\n    'CO2_per_km': [0, 95, 185, 0, 0],  # g/km\n    'Speed_kmh': [55, 65, 70, 30, 40],  # km/h average\n    'Daily_Capacity': [300, 200, 250, 50, 150],  # parcels per vehicle\n    'Reliability': [0.93, 0.95, 0.88, 0.98, 0.94],  # uptime %\n})\n\nprint(\"EcoExpress Vehicle Options:\")\nprint(vehicles.to_string(index=False))\n\nEcoExpress Vehicle Options:\n          Type  Purchase_Cost  Operating_Cost_per_km  CO2_per_km  Speed_kmh  Daily_Capacity  Reliability\nElectric Truck          75000                   0.18           0         55             300         0.93\n    Hybrid Van          45000                   0.25          95         65             200         0.95\n    Diesel Van          35000                   0.38         185         70             250         0.88\n  E-Cargo Bike          12000                   0.05           0         30              50         0.98\nAutonomous Pod          95000                   0.12           0         40             150         0.94\n\n\n\n\n\n\n\n\nTipThe Vehicles\n\n\n\n\nElectric Truck: Zero emissions, high capacity, expensive\nHybrid Van: Balanced option, good reliability\nDiesel Van: Cheapest, but high emissions (may violate constraint!)\nE-Cargo Bike: Zero emissions, perfect for city centers, low capacity\nAutonomous Pod: Expensive upfront, low operating cost, 24/7 operation",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#helper-functions",
    "href": "tutorials/nb_08_02_fleet_optimization.html#helper-functions",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Helper Functions",
    "text": "Helper Functions\n\nCalculate Fleet Metrics\nThis function evaluates ANY fleet composition on both objectives and the constraint.\n\ndef calculate_fleet_metrics(fleet_composition: Dict[str, int]) -&gt; Dict:\n    \"\"\"\n    Calculate metrics for a given fleet composition.\n    \n    Args:\n        fleet_composition: Dict like {'Electric Truck': 20, 'Hybrid Van': 30, ...}\n    \n    Returns:\n        Dict with: total_cost, service_score, avg_co2, total_capacity, total_vehicles\n    \"\"\"\n    # Constants\n    DAILY_DISTANCE = 1200  # km\n    OPERATING_DAYS = 360\n    REQUIRED_CAPACITY = 22000  # parcels/day\n    \n    # Initialize\n    total_purchase = 0\n    total_annual_operating = 0\n    total_capacity = 0\n    weighted_co2 = 0\n    weighted_reliability = 0\n    weighted_speed = 0\n    total_vehicles = sum(fleet_composition.values())\n    \n    # Calculate for each vehicle type\n    for vehicle_type, quantity in fleet_composition.items():\n        if quantity == 0:\n            continue\n            \n        # Get vehicle specs\n        vehicle = vehicles[vehicles['Type'] == vehicle_type].iloc[0]\n        \n        # Costs\n        total_purchase += vehicle['Purchase_Cost'] * quantity\n        annual_operating = vehicle['Operating_Cost_per_km'] * DAILY_DISTANCE * OPERATING_DAYS * quantity\n        total_annual_operating += annual_operating\n        \n        # Capacity and performance\n        total_capacity += vehicle['Daily_Capacity'] * quantity\n        weighted_co2 += vehicle['CO2_per_km'] * quantity\n        weighted_reliability += vehicle['Reliability'] * quantity\n        weighted_speed += vehicle['Speed_kmh'] * quantity\n    \n    # Calculate averages\n    avg_co2 = weighted_co2 / total_vehicles if total_vehicles &gt; 0 else 999\n    avg_reliability = weighted_reliability / total_vehicles if total_vehicles &gt; 0 else 0\n    avg_speed = weighted_speed / total_vehicles if total_vehicles &gt; 0 else 0\n    \n    # Total cost (purchase + 3 years operating)\n    total_cost = total_purchase + (total_annual_operating * 3)\n    \n    # Service score components\n    capacity_score = min(1.0, total_capacity / REQUIRED_CAPACITY)  # Caps at 1.0\n    reliability_score = avg_reliability\n    speed_score = avg_speed / 70  # Normalize to fastest vehicle\n    \n    # Combined service score (weighted average)\n    service_score = 0.5 * capacity_score + 0.3 * reliability_score + 0.2 * speed_score\n    \n    return {\n        'total_cost': total_cost,\n        'service_score': service_score,\n        'avg_co2': avg_co2,\n        'total_capacity': total_capacity,\n        'total_vehicles': total_vehicles,\n        'capacity_score': capacity_score,\n        'reliability_score': reliability_score,\n        'speed_score': speed_score\n    }\n\n\n\nExample Fleet Evaluation\n\n# Example: A balanced fleet\nexample_fleet = {\n    'Electric Truck': 15,\n    'Hybrid Van': 25,\n    'Diesel Van': 10,\n    'E-Cargo Bike': 20,\n    'Autonomous Pod': 5\n}\n\nmetrics = calculate_fleet_metrics(example_fleet)\n\nprint(\"\\nExample Fleet Performance:\")\nprint(f\"  Total Cost: €{metrics['total_cost']:,.0f}\")\nprint(f\"  Service Score: {metrics['service_score']:.3f}\")\nprint(f\"  Average CO2: {metrics['avg_co2']:.1f} g/km\")\nprint(f\"  Total Capacity: {metrics['total_capacity']:,} parcels/day\")\nprint(f\"  Total Vehicles: {metrics['total_vehicles']}\")\nprint(f\"\\n  EU Compliant: {'✓ YES' if metrics['avg_co2'] &lt;= 111 else '✗ NO'}\")\nprint(f\"  Sufficient Capacity: {'✓ YES' if metrics['total_capacity'] &gt;= 22000 else '✗ NO'}\")\n\n\nExample Fleet Performance:\n  Total Cost: €21,912,600\n  Service Score: 0.746\n  Average CO2: 56.3 g/km\n  Total Capacity: 13,750 parcels/day\n  Total Vehicles: 75\n\n  EU Compliant: ✓ YES\n  Sufficient Capacity: ✗ NO\n\n\n\n\n\n\n\n\nWarningCapacity Matters!\n\n\n\nYour fleet should have enough capacity to handle 22,000 daily parcels. The service score includes a capacity component that penalizes fleets that can’t meet demand.\nCapacity score = min(1.0, total_capacity / 22,000)\n\nIf capacity = 22,000 → capacity_score = 1.0 (perfect)\nIf capacity = 11,000 → capacity_score = 0.5 (only 50%!)",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#your-task",
    "href": "tutorials/nb_08_02_fleet_optimization.html#your-task",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Your Task",
    "text": "Your Task\nDesign the optimal fleet composition balancing:\n\nMinimize Total Cost (purchase + annual operating costs)\nMaximize Service Score (capacity + reliability + speed)\nHard Constraint: Average CO2 emissions ≤ 111 g/km",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#step-1-initial-solution",
    "href": "tutorials/nb_08_02_fleet_optimization.html#step-1-initial-solution",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Step 1: Initial Solution",
    "text": "Step 1: Initial Solution\nCreate a fleet composition by your reasoning that:\n\nMeets the EU emission constraint (avg CO2 ≤ 111 g/km)\nHas sufficient capacity (≥ 22,000 parcels/day would be great if achievable)\nBalances cost vs service score according to YOUR strategic priorities\n\n\n# YOUR FLEET COMPOSITION HERE\n\nmy_fleet = {\n    'Electric Truck': 0,      # YOUR CHOICE\n    'Hybrid Van': 0,          # YOUR CHOICE\n    'Diesel Van': 0,          # YOUR CHOICE\n    'E-Cargo Bike': 0,        # YOUR CHOICE\n    'Autonomous Pod': 0       # YOUR CHOICE\n}\n\n# Evaluate your fleet\nmy_metrics = calculate_fleet_metrics(my_fleet)\n\nprint(\"\\nYour Fleet Performance:\")\nprint(f\"  Total Cost: €{my_metrics['total_cost']:,.0f}\")\nprint(f\"  Service Score: {my_metrics['service_score']:.3f}\")\nprint(f\"  Average CO2: {my_metrics['avg_co2']:.1f} g/km\")\nprint(f\"  Total Capacity: {my_metrics['total_capacity']:,} parcels/day\")\nprint(f\"  Total Vehicles: {my_metrics['total_vehicles']}\")\nprint(f\"\\n  EU Compliant: {'✓ YES' if my_metrics['avg_co2'] &lt;= 111 else '✗ NO - INVALID!'}\")\nprint(f\"  Sufficient Capacity: {'✓ YES' if my_metrics['total_capacity'] &gt;= 22000 else '⚠ LOW'}\")",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#step-2-pareto-analysis",
    "href": "tutorials/nb_08_02_fleet_optimization.html#step-2-pareto-analysis",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Step 2: Pareto Analysis",
    "text": "Step 2: Pareto Analysis\nGenerate alternative fleet compositions and find the Pareto frontier.\n\n\n\n\n\n\nTipThree Approaches (Choose at Least One)\n\n\n\nApproach A: Sequential Greedy\n\nPrioritize one objective (e.g., minimize cost first)\nThen optimize the other within acceptable range\n\nApproach B: Weighted Greedy\n\nGenerate solutions with different weight combinations\nExample: 80% cost / 20% service, then 50/50, then 20/80\n\nApproach C: Random + Filter\n\nGenerate 100+ random fleet compositions\nFilter for feasibility (CO2 ≤ 111)\nFind Pareto frontier among feasible solutions\n\n\n\n\n# GENERATE ALTERNATIVES\n# Use one of the three approaches above!\n\nalternatives = []\n\n# Example: Random generation (you should implement your chosen approach)\nfor i in range(100):\n    # Generate random fleet\n    random_fleet = {\n        'Electric Truck': np.random.randint(0, 35),\n        'Hybrid Van': np.random.randint(0, 30),\n        'Diesel Van': np.random.randint(0, 25),\n        'E-Cargo Bike': np.random.randint(0, 40),\n        'Autonomous Pod': np.random.randint(0, 15)\n    }\n    \n    metrics = calculate_fleet_metrics(random_fleet)\n    \n    # Only keep feasible solutions\n    if metrics['avg_co2'] &lt;= 111:  # Hard constraint\n        alternatives.append({\n            'fleet': random_fleet,\n            'cost': metrics['total_cost'],\n            'service': metrics['service_score'],\n            'co2': metrics['avg_co2']\n        })\n\nprint(f\"\\nGenerated {len(alternatives)} feasible fleet alternatives\")\n\n\n# YOUR SOLUTION TO DETERMINE THE PARETO FRONTIER HERE",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#step-3-visualization-recommendation",
    "href": "tutorials/nb_08_02_fleet_optimization.html#step-3-visualization-recommendation",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Step 3: Visualization & Recommendation",
    "text": "Step 3: Visualization & Recommendation\n\n# YOUR SOLUTION HERE",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#step-4-create-your-submission",
    "href": "tutorials/nb_08_02_fleet_optimization.html#step-4-create-your-submission",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Step 4: Create Your Submission",
    "text": "Step 4: Create Your Submission\nPrepare a one-slide presentation (PDF) containing:\n\nYour Best Fleet: Total cost and service score (prominently displayed)\nApproach: Which solution generation method(s) did you use?\nVisualization: Scatter plot showing Pareto frontier with your solution marked\nFleet Composition: Table showing vehicle types and quantities\nStrategy Justification: 2-3 sentences explaining why your fleet is optimal",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#strategy-suggestions",
    "href": "tutorials/nb_08_02_fleet_optimization.html#strategy-suggestions",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Strategy Suggestions",
    "text": "Strategy Suggestions\n\nStart simple: Try random generation + filtering first to understand the solution space\nVisualize early: Plot your alternatives to see if you’re exploring well\nCheck feasibility: Always verify CO2 ≤ 111 before adding to alternatives\nCapacity matters: Don’t sacrifice too much capacity for cost savings\nPareto insight: If your solution isn’t on the frontier, ask why\nBe realistic: Explain trade-offs honestly as there’s likely no perfect solution",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#common-pitfalls-to-avoid",
    "href": "tutorials/nb_08_02_fleet_optimization.html#common-pitfalls-to-avoid",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Common Pitfalls to Avoid",
    "text": "Common Pitfalls to Avoid\n\nForgetting the CO2 constraint: Filter for feasibility BEFORE evaluating\nIgnoring capacity: Low capacity = low service score, even if cheap\nIncorrect dominance check: Must compare BOTH cost AND service score\nPoor visualization: Make sure your chosen solution is clearly visible",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#final-checklist",
    "href": "tutorials/nb_08_02_fleet_optimization.html#final-checklist",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Final Checklist",
    "text": "Final Checklist\nBefore submitting your solution, verify:\n\nFleet meets CO2 constraint (≤ 111 g/km)\nFleet has reasonable capacity (≥ 22,000 parcels/day recommended)\nCorrectly implemented Pareto frontier filtering\nJustification is clear and concise (2-3 sentences)\nOne-slide presentation ready with visualization and metrics",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "tutorials/nb_08_02_fleet_optimization.html#good-luck",
    "href": "tutorials/nb_08_02_fleet_optimization.html#good-luck",
    "title": "Competition 05 - Fleet Optimization Challenge",
    "section": "Good Luck!",
    "text": "Good Luck!",
    "crumbs": [
      "08 Multi Objective",
      "NB-08-02 Competition"
    ]
  },
  {
    "objectID": "assignments/assignment_01.html",
    "href": "assignments/assignment_01.html",
    "title": "Assignment 1: Risk Analysis & Forecasting",
    "section": "",
    "text": "Due: Start of Lecture 8\nWeight: 30% of final grade\nExpected Time: 4-6 hours\nWork: Groups\n\nYou’re a group of junior analysts at a consulting firm. A client needs help with:\n\nUnderstanding investment risk using simulation\nForecasting product demand",
    "crumbs": [
      "Assignments",
      "Assignment 01"
    ]
  },
  {
    "objectID": "assignments/assignment_01.html#assignment-overview",
    "href": "assignments/assignment_01.html#assignment-overview",
    "title": "Assignment 1: Risk Analysis & Forecasting",
    "section": "",
    "text": "Due: Start of Lecture 8\nWeight: 30% of final grade\nExpected Time: 4-6 hours\nWork: Groups\n\nYou’re a group of junior analysts at a consulting firm. A client needs help with:\n\nUnderstanding investment risk using simulation\nForecasting product demand",
    "crumbs": [
      "Assignments",
      "Assignment 01"
    ]
  },
  {
    "objectID": "assignments/assignment_01.html#consultants",
    "href": "assignments/assignment_01.html#consultants",
    "title": "Assignment 1: Risk Analysis & Forecasting",
    "section": "Consultants",
    "text": "Consultants\nWho is part of your group?\n\n\"\"\"\nYOUR ANSWER HERE:\n\"\"\"",
    "crumbs": [
      "Assignments",
      "Assignment 01"
    ]
  },
  {
    "objectID": "assignments/assignment_01.html#setup",
    "href": "assignments/assignment_01.html#setup",
    "title": "Assignment 1: Risk Analysis & Forecasting",
    "section": "Setup",
    "text": "Setup\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Sets a random seed for reproducibility (CHANGE THIS HERE!!!)\ngroup_name = \"[THE NAMES OF YOUR GROUP MEMBERS HERE]\"\n# Convert string to integer for seeding\nseed = hash(group_name) % (2**31)\nnp.random.seed(seed)\n\n\n\n\n\n\n\nFill in the names of all the members of your group in group_name instead of [THE NAMES OF YOUR GROUP MEMBERS HERE]. If you don’t do so, you will maximally receive half of the points.",
    "crumbs": [
      "Assignments",
      "Assignment 01"
    ]
  },
  {
    "objectID": "assignments/assignment_01.html#part-a-investment-risk-simulation-40",
    "href": "assignments/assignment_01.html#part-a-investment-risk-simulation-40",
    "title": "Assignment 1: Risk Analysis & Forecasting",
    "section": "Part A: Investment Risk Simulation (40%)",
    "text": "Part A: Investment Risk Simulation (40%)\n\nScenario\nYour client is considering investing €100,000 in a new product launch. Based on market research, you have initial projections for how this investment might perform.\nInitial projections:\n\nBest case: €180,000 return (20% probability)\nMost likely: €140,000 return (60% probability)\nWorst case: €90,000 return (20% probability)\n\n\n\nTask 1: Simple Monte Carlo Simulation (10%)\nCreate a Monte Carlo simulation with the probabilities above to understand the basic risk profile.\nYour function should:\n\nTake the number of simulations as input\nFor each simulation, randomly select one outcome based on the given probabilities\nReturn an array of all simulated returns\n\n\n\n\n\n\n\nUse np.random.choice() with the p parameter for probabilities.\n\n\n\n\n# Create a function that runs simulations and randomly picks outcomes\n# YOUR CODE HERE\n\n# Run your simulation with at least 1000 simulations\n# YOUR CODE HERE\n\n\n\nTask 2: Comparing Alternative Investment Opportunities (15%)\nAfter presenting your initial analysis, the client mentions they’re also considering two other investment opportunities with the same €100,000 initial investment. They want you to compare all three options.\nThe three investment options are:\nOption A: Original Product Launch (from Task 1)\n\nBest case: €180,000 (20% probability)\nMost likely: €140,000 (60% probability)\nWorst case: €90,000 (20% probability)\n\nOption B: Established Market Expansion\n\nReturns follow a normal distribution with mean €140,000 and standard deviation €20,000\n\nOption C: High-Risk Startup Partnership\n\n50% chance: Double your money (€200,000 return)\n50% chance: Lose everything (€0 return)\n\n\n\n\n\n\n\nThe client can only choose ONE option. Your job is to analyze all three.\n\n\n\nCreate simulations for Options B and C (you already have Option A from Task 1):\n\n\n\n\n\n\nHelpful NumPy functions: - np.random.normal(mean, std, size) for normal distribution - np.random.choice([option1, option2], size, p=[prob1, prob2]) for binary outcomes\n\n\n\n\n# Option A: You already simulated this in Task 1 (use simple_returns)\n\n# Simulate Option B: Normal distribution (mean=140k, std=20k)\n# YOUR CODE HERE\n\n# Simulate Option C: Binary outcome (200k or 0, each 50%)\n# YOUR CODE HERE\n\n\n\nTask 3: Comprehensive Risk Analysis & Recommendation (15%)\nNow analyze and compare all three investment options.\nPart 1: Calculate Risk Metrics\nFor each investment option (A, B, and C), calculate:\n\nExpected Return: Mean of simulated returns\nExpected Profit: Expected return - €100,000 initial investment\nProbability of Loss: Proportion of simulations where return &lt; €100,000\nValue at Risk (95%): 5th percentile (worst case in 95% of scenarios)\nUpside Potential: 95th percentile (best case in 95% of scenarios)\n\n\n# Calculate all metrics for all three investment options\n# YOUR CODE HERE\n\n# Print results clearly showing all metrics for each option\n# YOUR CODE HERE\n\nPart 2: Visualization\nCreate visualizations comparing the three investment options:\n\nThree histograms (or one figure with 3 subplots) showing the distribution of returns\nMark the initial investment (€100,000) on each plot\nClear labels and titles\n\n\n# Create visualization comparing all three distributions\n# YOUR CODE HERE\n\nPart 3: Business Recommendation\nBased on your analysis, write a recommendation memo (4-6 sentences) addressing:\n\nWhich investment option you recommend and why\nWhich option you strongly recommend AGAINST and why\nWhat type of investor would be suitable for each option\nAny important caveats or warnings\n\n\n\"\"\"\nYOUR RECOMMENDATION HERE:\n\nTo: Client\nFrom: [Your Consulting Team]\nRe: Investment Analysis & Recommendation\n\n[Your detailed recommendation here - address all 4 points above]\n\"\"\"",
    "crumbs": [
      "Assignments",
      "Assignment 01"
    ]
  },
  {
    "objectID": "assignments/assignment_01.html#part-b-demand-forecasting-60",
    "href": "assignments/assignment_01.html#part-b-demand-forecasting-60",
    "title": "Assignment 1: Risk Analysis & Forecasting",
    "section": "Part B: Demand Forecasting (60%)",
    "text": "Part B: Demand Forecasting (60%)\n\nScenario\nA retail client is experiencing growth and needs to forecast demand for the next 3 months to plan inventory. They’ve provided 24 months of historical sales data and want your team to recommend the best forecasting approach. The senior partner has asked you to start with standard forecasting methods, evaluate their performance, and then propose an improved approach if needed.\n\n\nThe Data\n\n\n\n\n\n\nUnique Data Per Group: The data generation below uses your group’s seed from the Setup section. This means each group will get slightly different sales patterns (different base levels, growth rates, and seasonality).\n\n\n\n\n# DON'T CHANGE ANYTHING BELOW!\n# Generate 24 months of sales data with trend and slight seasonality\n# Each group will get slightly different data based on their seed above!\n\n# Generate group-specific parameters (slightly different for each group)\nbase_sales = np.random.uniform(95, 105)  # Between 95-105\ntrend = np.random.uniform(2.0, 5.0)      # Between 2.0-5.0 units/month\nseasonal_amplitude = np.random.uniform(6, 24)  # Between 6-24\nnoise_level = np.random.uniform(4, 6)    # Between 4-6\n\n# Generate data\nmonths = np.arange(1, 25)\ntrend_component = base_sales + trend * months\nseasonal_component = seasonal_amplitude * np.sin(2 * np.pi * months / 12)\nnoise = np.random.normal(0, noise_level, len(months))\n\nsales_units = trend_component + seasonal_component + noise\n\n# Create DataFrame\ndf = pd.DataFrame({\n    'month': months,\n    'sales_units': sales_units\n})\n\nprint(\"=\" * 60)\nprint(\"YOUR GROUP'S UNIQUE SALES DATA\")\nprint(\"=\" * 60)\nprint(f\"Base sales level: {base_sales:.1f} units\")\nprint(f\"Monthly growth trend: {trend:.2f} units/month\")\nprint(f\"Seasonal variation: ±{seasonal_amplitude:.1f} units\")\nprint(f\"Random noise level: ±{noise_level:.1f} units\")\nprint(\"\\nFirst 10 months of sales data:\")\nprint(df.head(10))\nprint(f\"\\nTotal months: {len(df)}\")\nprint(f\"Average sales: {df['sales_units'].mean():.1f} units\")\nprint(f\"First month: {df['sales_units'].iloc[0]:.1f} units\")\nprint(f\"Last month: {df['sales_units'].iloc[-1]:.1f} units\")\nprint(f\"Overall growth: {df['sales_units'].iloc[-1] - df['sales_units'].iloc[0]:.1f} units\")\nprint(\"=\" * 60)\n# DON'T CHANGE ANYTHING ABOVE!\n\n============================================================\nYOUR GROUP'S UNIQUE SALES DATA\n============================================================\nBase sales level: 100.6 units\nMonthly growth trend: 4.46 units/month\nSeasonal variation: ±17.5 units\nRandom noise level: ±4.3 units\n\nFirst 10 months of sales data:\n   month  sales_units\n0      1   121.658798\n1      2   122.214132\n2      3   135.523772\n3      4   128.531712\n4      5   126.390707\n5      6   128.355069\n6      7   133.146650\n7      8   120.836526\n8      9   115.003802\n9     10   122.512218\n\nTotal months: 24\nAverage sales: 156.8 units\nFirst month: 121.7 units\nLast month: 208.1 units\nOverall growth: 86.5 units\n============================================================\n\n\n\n\nTask 1: Implement Baseline Forecasting Methods (15%)\nThe client wants to start with two proven forecasting approaches. As junior analysts, your first task is to implement these methods to establish baseline forecasts.\nFirst, visualize the sales data:\n\n# Create a line plot showing all 24 months of sales data\n# Include axis labels, title, and grid for readability\n# YOUR CODE HERE\n\nImplement Moving Average:\nCreate a function that calculates moving average forecasts.\n\n# Implement moving average forecast function\n# YOUR CODE HERE\n\nImplement Exponential Smoothing:\nCreate a function that calculates exponential smoothing forecasts.\n\n# Implement exponential smoothing forecast function\n# YOUR CODE HERE\n\n\n\nTask 2: Test Baseline Methods & Prepare Analysis (15%)\nAfter presenting your implementation to the client, they ask: “Which method should we use, and how accurate will it be?” You need to properly test both methods on recent data before making a recommendation.\nTesting Approach:\n\nSplit data: first 20 months for training, last 4 months (21-24) for testing\nUse rolling forecasts on the test period:\n\nForecast month 21 using months 1-20\nForecast month 22 using months 1-21 (add actual month 21 to training)\nForecast month 23 using months 1-22 (add actual month 22 to training)\nForecast month 24 using months 1-23 (add actual month 23 to training)\n\nCalculate Mean Absolute Error (MAE) for both methods\n\nParameters to use:\n\nMoving Average: window = 3\nExponential Smoothing: alpha = 0.3\n\n\n# Split data: first 20 months for training, last 4 for testing\ntrain_data = df['sales_units'].values[:20].copy()\ntest_data = df['sales_units'].values[20:]\n\nprint(f\"Training on months 1-20, testing on months 21-24\")\nprint(f\"Test data: {test_data}\")\n\n# Generate rolling forecasts for test period (months 21-24)\n# YOUR CODE HERE\n\n# Calculate Mean Absolute Error (MAE) for both methods\n# MAE = average of |actual - forecast|\n# YOUR CODE HERE\n\n# Print MAE comparison\n# YOUR CODE HERE\n\nTraining on months 1-20, testing on months 21-24\nTest data: [174.07187117 183.96153235 194.49526796 208.11966552]\n\n\nCreate visualizations for your client presentation:\n\n# Create TWO plots:\n\n# Plot 1: Full time series with test forecasts\n# YOUR CODE HERE\n\n# Plot 2: Forecast errors for test period\n# YOUR CODE HERE\n\nAnalysis for Internal Team Discussion:\nBefore meeting with the client, your team needs to align on what the testing reveals. Prepare answers to these questions:\n(a) Performance Summary: Which method has lower MAE on the test period? (1-2 sentences)\n\n\"\"\"\nYOUR ANSWER:\n\"\"\"\n\n'\\nYOUR ANSWER:\\n'\n\n\n(b) Error Pattern Analysis: Looking at your error plot, are the errors randomly scattered around zero, or is there a systematic bias? Are both methods consistently over-forecasting (predicting too high) or under-forecasting (predicting too low)? (2-3 sentences)\n\n\"\"\"\nYOUR ANSWER:\n\"\"\"\n\n'\\nYOUR ANSWER:\\n'\n\n\n(c) Data Pattern Identification: Looking at the full 24-month sales history, what patterns or characteristics do you observe? Consider whether the data appears flat, trending upward/downward, seasonal, or purely random. (2-3 sentences)\n\n\"\"\"\nYOUR ANSWER:\n\"\"\"\n\n'\\nYOUR ANSWER:\\n'\n\n\n\n\nTask 3: Propose & Implement Improved Forecast (20%)\nAfter reviewing your analysis, the senior partner calls your team into a meeting: “Good work on the baseline analysis. But I’m concerned we’re not giving the client the best possible forecast. I need you to come back with something better for months 21-24. Use whatever method you think will work—just make sure you can explain why it’s an improvement and prove it with the numbers.”\nYour task is to develop, implement, and validate an improved forecasting approach.\nYour Deliverables:\nPart 1: Proposed Method & Justification\nBased on your analysis in Task 2, propose a forecasting method that addresses the limitations you identified.\n\n\"\"\"\nMEMO: Proposed Forecasting Approach\n\nTo: Senior Partner\nFrom: [Your Team]\nRe: Improved Forecasting Method for Client\n\nMethod Proposed: [Name your method]\n\nWhy This Method: [3-4 sentences explaining why this method should perform better\nthan Moving Average and Exponential Smoothing for this specific data. Reference\nthe patterns and limitations you identified in Task 2.]\n\nImplementation Approach: [2-3 sentences describing how you'll implement this -\nwill you build it from scratch, use a Python library, or combine approaches?]\n\"\"\"\n\nPart 2: Implementation\nImplement your proposed method. You may:\n\nBuild the method from scratch using NumPy/Pandas\nUse external forecasting libraries (statsmodels, scikit-learn, etc.)\nCombine multiple approaches\n\n\n# Implement your improved forecasting method here\n# Include comments explaining key steps\n# YOUR CODE HERE\n\nPart 3: Testing & Validation\nTest your method on the same test period (months 21-24) using rolling forecasts, just like Task 2.\n\n# Generate rolling forecasts for months 21-24 with your improved method\n# YOUR CODE HERE\n\n# Calculate MAE for your method\n# YOUR CODE HERE\n\n# Print comparison of all three methods\n# YOUR CODE HERE\n\n\n\nTask 4: Client Presentation (10%)\nPart 1: Visualization & Comparison\nCreate a visualization comparing all three methods.\n\n# Create a plot showing:\n# - All 24 months of actual sales\n# - Vertical line marking train/test split at month 20\n# - Test forecasts (months 21-24) from all THREE methods\n# - Clear legend, labels, and title\n# YOUR CODE HERE\n\nPart 2: Client Recommendation\nWrite your final recommendation to the client for forecasting months 25, 26, and 27.\n\n\"\"\"\nFINAL RECOMMENDATION TO CLIENT\n\nTo: Retail Client\nFrom: [Your Team]\nRe: Recommended Forecasting Approach for Inventory Planning\n\nRecommended Method: [Which method?]\n\nPerformance Summary: [2-3 sentences comparing the MAE results and explaining\nwhy your method performed better or worse than expected]\n\nWhy We Recommend This Approach: [3-4 sentences explaining why this method is\nmost appropriate for their business needs going forward. Consider accuracy,\nsimplicity, reliability, and any limitations they should be aware of.]\n\nNext Steps: [1-2 sentences on what the client should do - e.g., use this\nmethod for months 25-27, monitor performance, collect more data, etc.]\n\"\"\"",
    "crumbs": [
      "Assignments",
      "Assignment 01"
    ]
  },
  {
    "objectID": "assignments/assignment_01.html#submission-checklist",
    "href": "assignments/assignment_01.html#submission-checklist",
    "title": "Assignment 1: Risk Analysis & Forecasting",
    "section": "Submission Checklist",
    "text": "Submission Checklist\nBefore submitting, verify:\n\nAll code cells run without errors\nGroup member names filled in at top\nAll visualizations have clear labels, titles, and legends\nFunctions include comments explaining logic",
    "crumbs": [
      "Assignments",
      "Assignment 01"
    ]
  },
  {
    "objectID": "assignments/assignment_01.html#tips",
    "href": "assignments/assignment_01.html#tips",
    "title": "Assignment 1: Risk Analysis & Forecasting",
    "section": "Tips",
    "text": "Tips\n\nUse AI tools to help understand concepts and program, but make sure you understand the code\nStart simple and get something working before optimizing\nRemember: the goal is good solutions, not perfect ones",
    "crumbs": [
      "Assignments",
      "Assignment 01"
    ]
  }
]