---
title: "Assignment 1: Risk Analysis & Forecasting"
subtitle: "Management Science"
format: ipynb
code-links:
  - text: Python
    href: assignment_01.py
    icon: hand-thumbs-up
---

## Assignment Overview

**Due:** Start of Lecture 8
**Weight:** 30% of final grade
**Expected Time:** 4-6 hours
**Work:** Groups

You're a group of junior analysts at a consulting firm. A client needs help with:

1. Understanding investment risk using simulation
2. Forecasting product demand

## Consultants
Who is part of your group?

```{python}
"""
YOUR ANSWER HERE:
"""
```

## Setup

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Sets a random seed for reproducibility (CHANGE THIS HERE!!!)
group_name = "[THE NAMES OF YOUR GROUP MEMBERS HERE]"
# Convert string to integer for seeding
seed = hash(group_name) % (2**31)
np.random.seed(seed)
```

::: callout-warning
Fill in the names of all the members of your group in `group_name` instead of `[THE NAMES OF YOUR GROUP MEMBERS HERE]`. If you don't do so, you will maximally receive half of the points.
:::

## Part A: Investment Risk Simulation (50%)

### Scenario

Your client is considering investing €100,000 in a new product launch. Based on market research, you have initial projections for how this investment might perform.

**Initial projections:**
- Best case: €180,000 return (20% probability)
- Most likely: €140,000 return (60% probability)
- Worst case: €90,000 return (20% probability)

### Task 1: Simple Monte Carlo Simulation (15%)

Create a Monte Carlo simulation with the probabilities above to understand the basic risk profile.

**Your function should:**
1. Take the number of simulations as input
2. For each simulation, randomly select one outcome based on the given probabilities
3. Return an array of all simulated returns

::: callout-tip
Use `np.random.choice()` with the `p` parameter for probabilities.
:::

```{python}
# Create a function that runs simulations and randomly picks outcomes
# YOUR CODE HERE

# Run your simulation with at least 1000 simulations
# YOUR CODE HERE

```

### Task 2: Comparing Alternative Investment Opportunities (20%)

After presenting your initial analysis, the client mentions they're also considering **two other investment opportunities** with the same €100,000 initial investment. They want you to compare all three options.

**The three investment options are:**

**Option A: Original Product Launch (from Task 1)**

- Best case: €180,000 (20% probability)
- Most likely: €140,000 (60% probability)
- Worst case: €90,000 (20% probability)

**Option B: Established Market Expansion**

- Returns follow a **normal distribution** with mean €140,000 and standard deviation €20,000

**Option C: High-Risk Startup Partnership**

- **50% chance**: Double your money (€200,000 return)
- **50% chance**: Lose everything (€0 return)

::: callout-note
The client can only choose ONE option. Your job is to analyze all three.
:::

Create simulations for Options B and C (you already have Option A from Task 1):

::: callout-tip
**Helpful NumPy functions:**
- `np.random.normal(mean, std, size)` for normal distribution
- `np.random.choice([option1, option2], size, p=[prob1, prob2])` for binary outcomes
:::

```{python}
# Option A: You already simulated this in Task 1 (use simple_returns)

# Simulate Option B: Normal distribution (mean=140k, std=20k)
# YOUR CODE HERE

# Simulate Option C: Binary outcome (200k or 0, each 50%)
# YOUR CODE HERE

```

### Task 3: Comprehensive Risk Analysis & Recommendation (15%)

Now analyze and compare all three investment options.

**Part 1: Calculate Risk Metrics**

For each investment option (A, B, and C), calculate:

1. **Expected Return**: Mean of simulated returns
2. **Expected Profit**: Expected return - €100,000 initial investment
3. **Probability of Loss**: Proportion of simulations where return < €100,000
4. **Value at Risk (95%)**: 5th percentile (worst case in 95% of scenarios)
5. **Upside Potential**: 95th percentile (best case in 95% of scenarios)

```{python}
# Calculate all metrics for all three investment options
# YOUR CODE HERE

# Print results clearly showing all metrics for each option
# YOUR CODE HERE

```

**Part 2: Visualization**

Create visualizations comparing the three investment options:

- Three histograms (or one figure with 3 subplots) showing the distribution of returns
- Mark the initial investment (€100,000) on each plot
- Clear labels and titles

```{python}
# Create visualization comparing all three distributions
# YOUR CODE HERE

```

**Part 3: Business Recommendation**

Based on your analysis, write a recommendation memo (4-6 sentences) addressing:

1. Which investment option you recommend and why
2. Which option you **strongly recommend AGAINST** and why
3. What type of investor would be suitable for each option
4. Any important caveats or warnings


```{python}
"""
YOUR RECOMMENDATION HERE:

To: Client
From: [Your Consulting Team]
Re: Investment Analysis & Recommendation

[Your detailed recommendation here - address all 4 points above]
"""
```

## Part B: Demand Forecasting (50%)

### Scenario

A retail client is experiencing growth and needs to forecast demand for the next 3 months to plan inventory. They've noticed sales have been generally increasing over the past 2 years, with some minor fluctuations.

### The Data

::: callout-note
**Unique Data Per Group**: The data generation below uses your group's seed from the Setup section. This means each group will get slightly different sales patterns (different base levels, growth rates, and seasonality).
:::

```{python}
# DON'T CHANGE ANYTHING BELOW!
# Generate 24 months of sales data with trend and slight seasonality
# Each group will get slightly different data based on their seed above!

# Generate group-specific parameters (slightly different for each group)
base_sales = np.random.uniform(95, 105)  # Between 95-105
trend = np.random.uniform(2.0, 3.0)      # Between 2.0-3.0 units/month
seasonal_amplitude = np.random.uniform(6, 10)  # Between 6-10
noise_level = np.random.uniform(4, 6)    # Between 4-6

# Generate data
months = np.arange(1, 25)
trend_component = base_sales + trend * months
seasonal_component = seasonal_amplitude * np.sin(2 * np.pi * months / 12)
noise = np.random.normal(0, noise_level, len(months))

sales_units = trend_component + seasonal_component + noise

# Create DataFrame
df = pd.DataFrame({
    'month': months,
    'sales_units': sales_units
})

print("=" * 60)
print("YOUR GROUP'S UNIQUE SALES DATA")
print("=" * 60)
print(f"Base sales level: {base_sales:.1f} units")
print(f"Monthly growth trend: {trend:.2f} units/month")
print(f"Seasonal variation: ±{seasonal_amplitude:.1f} units")
print(f"Random noise level: ±{noise_level:.1f} units")
print("\nFirst 10 months of sales data:")
print(df.head(10))
print(f"\nTotal months: {len(df)}")
print(f"Average sales: {df['sales_units'].mean():.1f} units")
print(f"First month: {df['sales_units'].iloc[0]:.1f} units")
print(f"Last month: {df['sales_units'].iloc[-1]:.1f} units")
print(f"Overall growth: {df['sales_units'].iloc[-1] - df['sales_units'].iloc[0]:.1f} units")
print("=" * 60)
# DON'T CHANGE ANYTHING ABOVE!
```

### Task 1: Moving Average Forecast (15%)

First, visualize the sales data to understand what you're working with:

```{python}
# This will help you see the pattern in the data
# YOUR CODE HERE

```

Now implement the moving average forecast:

**What the function should do:**

- Take historical sales data and a window size as inputs
- Calculate the average of the last N periods (where N = window size)
- Return the forecast for the next period

```{python}
# Implement a moving average forecast function
# YOUR CODE HERE

# Test different window sizes: 3, 6, and 12 months
# For each, calculate and print the forecast for month 25
# Use the full 24 months of data
# YOUR CODE HERE

```

### Task 2: Exponential Smoothing (15%)

You and the client both think that a simple moving average forecast might not be sufficient and you are thus tasked to test exponential smoothing, which gives more weight to recent observations while still considering historical data.

The formula is:

$$F_t = α \times A_{t-1} + (1 - α) \times F_{t-1}$$

Where:

- $F_t$ = Forecast for period $t$
- $A_{t-1}$ = Actual value in previous period
- $F_{t-1}$ = Forecast for previous period
- $α$ = Smoothing parameter between 0 and 1

**How it works:**

- Start with the first actual value as your initial forecast: $F_1 = A_1$
- For each subsequent period, update the forecast using the formula above
- Higher α (e.g., 0.7) = more weight on recent data (responsive to changes)
- Lower α (e.g., 0.1) = more weight on historical pattern (smooth, stable)

**Example with α = 0.3:**

- Month 1: Actual = 120, Forecast = 120 (initial)
- Month 2: Actual = 135, Forecast = 0.3 × 120 + 0.7 × 120 = 120
- Month 3: Actual = 155, Forecast = 0.3 × 135 + 0.7 × 120 = 124.5
- And so on...

```{python}
# Implement exponential smoothing function
# YOUR CODE HERE

# Test different alpha values: 0.1 (smooth), 0.3 (balanced), 0.7 (responsive)
# For each, calculate and print the forecast for month 25
# Use the full 24 months of data
# YOUR CODE HERE

```

### Task 3: Evaluate and Compare Methods (20%)

Now compare the two forecasting methods using a proper train/test split.

**Approach:**

- Use first 20 months for initial training
- Forecast months 21-24 one at a time
- After each forecast, **add the actual value to your training data** before forecasting the next month!
- Calculate forecast accuracy using Mean Absolute Error (MAE)

::: callout-tip
This is called "rolling forecast".
:::

**For this task, use:**

- Moving Average with window=3
- Exponential Smoothing with alpha=0.3

```{python}
# Split data: first 20 months for training, last 4 for testing
train_data = df['sales_units'].values[:20].copy()
test_data = df['sales_units'].values[20:]

print(f"Training on months 1-20, testing on months 21-24")
print(f"Test data: {test_data}")

# Generate rolling forecasts for test period (months 21-24)
ma_forecasts = []
es_forecasts = []

# For each test month (4 iterations):
# 1. Use current training data to generate forecast
# 2. Store the forecast
# 3. Add the actual value to training data for next iteration
# YOUR CODE HERE

# Calculate Mean Absolute Error (MAE) for both methods
# MAE = average of |actual - forecast|
# YOUR CODE HERE

# Print results
# YOUR CODE HERE

```

```{python}
# Visualization: Plot actual sales with forecasts
# Create a plot showing:
# 1. All 24 months of actual sales
# 2. Forecasts for months 21-24 from both methods
# 3. Legend identifying each line
# YOUR CODE HERE

```

**Business Question 1:** Which forecasting method performed better based on MAE? (2-3 sentences)

```{python}
"""
YOUR ANSWER HERE:
"""
```

**Business Question 2:**

The client's inventory manager says: *"Great analysis! Let's use your recommended method to order inventory for the next 6 months."*

Before approving this plan, you review your visualization showing months 1-24. You notice something concerning about the data pattern.

Write a brief warning to the client (4-5 sentences) explaining why they should NOT rely solely on these methods for their 6-month planning horizon, despite the good MAE performance on months 21-24.

```{python}
"""
YOUR CONSULTANT WARNING:

To: Inventory Manager
From: [Your Team]
Re: CAUTION - Limitations of Current Forecasting Approach

[Your warning here - explain the pattern, the limitation, the risk, and what to do instead]
"""
```

## Submission Checklist

- [ ] All code cells run without errors
- [ ] Functions are commented
- [ ] Visualizations are clear and labeled
- [ ] Business questions are answered
- [ ] Names added to top of notebook

## Tips

- Use AI tools to help understand concepts and program, but make sure you understand the code
- Start simple and get something working before optimizing
- Remember: the goal is good solutions, not perfect ones
