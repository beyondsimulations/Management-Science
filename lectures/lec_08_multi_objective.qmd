---
title: "Multi-Objective Optimization"
subtitle: "Lecture 8 - Management Science"
author: "Dr. Tobias Vlćek"
format:
  revealjs:
    footer: " {{< meta title >}} | {{< meta author >}} | [Home](lec_08_multi_objective.qmd)"
    output-file: lec_08_presentation.html
---

# [Introduction]{.flow} {.title}

## **[Client Briefing: EcoExpress Logistics]{.invert-font}** {background-image="https://unsplash.com/photos/QqSIuvz94s8/download?ixid=M3wxMjA3fDB8MXxzZWFyY2h8MTF8fHN1c3RhaW5hYmlsaXR5fGVufDB8fHx8MTc2MzE4Nzk0MHww&force=true&w=2400" background-size="cover"}

. . .

[Operations Director's Dilemma:]{.invert-font}

["EU regulations demand 40% emission cuts, but we can't sacrifice [profitability]{.highlight}, [service quality]{.highlight}, or [reliability]{.highlight}!"]{.invert-font .fragment}

## The Fleet Challenge

[EcoExpress operates regional last-mile delivery across 3 cities]{.highlight}

::: incremental
- EU Green Deal: 40% emission reduction by 2025
- Rising fuel costs (€2.1/L diesel)
- Amazon entering our market (speed pressure)
- Driver shortage (need automation-friendly vehicles)
:::

. . .

[Question:]{.question} How do we transform our fleet while staying competitive?

## Today's Learning Objectives

[By the end of this lecture, you will be able to:]{.highlight}

::: {.incremental}
1. Explain why most decisions involve competing objectives
2. Identify and visualize Pareto optimal solutions
3. Apply normalization techniques to make objectives comparable
4. Implement apporaches to find trade-off solutions
5. Make decisions from a Pareto frontier
:::

## Quick Recap: Local Search

[Last week we optimized routes for delivery:]{.highlight}

::: {.incremental}
- Started with greedy construction (e.g. Nearest Neighbor)
- Improved with local search (e.g. 2-opt)
- Considered time windows
- **But: We only optimized distance**
:::

. . .

[Question:]{.question} What if we also care about emissions, cost, AND customer satisfaction?

# [The Problem]{.flow} {.title}

## Single vs Multi-Objective

**Single Objective**

- ["Minimize total distance"]{.highlight}
- Clear winner. Easy, right!

. . .

**Multiple Objectives**

- ["Minimize cost AND emissions AND maximize speed"]{.highlight}
- No clear answer...

. . .

[Question:]{.question} Any idea how to approach this?

## EcoExpress Vehicle Options {.smaller}

```{python}
#| echo: false
#| eval: true

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append('../helpers')
from plot_utils import setup_clean_style, BRAND_COLORS, PLOT_COLORS

# Apply consistent brand styling
setup_clean_style()

vehicles = pd.DataFrame({
    'Type': ['E-Truck', 'Hybrid', 'Diesel', 'E-Bike', 'Auto'],
    'Purchase Cost (€)': [75000, 45000, 35000, 12000, 95000],
    'Operating (€/km)': [0.18, 0.25, 0.38, 0.05, 0.12],
    'CO2 (g/km)': [0, 95, 185, 0, 0],
    'Speed (km/h)': [55, 65, 70, 30, 40],
    'Capacity (parcels)': [300, 200, 250, 50, 150],
    'Reliability': [0.93, 0.95, 0.88, 0.98, 0.94]
})

# Display as nice table
from IPython.display import display, HTML
display(HTML(vehicles.to_html(index=False, classes='table table-striped')))
```
. . .

[Question:]{.question} Which vehicle is "best" for EcoExpress?

## Trade-offs Everywhere

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3)

# Cost vs Emissions
axes[0].scatter(vehicles['Purchase Cost (€)']/1000, 
                vehicles['CO2 (g/km)'], 
                s=vehicles['Capacity (parcels)'],
                alpha=0.7, color=PLOT_COLORS[0])
for i, txt in enumerate(vehicles['Type']):
    axes[0].annotate(txt, (vehicles['Purchase Cost (€)'].iloc[i]/1000, 
                           vehicles['CO2 (g/km)'].iloc[i]),
                    fontsize=9)
axes[0].set_xlabel('Purchase Cost (k€)')
axes[0].set_ylabel('CO2 Emissions (g/km)')
axes[0].set_title('Cost vs Environmental Impact')

# Speed vs Cost
axes[1].scatter(vehicles['Speed (km/h)'], 
                vehicles['Operating (€/km)'],
                s=vehicles['Capacity (parcels)'],
                alpha=0.7, color=PLOT_COLORS[1])
for i, txt in enumerate(vehicles['Type']):
    axes[1].annotate(txt, (vehicles['Speed (km/h)'].iloc[i], 
                           vehicles['Operating (€/km)'].iloc[i]),
                    fontsize=9)
axes[1].set_xlabel('Speed (km/h)')
axes[1].set_ylabel('Operating (€/km)')
axes[1].set_title('Speed vs Operating Cost')

# Capacity vs Reliability
axes[2].scatter(vehicles['Capacity (parcels)'], 
                vehicles['Reliability'],
                s=vehicles['Purchase Cost (€)']/300,
                alpha=0.7, color=PLOT_COLORS[2])
for i, txt in enumerate(vehicles['Type']):
    axes[2].annotate(txt, (vehicles['Capacity (parcels)'].iloc[i], 
                           vehicles['Reliability'].iloc[i]),
                    fontsize=9)
axes[2].set_xlabel('Capacity (parcels)')
axes[2].set_ylabel('Reliability')
axes[2].set_title('Capacity vs Reliability')

plt.tight_layout()
plt.show()
```

. . .

::: callout-important
Every vehicle excels at something different!
:::

## Real Business Constraints

[Beyond the numbers, consider:]{.highlight}

::: {.incremental}
- **EU regulations:** Carbon tax of €100/ton CO₂ starting 2025
- **Competition:** Amazon promises 2-hour delivery
- **Labor market:** Autonomous vehicles reduce driver dependency
- **Urban zones:** Zero-emission zones in city centers
- **Peak times:** Black Friday = 3x normal volume
:::

. . .

::: {.callout-important}
There is no single "optimal" solution - only trade-offs
:::

# [Pareto Optimality]{.flow} {.title}

## Dominated Solutions

[A solution is dominated if another solution is:]{.highlight} 

```{python}
#| echo: false
#| eval: true

# Create example data
np.random.seed(42)
n_solutions = 30
cost = np.random.uniform(20, 100, n_solutions)
emissions = 150 - cost + np.random.normal(0, 15, n_solutions)

# Identify Pareto front
pareto_mask = np.ones(n_solutions, dtype=bool)
for i in range(n_solutions):
    for j in range(n_solutions):
        if i != j:
            if cost[j] <= cost[i] and emissions[j] <= emissions[i]:
                if cost[j] < cost[i] or emissions[j] < emissions[i]:
                    pareto_mask[i] = False
                    break

fig, ax = plt.subplots()

# Plot dominated solutions
ax.scatter(cost[~pareto_mask], emissions[~pareto_mask], 
          alpha=0.3, s=100, color=BRAND_COLORS["darker"], label='Dominated')

# Plot Pareto optimal solutions
ax.scatter(cost[pareto_mask], emissions[pareto_mask], 
          alpha=0.8, s=100, color=PLOT_COLORS[1], label='Pareto Optimal')

# Sort Pareto points and draw frontier
pareto_cost = cost[pareto_mask]
pareto_emissions = emissions[pareto_mask]
sorted_idx = np.argsort(pareto_cost)
ax.plot(pareto_cost[sorted_idx], pareto_emissions[sorted_idx], 
        '--', color=PLOT_COLORS[1], alpha=0.5, linewidth=2)

# Highlight one dominated solution
example_idx = np.where(~pareto_mask)[0][5]
ax.scatter(cost[example_idx], emissions[example_idx], 
          s=200, color='red', marker='x', linewidth=3)
ax.annotate('Dominated\n(worse in both)', 
           (cost[example_idx], emissions[example_idx]),
           xytext=(cost[example_idx]+10, emissions[example_idx]+5),
           fontsize=10, ha='center',
           arrowprops=dict(arrowstyle='->', color='red'))

ax.set_xlabel('Cost (€)', fontsize=12)
ax.set_ylabel('CO2 Emissions (g/km)', fontsize=12)
ax.set_title('Pareto Frontier: Non-Dominated Solutions', fontsize=14)
ax.legend()
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

. . .

:::callout-important
Better in at least one objective and not worse in any objective!
:::

## The Pareto Frontier

[The Pareto frontier is the set of all non-dominated solutions]{.highlight}

::: {.incremental}
- No solution is objectively "better"
- Each represents a different trade-off
- Moving along frontier: gain in one objective, loss in another
- Decision makers choose based on **preferences**
:::

. . .

[Question]{.question} Do you think you get the idea?

## Find the Non-Dominated

```{python}
#| echo: false
#| eval: true

# Simple example for interaction - designed to have clear dominance
solutions = pd.DataFrame({
    'Fleet': ['A', 'B', 'C', 'D', 'E'],
    'Cost (k€)': [100, 120, 90, 105, 95],
    'Emissions (tons/year)': [50, 30, 40, 55, 60]
})

# Determine which are dominated
dominated = []
for i in range(len(solutions)):
    for j in range(len(solutions)):
        if i != j:
            # Check if j dominates i
            if (solutions.iloc[j]['Cost (k€)'] <= solutions.iloc[i]['Cost (k€)'] and
                solutions.iloc[j]['Emissions (tons/year)'] <= solutions.iloc[i]['Emissions (tons/year)'] and
                (solutions.iloc[j]['Cost (k€)'] < solutions.iloc[i]['Cost (k€)'] or
                 solutions.iloc[j]['Emissions (tons/year)'] < solutions.iloc[i]['Emissions (tons/year)'])):
                dominated.append(i)
                break

# Color code based on dominance
fig, ax = plt.subplots()
for i, row in solutions.iterrows():
    color = BRAND_COLORS["darker"] if i in dominated else PLOT_COLORS[1]
    alpha = 0.4 if i in dominated else 0.8
    ax.scatter(row['Cost (k€)'], row['Emissions (tons/year)'], 
              s=500, alpha=alpha, color=color, linewidth=2)
    ax.annotate(row['Fleet'], 
               (row['Cost (k€)'], row['Emissions (tons/year)']),
               fontsize=14, ha='center', va='center', fontweight='bold')

ax.set_xlabel('Cost (k€)', fontsize=12)
ax.set_ylabel('Emissions (tons/year)', fontsize=12)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Which fleets are non-dominated?

## Three+ Objectives

[With 3 objectives, the Pareto frontier becomes a surface:]{.highlight}

```{python}
#| echo: false
#| eval: true

from mpl_toolkits.mplot3d import Axes3D

# Generate 3D Pareto example
np.random.seed(123)
n = 100
cost_3d = np.random.uniform(50, 150, n)
emissions_3d = 200 - cost_3d + np.random.normal(0, 20, n)
speed_3d = cost_3d/2 + np.random.normal(0, 10, n)

# Simple Pareto identification (approximate)
pareto_3d = []
for i in range(n):
    dominated = False
    for j in range(n):
        if i != j:
            if (cost_3d[j] <= cost_3d[i] and 
                emissions_3d[j] <= emissions_3d[i] and 
                speed_3d[j] >= speed_3d[i]):
                if (cost_3d[j] < cost_3d[i] or 
                    emissions_3d[j] < emissions_3d[i] or 
                    speed_3d[j] > speed_3d[i]):
                    dominated = True
                    break
    if not dominated:
        pareto_3d.append(i)

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

# Plot all solutions
ax.scatter(cost_3d, emissions_3d, speed_3d, 
          alpha=0.2, s=30, color=BRAND_COLORS["darker"])

# Highlight Pareto solutions
ax.scatter(cost_3d[pareto_3d], emissions_3d[pareto_3d], speed_3d[pareto_3d], 
          alpha=0.8, s=60, color=PLOT_COLORS[1], edgecolors=PLOT_COLORS[1])

ax.set_xlabel('Cost (€)', fontsize=10, labelpad=15)
ax.set_ylabel('Emissions (g/km)', fontsize=10, labelpad=15)
ax.set_zlabel('Speed (km/h)', fontsize=10, labelpad=15)
ax.set_title('3D Pareto Frontier (Surface)', fontsize=14, fontweight='bold', pad=20)
ax.view_init(elev=20, azim=45)

# Fix the cutoff issue
plt.subplots_adjust(left=0, right=1, bottom=0, top=1)
plt.tight_layout()
plt.show()
```

. . .

::: callout-important
Harder to visualize, but same principle applies!
:::

# [Fleet Composition Problem]{.flow} {.title}

## The Fleet Challenge

[EcoExpress needs to replace their 80 diesel vans]{.highlight}

::: incremental
- Must meet **EU regulation**: Average emissions ≤ 111 g CO₂/km
- Need capacity for **22,000 parcels/day**
- Must balance **cost vs. service quality**
- 5 vehicle types available, each with trade-offs
:::

. . .

[Question:]{.question} How do we choose the right mix?

## Vehicle Options Recap {.smaller}

```{python}
#| echo: false
#| eval: true

# Display the vehicle specifications again for reference
display(HTML(vehicles.to_html(index=False, classes='table table-striped')))
```

. . .

[Notice: No single vehicle is "best" at everything!]{.highlight}

## Fleet Composition Framework

[This is a discrete selection problem, not continuous allocation]{.highlight}

**Decision Variables:**

::: incremental
- Fleet: How many of each vehicle type? (discrete/integer)
- $n_i$ = number of vehicles of type $i$ (integers!)
- Example: $n_{\text{E-Truck}} = 20$, $n_{\text{Hybrid}} = 30$, etc.
:::

## Objective 1: Total Cost

[Purchase cost + Operating cost over 3 years]{.highlight}

$$\text{Total Cost} = \sum_{i} n_i \cdot \left( P_i + O_i \cdot d \cdot y \right)$$

- $n_i$ = quantity of vehicle type $i$
- $P_i$ = purchase cost of vehicle type $i$
- $O_i$ = operating cost per km for type $i$
- $d$ = daily distance × days per year
- $y$ = years

## Objective 2: Service Score

[Composite measure of fleet performance]{.highlight}

$$\text{Service Score} = 0.5 \cdot C_{\text{score}} + 0.3 \cdot R_{\text{score}} + 0.2 \cdot S_{\text{score}}$$

- $C_{\text{score}} = \min\left(1.0, \frac{\text{Total Capacity}}{22000}\right)$ (capacity adequacy)
- $R_{\text{score}} = \frac{\sum n_i \cdot r_i}{\sum n_i}$ (weighted avg. reliability)
- $S_{\text{score}} = \frac{\sum n_i \cdot s_i}{70 \cdot \sum n_i}$ (normalized speed)

. . .

::: callout-note
Service score captures multiple performance dimensions in one metric!
:::

## Hard Constraint: Emissions

[EU regulation creates a feasibility boundary]{.highlight}

$$\text{Average CO}_2 = \frac{\sum_{i} n_i \cdot e_i}{\sum_{i} n_i} \leq 111 \text{ g/km}$$

Where $e_i$ = CO₂ emissions per km for vehicle type $i$

. . .

**This eliminates some solutions:**

::: incremental
- All diesel vans: 185 g/km > 111
- Mix with too many diesel: Still violates
- Zero-emission + some diesel: Might work
:::

## Data Source

[Where Do These Numbers Come From?]{.highlight}

. . .

**Vehicle Specifications:**

::: incremental
- **Purchase costs**: Manufacturer quotes, market research
- **Operating costs**: Fuel/electricity prices, maintenance records
- **Capacity**: Vehicle specs (cargo volume, weight limits)
- **Reliability**: Historical uptime data, manufacturer warranties
- **EU Standards**: WLTP certification for vehicles
- **Electric vehicles**: Grid carbon intensity (kWh → g CO₂)
:::

## Example Fleet Comparison

```{python}
#| echo: false
#| eval: true

# Define three contrasting fleet strategies
DAILY_DISTANCE = 1200
OPERATING_DAYS = 360
YEARS = 3

def evaluate_fleet(fleet_dict, name):
    """Calculate metrics for a fleet composition"""
    total_purchase = 0
    total_operating = 0
    total_capacity = 0
    weighted_co2 = 0
    weighted_reliability = 0
    weighted_speed = 0
    total_vehicles = sum(fleet_dict.values())
    
    # Use the vehicles DataFrame directly
    vehicle_map = {}
    for _, row in vehicles.iterrows():
        vehicle_map[row['Type']] = {
            'purchase': row['Purchase Cost (€)'],
            'op': row['Operating (€/km)'],
            'co2': row['CO2 (g/km)'],
            'cap': row['Capacity (parcels)'],
            'rel': row['Reliability'],
            'speed': row['Speed (km/h)']
        }
    
    for vtype, qty in fleet_dict.items():
        v = vehicle_map[vtype]
        total_purchase += v['purchase'] * qty
        total_operating += v['op'] * DAILY_DISTANCE * OPERATING_DAYS * YEARS * qty
        total_capacity += v['cap'] * qty
        weighted_co2 += v['co2'] * qty
        weighted_reliability += v['rel'] * qty
        weighted_speed += v['speed'] * qty
    
    avg_co2 = weighted_co2 / total_vehicles if total_vehicles > 0 else 999
    avg_reliability = weighted_reliability / total_vehicles if total_vehicles > 0 else 0
    avg_speed = weighted_speed / total_vehicles if total_vehicles > 0 else 0
    
    total_cost = total_purchase + total_operating
    
    capacity_score = min(1.0, total_capacity / 22000)
    reliability_score = avg_reliability
    speed_score = avg_speed / 70
    service_score = 0.5 * capacity_score + 0.3 * reliability_score + 0.2 * speed_score
    
    return {
        'name': name,
        'cost': total_cost / 1e6,  # in millions
        'service': service_score,
        'co2': avg_co2,
        'capacity': total_capacity,
        'vehicles': total_vehicles
    }

# Three strategic fleet compositions
fleet_cheap = {'E-Truck': 0, 'Hybrid': 50, 'Diesel': 20, 'E-Bike': 0, 'Auto': 0}
fleet_balanced = {'E-Truck': 20, 'Hybrid': 25, 'Diesel': 0, 'E-Bike': 15, 'Auto': 10}
fleet_green = {'E-Truck': 30, 'Hybrid': 0, 'Diesel': 0, 'E-Bike': 30, 'Auto': 15}

results = [
    evaluate_fleet(fleet_cheap, 'Cost-Focused'),
    evaluate_fleet(fleet_balanced, 'Balanced'),
    evaluate_fleet(fleet_green, 'Green-Focused')
]

results_df = pd.DataFrame(results)
print("Three Fleet Strategies:\n")
print(results_df.to_string(index=False))
print("\n")

# Check feasibility
for r in results:
    compliance = "✓ Compliant" if r['co2'] <= 111 else "✗ VIOLATES"
    print(f"{r['name']}: {compliance} (CO2: {r['co2']:.1f} g/km)")
```

. . .

[Question:]{.question} Which strategy would you choose?

## Visualizing Fleet Trade-offs

```{python}
#| echo: false
#| eval: true

# Generate diverse fleet compositions
np.random.seed(42)
fleet_solutions = []

# Systematic exploration with different strategies
for _ in range(100):
    # Random fleet composition
    fleet = {
        'E-Truck': np.random.randint(0, 40),
        'Hybrid': np.random.randint(0, 50),
        'Diesel': np.random.randint(0, 30),
        'E-Bike': np.random.randint(0, 40),
        'Auto': np.random.randint(0, 20)
    }
    
    result = evaluate_fleet(fleet, 'Random')
    
    # Only keep feasible solutions (CO2 constraint)
    if result['co2'] <= 111 and result['vehicles'] >= 50 and result['vehicles'] <= 100:
        fleet_solutions.append(result)

fleet_df = pd.DataFrame(fleet_solutions)

# Plot cost vs service score
fig, ax = plt.subplots()

# Color by CO2 emissions
scatter = ax.scatter(fleet_df['cost'], fleet_df['service'], 
                     c=fleet_df['co2'], cmap='RdYlGn_r', 
                     s=80, alpha=0.6, edgecolors='black', linewidth=0.5)

# Add the three example fleets
for r, color, marker in zip(results, [PLOT_COLORS[0], PLOT_COLORS[2], PLOT_COLORS[1]], ['o', 's', '^']):
    if r['co2'] <= 111:  # Only plot if feasible
        ax.scatter(r['cost'], r['service'], s=300, color=color, 
                  marker=marker, label=r['name'], 
                  edgecolors='white', linewidth=2.5, zorder=10)

ax.set_xlabel('Total Cost (€ millions)', fontsize=12, fontweight='bold')
ax.set_ylabel('Service Score', fontsize=12, fontweight='bold')
ax.set_title('Fleet Composition Trade-offs\n(All solutions meet EU emissions constraint)', 
             fontsize=13, fontweight='bold')
ax.legend(loc='best', fontsize=10)
ax.grid(True, alpha=0.3)

# Add colorbar
cbar = plt.colorbar(scatter, ax=ax)
cbar.set_label('Avg CO₂ (g/km)', fontsize=10)

plt.tight_layout()
plt.show()

print(f"\nGenerated {len(fleet_df)} feasible fleet compositions")
```

. . .

::: callout-important
Each point is a different fleet mix, all meeting emissions constraint!
:::

# [Solution Approaches]{.flow} {.title}

## Multi-Objective Optimization

[You can use optimization solvers or heuristics!]{.highlight}

. . .

::: columns
::: {.column width="50%"}
**With Optimization Solvers**

- Weighted Sum Method
- ε-Constraint Method  
- Goal Programming
- **Optimal solutions**
- **Need mathematical model**
:::

::: {.column width="50%"}
**With Heuristics**

- Weighted Greedy Construction
- Multi-Objective Local Search
- Metaheuristics
- **Good solutions, fast**
- **No optimality proof**
:::
:::

. . .

::: {.callout-important}
In this lecture we use heuristic approaches!
:::

## Foundation: Extreme Points

[First step for BOTH approaches - find the boundaries:]{.highlight}

```{python}
#| echo: false
#| eval: true

# Use the fleet problem data from earlier
fig, axes = plt.subplots(1, 2)

# Left plot: Show extreme points from fleet problem
ax1 = axes[0]

# Plot the Pareto frontier from fleet problem
ax1.scatter(fleet_df['cost'], fleet_df['service'], 
           s=60, alpha=0.4, color=BRAND_COLORS["darker"], label='All feasible fleets')

# Find extreme points (approximate)
min_cost_fleet = fleet_df.loc[fleet_df['cost'].idxmin()]
max_service_fleet = fleet_df.loc[fleet_df['service'].idxmax()]

ax1.scatter(min_cost_fleet['cost'], min_cost_fleet['service'],
           s=300, color=PLOT_COLORS[2], marker='*', 
           label=f'Min Cost: €{min_cost_fleet["cost"]:.1f}M',
           edgecolors='black', linewidth=2, zorder=10)
ax1.scatter(max_service_fleet['cost'], max_service_fleet['service'],
           s=300, color=PLOT_COLORS[0], marker='*', 
           label=f'Max Service: {max_service_fleet["service"]:.3f}',
           edgecolors='black', linewidth=2, zorder=10)

ax1.set_xlabel('Cost (€M)', fontsize=12, fontweight='bold')
ax1.set_ylabel('Service Score', fontsize=12, fontweight='bold')
ax1.set_title('Step 1: Find Extreme Points', fontsize=13, fontweight='bold')
ax1.legend(fontsize=9)
ax1.grid(True, alpha=0.3)

# Right plot: Show normalization (scaled to [0,1])
ax2 = axes[1]

# Calculate normalized values using actual fleet data
ideal_cost = fleet_df['cost'].min()
worst_cost = fleet_df['cost'].max()
ideal_service = fleet_df['service'].max()
worst_service = fleet_df['service'].min()

cost_range = worst_cost - ideal_cost
service_range = ideal_service - worst_service

# Show normalized ranges
objectives = ['Cost\n(normalized)', 'Service\n(normalized)']
normalized_mins = [0, 0]
normalized_maxs = [1, 1]

x = np.arange(len(objectives))
width = 0.35

bars1 = ax2.bar(x - width/2, normalized_mins, width, label='Best = 0', 
               color=PLOT_COLORS[1], alpha=0.7, edgecolor='black', linewidth=1.5)
bars2 = ax2.bar(x + width/2, normalized_maxs, width, label='Worst = 1', 
               color=PLOT_COLORS[0], alpha=0.7, edgecolor='black', linewidth=1.5)

# Add original range annotations
ax2.text(0, 0.5, f'€{ideal_cost:.1f}M → €{worst_cost:.1f}M\nRange: €{cost_range:.1f}M', 
        ha='center', va='center', fontsize=9, fontweight='bold',
        bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
ax2.text(1, 0.5, f'{worst_service:.2f} → {ideal_service:.2f}\nRange: {service_range:.2f}', 
        ha='center', va='center', fontsize=9, fontweight='bold',
        bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

ax2.set_ylabel('Normalized Value [0, 1]', fontsize=12, fontweight='bold')
ax2.set_title('Step 2: Normalize to [0,1] Scale', fontsize=13, fontweight='bold')
ax2.set_xticks(x)
ax2.set_xticklabels(objectives)
ax2.set_ylim(-0.1, 1.3)
ax2.legend(fontsize=10)
ax2.grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Why is normalization essential?

## Critical: Normalization

[Without it, your analysis is meaningless]{.highlight}

```{python}
#| echo: false
#| eval: true

# Demonstrate the normalization problem with trade-offs
fig, axes = plt.subplots(1, 3)

# Sample data showing real trade-offs
# Solution A: Cheap but slow and dirty
# Solution B: Balanced
# Solution C: Fast and clean but expensive
cost_vals = np.array([50000, 75000, 100000])  # In euros
emissions_vals = np.array([150, 100, 50])      # In g/km (INVERSED - cheaper = dirtier)
speed_vals = np.array([40, 55, 70])            # In km/h

objectives = ['Solution A', 'Solution B', 'Solution C']

# Plot 1: Raw values (wrong!)
ax1 = axes[0]
x = np.arange(len(objectives))
width = 0.25
ax1.bar(x - width, cost_vals, width, label='Cost (€)', color=PLOT_COLORS[0])
ax1.bar(x, emissions_vals, width, label='Emissions (g/km)', color=PLOT_COLORS[1])
ax1.bar(x + width, speed_vals, width, label='Speed (km/h)', color=PLOT_COLORS[2])
ax1.set_ylabel('Raw Values')
ax1.set_title('WRONG: Different Scales', fontweight='bold')
ax1.set_xticks(x)
ax1.set_xticklabels(objectives)
ax1.set_ylim(0, 140000)
ax1.legend()
ax1.annotate('Cost dominates everything!', xy=(1, 60000), fontsize=10, color='black')

# Plot 2: Min-Max Normalized [0,1]
ax2 = axes[1]
cost_norm = (cost_vals - cost_vals.min()) / (cost_vals.max() - cost_vals.min())
emissions_norm = (emissions_vals - emissions_vals.min()) / (emissions_vals.max() - emissions_vals.min())
speed_norm = (speed_vals - speed_vals.min()) / (speed_vals.max() - speed_vals.min())

ax2.bar(x - width, cost_norm, width, label='Cost', color=PLOT_COLORS[0])
ax2.bar(x, emissions_norm, width, label='Emissions', color=PLOT_COLORS[1])
ax2.bar(x + width, speed_norm, width, label='Speed', color=PLOT_COLORS[2])
ax2.set_ylabel('Normalized [0,1]')
ax2.set_title('Min-Max Normalization', fontweight='bold')
ax2.set_xticks(x)
ax2.set_xticklabels(objectives)
ax2.set_ylim(0, 1.4)
ax2.legend()

# Plot 3: Z-Score Standardized
ax3 = axes[2]
cost_std = (cost_vals - cost_vals.mean()) / cost_vals.std()
emissions_std = (emissions_vals - emissions_vals.mean()) / emissions_vals.std()
speed_std = (speed_vals - speed_vals.mean()) / speed_vals.std()

ax3.bar(x - width, cost_std, width, label='Cost', color=PLOT_COLORS[0])
ax3.bar(x, emissions_std, width, label='Emissions', color=PLOT_COLORS[1])
ax3.bar(x + width, speed_std, width, label='Speed', color=PLOT_COLORS[2])
ax3.set_ylabel('Standardized (μ=0, σ=1)')
ax3.set_title('Z-Score Standardization', fontweight='bold')
ax3.set_xticks(x)
ax3.set_xticklabels(objectives)
ax3.legend()
ax3.set_ylim(0, 1.6)
ax3.axhline(y=0, color='black', linestyle='-', linewidth=0.5)

plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Any intuition on how to do [0,1] normalization?

## How to Normalize

[The Normalization Formula for [0,1]]{.highlight}

$$\text{Normalized}_i = \frac{x_i - x_{min}}{x_{max} - x_{min}}$$

. . .

**In Python, this is rather simple!**

. . .

```python
def normalize_objectives(data):
    return (data - data.min()) / (data.max() - data.min())

# Now weights actually mean something
weighted_score = w1 * normalize(cost) + w2 * normalize(emissions)
```

. . .

::: callout-tip
Easy, right?
:::

## Extreme Points

[There are several reasons why extreme points matter:]{.highlight}

1. **Trade-off Space**: Min/max values bound your Pareto frontier
2. **Enable Proper Normalization**: Need ranges for scaling to [0,1]
3. **Feasibility**: If single objectives not achievable, problem infeasible
4. **Stakeholder**: "Best cost is €50k, best emissions is 40kg"

. . .

**Implementation Pattern:**
```python
def find_extreme_points(problem):
    # Solve for minimum cost (ignore emissions)
    min_cost_solution = minimize(cost_objective, constraints)
    # Solve for minimum emissions (ignore cost)
    min_emissions_solution = minimize(emissions_objective, constraints)
```

## Computational Complexity

[How hard does it get with more objectives?]{.highlight}

. . .

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots()

# Pareto front complexity growth
n_objectives = np.array([2, 3, 4, 5])
pareto_points = np.array([100, 1000, 10000, 100000])  # Exponential growth

ax.semilogy(n_objectives, pareto_points, 'o-', linewidth=3, 
            markersize=12, color=PLOT_COLORS[0])
ax.set_xlabel('Number of Objectives', fontsize=12)
ax.set_ylabel('Potential Pareto Points (log scale)', fontsize=12)
ax.set_title('Complexity Explosion', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.3)

# Add annotations
for i, (n, p) in enumerate(zip(n_objectives, pareto_points)):
    if n == 2:
        ax.annotate('Manageable\n(curve)', xy=(n, p), xytext=(n+0.15, p*3),
                   fontsize=10, ha='center', color=PLOT_COLORS[1])
    elif n == 3:
        ax.annotate('Challenging\n(surface)', xy=(n, p), xytext=(n+0.2, p*3),
                   fontsize=10, ha='center', color=PLOT_COLORS[2])
    elif n >= 4:
        ax.annotate('Very Hard!\n(hypersurface)', xy=(n, p), xytext=(n+0.3, p*0.3),
                   fontsize=10, ha='center', color='red')

plt.tight_layout()
plt.show()
```

. . .

::: callout-tip
Why? Because there are just way more potential solutions to check!
:::

## Solver-Based Methods

[Quick overview - you won't implement these in assignments]{.highlight}


::: incremental
1. **Weighted Sum:** Minimize $w_1 \times \text{cost} + w_2 \times \text{emissions}$
   - Simple, fast for convex problems
   
2. **ε-Constraint:** Minimize cost subject to emissions $\leq \varepsilon$
   - Systematically vary $\varepsilon$ to find complete frontier
   
3. **Goal Programming:** Minimize deviations from targets
   - Set target for each objective, minimize weighted deviations
:::

. . .

::: {.callout-note}
**For your fleet optimization:** You'll use **heuristic approaches** instead!
:::

# [Heuristic Approach]{.flow} {.title}

## The Heuristic Strategy

[For problems without mathematical models]{.highlight}

. . .

::: incremental
1. **Construction:** Build initial solutions with weighted greedy
2. **Improvement:** Multi-objective local search
3. **Selection:** Filter dominated solutions to find Pareto frontier
:::

. . .

::: {.callout-important}
**Key difference from solvers:**

- **Solvers:** Need mathematical model, guarantee optimality
- **Heuristics:** Work with any evaluation function, find good solutions fast
:::

## Why Heuristics?

[Depending on the problem:]{.highlight}

::: incremental
  - **Combinatorial explosion**
  - Huge solution space even for one problem
  - Evaluating one solution might thus take too long
  - Need diverse Pareto frontier, not just one "optimal" solution
  - Open Source Solvers too slow
  - Commercial solvers too expensive

:::

. . .

[Question:]{.question} How do we build good solutions without a solver?

## The Three-Stage Heuristic Process

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots()

# Visualization showing the three-stage process
stages_y = [0.8, 0.5, 0.2]
stage_names = [
    'Stage 1: Construction',
    'Stage 2: Improvement',
    'Stage 3: Selection'
]
stage_colors = [PLOT_COLORS[0], PLOT_COLORS[1], PLOT_COLORS[2]]

for i, (y, name, color) in enumerate(zip(stages_y, stage_names, stage_colors)):
    # Stage box
    rect = plt.Rectangle((0.1, y-0.08), 0.8, 0.12, 
                         facecolor=color, edgecolor='black', 
                         linewidth=2, alpha=0.6)
    ax.add_patch(rect)
    
    # Stage text
    ax.text(0.5, y, name, ha='center', va='center', 
           fontsize=13, fontweight='bold')
    
    # Arrow to next stage
    if i < len(stages_y) - 1:
        ax.arrow(0.5, y-0.08, 0, -0.06, head_width=0.05, 
                head_length=0.02, fc='black', ec='black', linewidth=2)

# Add outcome visualization on right side
# Generate example Pareto front
np.random.seed(42)
cost_range = np.linspace(60, 140, 20)
emissions_range = 180 - cost_range + np.random.normal(0, 8, 20)

# Normalize for plotting in figure coordinates
cost_norm = 0.1 + 0.35 * (cost_range - cost_range.min()) / (cost_range.max() - cost_range.min())
emissions_norm = 0.1 + 0.7 * (emissions_range - emissions_range.min()) / (emissions_range.max() - emissions_range.min())

# Transform to axis coordinates  
ax_cost = 0.55 + cost_norm
ax_emissions = emissions_norm

ax.plot(ax_cost, ax_emissions, 'o-', color='grey', 
       markersize=6, linewidth=2, label='Your Pareto Frontier')
ax.text(0.75, 0.85, 'Output:\nPareto Frontier', 
       ha='center', fontsize=11, fontweight='bold',
       bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.axis('off')
ax.set_title('Heuristic Multi-Objective Optimization Workflow', 
            fontsize=15, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()
```

. . .

[This is what you'll implement in your assignments!]{.highlight}

# [Construction & Improvement]{.flow} {.title}

## Construction Methods for MOO

[How to build initial solutions when you have multiple objectives?]{.highlight}

```{python}
#| echo: false
#| eval: true

fig, axes = plt.subplots(1, 3)

# Method 1: Weighted Greedy
ax1 = axes[0]
np.random.seed(42)
n_points = 15

# Simulate greedy solutions with different weight biases
cost_greedy = np.random.uniform(60, 140, n_points)
emissions_greedy = 250 - 1.5*cost_greedy + np.random.normal(0, 10, n_points)

ax1.scatter(cost_greedy[:5], emissions_greedy[:5], s=100, 
           color=PLOT_COLORS[0], alpha=0.7, label='Cost-focused greedy')
ax1.scatter(cost_greedy[5:10], emissions_greedy[5:10], s=100, 
           color=PLOT_COLORS[1], alpha=0.7, label='Emission-focused greedy')
ax1.scatter(cost_greedy[10:], emissions_greedy[10:], s=100, 
           color=PLOT_COLORS[2], alpha=0.7, label='Balanced greedy')

ax1.set_xlabel('Cost (€)', fontsize=10)
ax1.set_ylabel('Emissions (kg CO₂)', fontsize=10)
ax1.set_title('Method 1: Weighted Greedy', fontsize=11, fontweight='bold')
ax1.legend(fontsize=9)
ax1.grid(True, alpha=0.3)

# Method 2: Sequential Objectives
ax2 = axes[1]
# Show progression
stages = ['Stage 1:\nOptimize\nCost', 'Stage 2:\nFix Cost,\nOptimize\nEmissions', 'Stage 3:\nLocal\nadjustments']
y_pos = np.arange(len(stages))
colors_seq = [PLOT_COLORS[0], PLOT_COLORS[1], PLOT_COLORS[2]]

bars = ax2.barh(y_pos, [100, 70, 85], color=colors_seq, alpha=0.7)
ax2.set_yticks(y_pos)
ax2.set_yticklabels(stages)
ax2.set_xlabel('Solution Quality (%)', fontsize=10)
ax2.set_title('Method 2: Sequential Construction', fontsize=11, fontweight='bold')

# Method 3: Random + Filter
ax3 = axes[2]
# Generate random solutions
random_cost = np.random.uniform(50, 150, 50)
random_emissions = np.random.uniform(50, 250, 50)

# Mark dominated
dominated_mask = np.random.choice([True, False], 50, p=[0.7, 0.3])
ax3.scatter(random_cost[~dominated_mask], random_emissions[~dominated_mask], 
           s=80, alpha=0.7, color=PLOT_COLORS[1])

ax3.set_xlabel('Cost (€)', fontsize=10)
ax3.set_ylabel('Emissions (kg CO₂)', fontsize=10)
ax3.set_title('Method 3: Generate & Filter', fontsize=11, fontweight='bold')
ax3.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

. . .

::: callout-note
Three choices (for starters). Let's check them out!
:::

## Weighted Greedy Construction

[Making greedy choices on a weighted objective]{.highlight}

::: {.incremental}
1. **Choose weight vector** w = (w₁, w₂)
2. **At each step, pick the choice that minimizes:**
   $$w_1 \cdot \text{cost}(x) + w_2 \cdot \text{emissions}(x)$$
3. **Build complete solution greedily**
4. **Repeat** with different weights to explore frontier
:::

. . .

::: callout-tip
Different weights explore different trade-offs! Easy, right?
:::

## Sequential Greedy (Lexicographic)

[Optimize one objective at a time, in priority order]{.highlight}

::: {.incremental}
1. **Rank objectives by priority**
   - E.g. cost (most important) and then emissions (tie-breaker)
2. **At each step:**
   - Find choices that minimize **primary** objective
   - If tie → use **secondary** objective
3. **Build one working solution**
:::

. . .

::: callout-tip
We could also accept primary values within 10% of best so secondary has more influence!
:::

## Diverse Starting Pool

[Generate many random solutions, keep the non-dominated ones]{.highlight}

::: {.incremental}
1. **Generate N random solutions (e.g., N=100)**
2. **Evaluate all solutions on both objectives**
3. **Filter to keep only non-dominated solutions**
4. **Result:** A diverse set of Pareto-optimal solutions
:::

. . .

::: callout-tip
- Explores **entire** solution space
- No bias toward specific weights
- Great for **warm-starting** local search
:::

## Local Search for Multi-Objective

[Special moves that improve multiple objectives:]{.highlight}

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots()

# Current solution (normalized space)
current_cost = 0.5
current_emissions = 0.5
ax.scatter(current_cost, current_emissions, s=400, color=BRAND_COLORS['darker'], 
          marker='*', label='Current Solution', zorder=10, edgecolors='white', linewidth=2)

# Show different move types (normalized deltas)
moves = [
    {'name': 'Trade-off', 'dcost': 0.15, 'demissions': -0.12, 'color': PLOT_COLORS[0]},
    {'name': 'Win-Win', 'dcost': -0.08, 'demissions': -0.08, 'color': PLOT_COLORS[1]},
    {'name': 'Cost Focus', 'dcost': -0.12, 'demissions': 0.04, 'color': PLOT_COLORS[2]},
    {'name': 'Green Focus', 'dcost': 0.04, 'demissions': -0.15, 'color': PLOT_COLORS[3]},
    {'name': 'Bad Move', 'dcost': 0.12, 'demissions': 0.15, 'color': PLOT_COLORS[0], 'style': '--'}
]

for move in moves:
    new_cost = current_cost + move['dcost']
    new_emissions = current_emissions + move['demissions']
    style = move.get('style', '-')
    
    # Draw arrow
    ax.annotate('', xy=(new_cost, new_emissions), 
                xytext=(current_cost, current_emissions),
                arrowprops=dict(arrowstyle='->', color=move['color'], 
                              lw=2.5, linestyle=style, alpha=0.8))
    
    # Add endpoint
    ax.scatter(new_cost, new_emissions, s=200, color=move['color'], 
              alpha=0.7, edgecolors=BRAND_COLORS['darker'], linewidth=1.5)
    ax.text(new_cost, new_emissions - 0.06, move['name'], 
           fontsize=10, ha='center', fontweight='bold')

ax.set_xlabel('Normalized Cost')
ax.set_ylabel('Normalized Emissions')
ax.set_title('Multi-Objective Local Search: Not All Moves Are Equal!', fontweight='bold')
ax.legend(loc='upper right')
ax.grid(True, alpha=0.2)
ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
plt.tight_layout()
plt.show()
```

. . .

[Question:]{.question} Which moves are acceptable?

## MOO Local Search Rules

[Accept a move if:]{.highlight}

1. **Dominance**: New solution dominates current (win-win!)
2. **Trade-off**: Improves primary, acceptable loss in secondary
3. **Probabilistic**: Use temperature (like simulated annealing)

. . .

::: callout-important
Always keep all your objectives in mind when making decisions.
:::

# [From Pareto Front to Decision]{.flow} {.title}

## How to Choose!

::: incremental
1. [The Knee Point:]{.highlight} Find the "elbow" where improvement slows
1. [Satisficing Levels:]{.highlight} Set minimum acceptable thresholds
   - **Cost** must be < €100k (budget constraint)
   - **Emissions** must be < 100 kg (regulatory limit)
   - **Service level** must be > 90% (customer requirement)
3. [Stakeholder Preferences:]{.highlight} Let business priorities guide
   - **Sustainability:** Minimum emissions that meets constraints
   - **Operations:** Maximum service level within budget
:::

## Weighting has an Impact

[The weights thus reflect your values!]{.highlight}

```{python}
#| echo: false
#| eval: true

fig, ax = plt.subplots()

# Generate diverse fleet combinations with clear trade-offs
np.random.seed(456)
n_fleets = 25
fleet_cost = np.random.uniform(60, 140, n_fleets)
# Add non-linear relationship so different weights pick different points
fleet_emissions = 50 + 150 * (1 - (fleet_cost - 60) / 80)**1.5 + np.random.normal(0, 12, n_fleets)

# Normalize for scoring
norm_cost = (fleet_cost - fleet_cost.min()) / (fleet_cost.max() - fleet_cost.min())
norm_emissions = (fleet_emissions - fleet_emissions.min()) / (fleet_emissions.max() - fleet_emissions.min())

# Show three different weight scenarios
weight_scenarios = [
    (0.9, 0.1, 'Business Focus'),
    (0.5, 0.5, 'Balanced'),
    (0.1, 0.9, 'Environmental Focus')
]

scenario_colors = [PLOT_COLORS[0], PLOT_COLORS[2], PLOT_COLORS[1]]
for (w_cost, w_emissions, label), color in zip(weight_scenarios, scenario_colors):
    # Minimize weighted sum
    scores = w_cost * norm_cost + w_emissions * norm_emissions
    best = np.argmin(scores)
    ax.scatter(fleet_cost[best], fleet_emissions[best], 
              s=300, color=color, alpha=0.7, label=label,
              edgecolors=BRAND_COLORS['darker'], linewidth=2, zorder=5)

# Plot all options
ax.scatter(fleet_cost, fleet_emissions, alpha=0.3, s=60, 
          color=BRAND_COLORS['darker'], label='Available fleets')

ax.set_xlabel('Total Fleet Cost (k€)')
ax.set_ylabel('Annual Emissions (tons CO₂)')
ax.set_title('Different Priorities → Different Optimal Fleets', fontweight='bold')
ax.legend()
ax.grid(True, alpha=0.2)
plt.tight_layout()
plt.show()
```

. . .

::: callout-tip
Depending on your weight, the choice will vary.
:::

# [Advanced]{.flow} {.title}

## Speed vs Sustainability Dilemma

[The Three-Way Trade-off in E-Commerce]{.highlight}

1. **Minimize Delivery Time** (1-day/2-hour promise)
2. **Minimize Cost** (fuel, labor, fulfillment)
3. **Minimize Environmental Impact** (carbon footprint)

. . .

[Faster delivery = More vehicles less full = Higher emissions]{.highlight}

. . .

[Question:]{.question} What could retailers do?

## Moving the Frontier

[Instead of point on the frontier, move the entire frontier:]{.highlight}

. . .

[Question:]{.question} Any idea of examples?

. . .

::: callout-tip
R&D can fundamentally change what's possible!
:::

# [Briefing]{.flow} {.title}

## Today

:::: columns
::: {.column width="33%"}
**Hour 2: This Lecture**

- Multi-objective
- Pareto optimality
- Weighted greedy
- Local search MOO
:::

::: {.column width="33%"}
**Hour 3: Notebook**

- Bean Counter CEO
- Find Pareto frontier
- Apply weighted greedy
- Normalize objectives
:::

::: {.column width="33%"}
**Hour 4: Competition**

- Fleet composition
- Vehicle selection
- Cost vs service
- Justify choice!
:::
::::

## The Competition Challenge

[EcoExpress Sustainable Fleet Design]{.highlight}

. . .

1. **Select** optimal fleet mix (5 vehicle types)
2. **Balance** cost vs. service score
3. **Meet** EU emission constraint (≤ 111 g CO₂/km)
4. **Ensure** sufficient capacity (22,000 parcels/day)

. . .

:::{.callout-important}
Find the best trade-off for your business priorities!
:::

## Choosing Your MOO Approach

[Different situations call for different methods:]{.highlight}

| Situation | Best | Why |
|---------|----------|-----|
| Clear priorities | Sequential greedy | Fast, hierarchy |
| Exploring | Weighted greedy | Different solutions |
| Many solutions | Diverse pool | Builds frontier |
| Quick solution | Single weighted | One good compromise |
| Improve existing | Multi-objective local | Refines trade-offs |

. . .

:::{.callout-tip}
**Competition?** Generate diverse pool or weigted, then improve with local search.
:::

## Implementation Pitfalls to Avoid

[Common bugs that cost you time:]{.highlight}

::: incremental
1. **Forgetting to Normalize**
   - Always normalize to [0,1] first!
2. **Optimizing Too Many Objectives**
   - 2-3: Manageable, 4+: Exponentially harder
   - Combine related objectives or use constraints
3. **Not Checking Solution Feasibility**
   - Always verify constraints after optimization
:::

## Summary

[Key Takeaways:]{.highlight}

::: incremental
- Real decisions have multiple conflicting objectives
- Pareto frontier shows all rational trade-offs
- Normalization is essential for fair comparison
- Weights reflect values, make them explicit
- Visualization crucial for decision-making
:::

## Break!

[Take 20 minutes, then we start the practice notebook]{.highlight}

**Next up:** You'll become Bean Counter's expert

**Then:** The Sustainability competition
