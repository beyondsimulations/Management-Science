---
title: "Better Routing"
subtitle: "Lecture 7 - Management Science"
author: "Dr. Tobias Vlćek"
format:
  revealjs:
    footer: " {{< meta title >}} | {{< meta author >}} | [Home](lec_07_local_search.qmd)"
    output-file: lec_07_presentation.html
---

# [Introduction]{.flow} {.title}

## **[Client Briefing: Artisan Bakery]{.invert-font}** {background-image="https://unsplash.com/photos/RndRFJ1v1kk/download?ixid=M3wxMjA3fDB8MXxhbGx8fHx8fHx8fHwxNzYyODcwNzAzfA&force=true&w=2400" background-size="cover"}

. . .

[Master Baker's Morning Dilemma:]{.invert-font}

["Every morning at 5:00, our delivery van leaves with fresh bread for [16 cafés]{.highlight} across the city. Our driver currently takes much too long using his 'intuition' for the route. The fuel costs are killing us, and worse, some cafés get their bread late."]{.invert-font .fragment}

## The Delivery Challenge

[Artisan Bakery's daily logistics puzzle:]{.highlight}

::: incremental
- **16 Cafés:** Each expecting fresh bread by 8:00
- **One Van:** Unlimited capacity, must visit all locations
- **Time Windows:** 3 cafés open early (6:30) and need priority
- **Current Problem:** Driver uses "gut feeling" for routing
:::

. . .

:::{.callout-important}
**The Stakes:** Poor routing costs plus reputation damage from late deliveries!
:::

## Quick Recap: Greedy Decisions

[Last week we learned greedy algorithms for scheduling:]{.highlight}

::: incremental
- **SPT:** Process shortest jobs first
- **EDD:** Process by earliest due date
- **Fast & Simple:** Made quick decisions, no looking back
:::

. . .

[Question]{.question}: Can we use the same greedy approach for routing?

. . .

:::{.callout-note}
[Today:]{.highlight} We'll start greedy, then learn how to [improve]{.highlight} solutions with local search!
:::

# [The Routing Problem]{.flow} {.title}

## The Traveling Salesman Problem

[Visit all locations exactly once, minimize total distance.]{.highlight}

. . .

```{python}
#| eval: true
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
import sys
sys.path.append('../helpers')
from plot_utils import BRAND_COLORS, setup_clean_style

setup_clean_style()
np.random.seed(123)

n_cafes = 16
x_coords = np.random.uniform(0, 30, n_cafes)
y_coords = np.random.uniform(0, 10, n_cafes)

# Bakery at center
bakery_x, bakery_y = 15, 5

fig, ax = plt.subplots()
ax.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], zorder=3, label='Cafés')
ax.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], marker='s', zorder=3, label='Bakery')

ax.set_xlabel('Distance (km)', fontsize=9)
ax.set_ylabel('Distance (km)', fontsize=9)
ax.set_aspect('equal', adjustable='box')
ax.grid(True, alpha=0.2)
ax.legend()
plt.tight_layout()
plt.show()
```

## Compute Everything?

[How many unique tours exist? With depot, n!/2 unique tours.]{.highlight}

. . .

**If your computer checks 1 million routes per second:**

::: incremental
- 4 cafés: 4!/2 = 12 tours → 0.000012 seconds ✓
- 8 cafés: 8!/2 = 20,160 tours → 0.02 seconds ✓
- 12 cafés: 12!/2 = 239,500,800 tours → 4 minutes ~
- 16 cafés: 16!/2 = 10,461,394,944,000 tours → 4 months! ✗
- 20 cafés: 20!/2 → 38,573 years! ✗
:::

. . .

:::{.callout-important}
**The Reality:** Exact approach would take longer than the universe has existed!
:::

## The "Cost" of Complexity

[Why buying a faster computer won't help:]{.highlight}

::: incremental

- **P:** Tasks that can be solved in polynomial time
  - Like sorting a spreadsheet or calculating payroll
  - These are safe, predictable, and easy to automate

- **NP:** Easy to check, hard to solve
  - Analogy: easy to check if a specific password works
  - Very hard to guess a password by trying every combination!

:::

. . .

::: callout-important
TSP optimization where we find minimum cost tour → NP-Hard. This means no known algorithm can find the perfect solution quickly for large problems.
:::

# [Graph Theory Foundations]{.flow} {.title}

## What is a Graph?

[A graph $G = (V, E)$ consists of:]{.highlight}

::: incremental
- **Vertices (V):** The nodes or points (bakery + cafés)
- **Edges (E):** The connections between vertices (roads)
- **Weight Function:** $w$ assigns costs to edges (distances)
:::

. . .

**For our bakery problem:**

::: incremental
- $|V| = 17$ (1 bakery + 17 cafés)
- $|E| = \binom{17}{2} = 136$ possible connections
- Each edge $(i,j)$ has weight $w_{ij}$ = distance between $i$ and $j$
:::

## Complete vs. Sparse Graphs

[Different graph structures lead to different complexities:]{.highlight}

::: incremental
- **Complete Graph:** All vertices connected to each other
  - TSP: $(n-1)!/2$ unique tours
  - Real roads: Usually complete (drive between any two points)
- **Sparse Graph:** Limited connections between vertices
  - Fewer edges = fewer possible routes
  - Examples: Public transit networks, restricted road access
:::

. . .

:::{.callout-important}
Density dramatically affects both problem difficulty and solution approaches!
:::

## Hamiltonian Cycles and Tours

[Mathematical foundation of the TSP:]{.highlight}

::: incremental
- **Hamiltonian Path:** Visits each vertex exactly once
- **Hamiltonian Cycle:** Hamiltonian path that returns to start vertex
- **TSP Tour:** Minimum weight Hamiltonian cycle
:::

. . .

**Mathematical Definition:**
A tour $T = (v_1, v_2, ..., v_n, v_1)$ where:

- Each $v_i \in V$ appears exactly once (except start/end)
- Total weight: $w(T) = \sum_{i=1}^{n} w_{v_i, v_{i+1}}$ (where $v_{n+1} = v_1$)

. . .

[Goal: Find tour $T^*$ such that $w(T^*) = \min_{T \in \mathcal{H}} w(T)$]{.highlight}

## Distance Functions and Metrics

[The weight function can have different properties:]{.highlight}

1. **Identity:** $d(i,i) = 0$ \quad \forall $i \in V$
2. **Symmetry:** $d(i,j) = d(j,i)$ \quad \forall $i,j \in V$
3. **Triangle Inequality:** $d(i,k) \leq d(i,j) + d(j,k) \quad \forall i,j,k \in V$

. . .

**Common Distance Functions:**

- **Euclidean:** $d(i,j) = \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$
- **Manhattan:** $d(i,j) = |x_i - x_j| + |y_i - y_j|$
- **Real road distances:** Often violate triangle inequality!

# [Greedy Construction]{.flow} {.title}

## A Bad Start: Random Route

[What happens if we pick cafés randomly?]{.highlight}

. . .

```{python}
#| eval: true
#| echo: false
# Setup for construction methods
np.random.seed(123)
n_cafes = 8
x_coords = np.random.uniform(0, 12, n_cafes)
y_coords = np.random.uniform(0, 4.5, n_cafes)
bakery_x, bakery_y = 2, 3

def calculate_distance(x1, y1, x2, y2):
    return np.sqrt((x2 - x1)**2 + (y2 - y1)**2)

def calculate_route_distance(route, x_coords, y_coords, start_x, start_y):
    distance = calculate_distance(start_x, start_y, x_coords[route[0]], y_coords[route[0]])
    for i in range(len(route) - 1):
        distance += calculate_distance(x_coords[route[i]], y_coords[route[i]],
                                      x_coords[route[i+1]], y_coords[route[i+1]])
    distance += calculate_distance(x_coords[route[-1]], y_coords[route[-1]], start_x, start_y)
    return distance

def random_route(n):
    route = list(range(n))
    np.random.shuffle(route)
    return route

# Generate random route
random_r = random_route(n_cafes)
random_dist = calculate_route_distance(random_r, x_coords, y_coords, bakery_x, bakery_y)

# Visualize random route
fig, ax = plt.subplots()

# Draw route
route_x = [bakery_x] + [x_coords[i] for i in random_r] + [bakery_x]
route_y = [bakery_y] + [y_coords[i] for i in random_r] + [bakery_y]
ax.plot(route_x, route_y, 'o-', color=BRAND_COLORS["threeDark"], linewidth=2, markersize=0, alpha=0.6)

# Draw locations
ax.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], s=400, zorder=3)
ax.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=400, marker='s', zorder=3)

# Add labels
for i, (x, y) in enumerate(zip(x_coords, y_coords)):
    ax.annotate(f'C{i+1}', (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)
ax.annotate('B', (bakery_x, bakery_y), ha='center', va='center', color='white', fontweight='bold', fontsize=12)

ax.set_xlabel('Distance (km)', fontsize=11)
ax.set_ylabel('Distance (km)', fontsize=11)
ax.set_aspect('equal', adjustable='box')
ax.set_title(f'Random Route: {random_dist:.1f} km - Notice the Crossings!', fontsize=13, fontweight='bold', color='black')
ax.grid(True, alpha=0.2)
plt.tight_layout()
plt.show()
```

. . .

:::{.callout-warning}
Random selection creates routes with many crossings and inefficiencies.
:::

## Nearest Neighbor: The Problem

[Given these 8 cafés, which should we visit first?]{.highlight}

```{python}
#| eval: true
#| echo: false
# Show just the problem - no solution
fig, ax = plt.subplots()

# Draw locations only
ax.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], s=400, zorder=3, label='Cafés')
ax.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=400, marker='s', zorder=3, label='Bakery')

# Add labels
for i, (x, y) in enumerate(zip(x_coords, y_coords)):
    ax.annotate(f'C{i+1}', (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)
ax.annotate('B', (bakery_x, bakery_y), ha='center', va='center', color='white', fontweight='bold', fontsize=12)

# Add distance annotations to nearest cafes
for i in range(n_cafes):
    dist = calculate_distance(bakery_x, bakery_y, x_coords[i], y_coords[i])
    if dist < 10:  # Show only nearby distances
        mid_x = (bakery_x + x_coords[i]) / 2
        mid_y = (bakery_y + y_coords[i]) / 2
        ax.annotate(f'{dist:.1f}', (mid_x, mid_y), fontsize=9, alpha=0.7)

ax.set_xlabel('Distance (km)', fontsize=11)
ax.set_ylabel('Distance (km)', fontsize=11)
ax.set_aspect('equal', adjustable='box')
ax.grid(True, alpha=0.2)
plt.tight_layout()
plt.show()
```

. . .

[Question]{.question}: Using nearest neighbor, which café would you visit first?

## Nearest Neighbor: The Algorithm

[Build a route by always visiting the closest unvisited location.]{.highlight}

1. Start at the bakery
2. Find the nearest unvisited café
3. Go there
4. Repeat until all visited
5. Return to bakery

. . .

:::{.callout-tip}
**Intuition:** Like picking low-hanging fruit - grab what's easiest (nearest) first!
:::

## Nearest Neighbor: The Solution

[Let's see how nearest neighbor builds the route step by step:]{.highlight}

```{python}
#| eval: true
#| echo: false
def nearest_neighbor_route(x_coords, y_coords, start_x, start_y):
    n = len(x_coords)
    unvisited = list(range(n))
    route = []
    current_x, current_y = start_x, start_y

    while unvisited:
        nearest_idx = min(unvisited,
                         key=lambda i: calculate_distance(current_x, current_y,
                                                        x_coords[i], y_coords[i]))
        route.append(nearest_idx)
        unvisited.remove(nearest_idx)
        current_x, current_y = x_coords[nearest_idx], y_coords[nearest_idx]

    return route

# Build route step by step
nn_route = nearest_neighbor_route(x_coords, y_coords, bakery_x, bakery_y)
nn_dist = calculate_route_distance(nn_route, x_coords, y_coords, bakery_x, bakery_y)

# Create visualization showing the construction process
fig, axes = plt.subplots(2, 4)
axes = axes.flatten()

for step_num in range(1, 9):  # Show steps 1-8
    ax = axes[step_num - 1]  # Use index 0-7 for axes

    # Draw all cafés
    ax.scatter(x_coords, y_coords, c=BRAND_COLORS["twoLight"], s=100, zorder=2)
    ax.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=150, marker='s', zorder=3)

    # Draw route so far
    partial_route = nn_route[:step_num]
    route_x = [bakery_x] + [x_coords[i] for i in partial_route]
    route_y = [bakery_y] + [y_coords[i] for i in partial_route]

    if step_num == 8:  # Last step - complete the tour
        route_x.append(bakery_x)
        route_y.append(bakery_y)

    ax.plot(route_x, route_y, 'o-', color=BRAND_COLORS["twoDark"], linewidth=2, markersize=0, alpha=0.7)

    # Highlight visited cafés
    for idx in partial_route:
        ax.scatter(x_coords[idx], y_coords[idx], c=BRAND_COLORS["twoDark"], s=150, zorder=3)

    # Add labels
    for i, (x, y) in enumerate(zip(x_coords, y_coords)):
        color = 'white' if i in nn_route[:step_num] else 'black'
        ax.annotate(f'{i+1}', (x, y), ha='center', va='center', color=color, fontweight='bold', fontsize=9)
    ax.annotate('B', (bakery_x, bakery_y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)

    ax.set_xlim(-1, 13)
    ax.set_ylim(-1, 5)
    ax.set_aspect('equal', adjustable='box')
    ax.grid(True, alpha=0.2)
    ax.set_title(f'Step {step_num}', fontsize=10)
    ax.set_xticks([])
    ax.set_yticks([])

plt.suptitle(f'Nearest Neighbor Construction: Final Distance = {nn_dist:.1f} km', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()
```

. . .

:::{.callout-note}
Farthest insertion builds a more balanced tour by establishing the outer structure first!
:::

## Farthest Insertion: The Problem

[Same 8 cafés - but now we'll use a different strategy:]{.highlight}

```{python}
#| eval: true
#| echo: false
# Show the problem again for farthest insertion
fig, ax = plt.subplots()

# Draw locations only
ax.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], s=400, zorder=3, label='Cafés')
ax.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=400, marker='s', zorder=3, label='Bakery')

# Add labels
for i, (x, y) in enumerate(zip(x_coords, y_coords)):
    ax.annotate(f'C{i+1}', (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)
ax.annotate('B', (bakery_x, bakery_y), ha='center', va='center', color='white', fontweight='bold', fontsize=12)

ax.set_xlabel('Distance (km)', fontsize=11)
ax.set_ylabel('Distance (km)', fontsize=11)
ax.set_aspect('equal', adjustable='box')
ax.grid(True, alpha=0.2)
plt.tight_layout()
plt.show()
```

. . .

::: callout-tip
The farthest point is our start!
:::

## Farthest Insertion: The Algorithm

[Build a route by starting with distant points and filling in gaps:]{.highlight}

1. Start at the bakery
2. Find the farthest café from bakery - add it to tour
3. Create initial tour: Bakery → Farthest → Bakery
4. **Repeat:** Find the café farthest from current tour
5. Insert it at the position that minimizes tour increase
6. Continue until all cafés are in the tour

. . .

:::{.callout-tip}
**Intuition:** Build the "skeleton" of the route first with distant points, then fill in the gaps.
:::

## Farthest Insertion: Step-by-Step

```{python}
#| eval: true
#| echo: false

def furthest_insertion_route(x_coords, y_coords, start_x, start_y):
    n = len(x_coords)
    if n == 0:
        return []

    # Find furthest from start
    distances_from_start = [calculate_distance(x_coords[i], y_coords[i], start_x, start_y)
                           for i in range(n)]
    furthest = np.argmax(distances_from_start)

    # Initialize tour with furthest point
    tour = [furthest]
    unvisited = set(range(n)) - {furthest}

    while unvisited:
        # Find unvisited point furthest from tour
        max_min_dist = -1
        furthest_point = None

        for u in unvisited:
            # Find minimum distance from u to any point in tour
            min_dist_to_tour = float('inf')
            for t in tour:
                dist = calculate_distance(x_coords[u], y_coords[u], x_coords[t], y_coords[t])
                min_dist_to_tour = min(min_dist_to_tour, dist)

            # Also consider distance to start
            dist_to_start = calculate_distance(x_coords[u], y_coords[u], start_x, start_y)
            min_dist_to_tour = min(min_dist_to_tour, dist_to_start)

            if min_dist_to_tour > max_min_dist:
                max_min_dist = min_dist_to_tour
                furthest_point = u

        # Find best insertion position
        if len(tour) == 1:
            tour.append(furthest_point)
        else:
            best_pos = 0
            best_increase = float('inf')

            # Try inserting at each position
            for i in range(len(tour) + 1):
                test_tour = tour[:i] + [furthest_point] + tour[i:]
                new_dist = calculate_route_distance(test_tour, x_coords, y_coords, start_x, start_y)
                old_dist = calculate_route_distance(tour, x_coords, y_coords, start_x, start_y)
                increase = new_dist - old_dist

                if increase < best_increase:
                    best_increase = increase
                    best_pos = i

            tour.insert(best_pos, furthest_point)

        unvisited.remove(furthest_point)

    return tour

# Build route with steps tracking
fi_route = furthest_insertion_route(x_coords, y_coords, bakery_x, bakery_y)
fi_dist = calculate_route_distance(fi_route, x_coords, y_coords, bakery_x, bakery_y)

# Build route step by step for visualization
tour_steps = []
tour = []
unvisited = set(range(n_cafes))

# Step 1: Find furthest from start
distances_from_start = [calculate_distance(x_coords[i], y_coords[i], bakery_x, bakery_y)
                       for i in range(n_cafes)]
furthest = np.argmax(distances_from_start)
tour = [furthest]
unvisited.remove(furthest)
tour_steps.append(tour.copy())

# Build rest of tour
while unvisited:
    # Find unvisited point furthest from tour
    max_min_dist = -1
    furthest_point = None

    for u in unvisited:
        min_dist_to_tour = float('inf')
        for t in tour:
            dist = calculate_distance(x_coords[u], y_coords[u], x_coords[t], y_coords[t])
            min_dist_to_tour = min(min_dist_to_tour, dist)

        dist_to_start = calculate_distance(x_coords[u], y_coords[u], bakery_x, bakery_y)
        min_dist_to_tour = min(min_dist_to_tour, dist_to_start)

        if min_dist_to_tour > max_min_dist:
            max_min_dist = min_dist_to_tour
            furthest_point = u

    # Find best insertion position
    if len(tour) == 1:
        tour.append(furthest_point)
    else:
        best_pos = 0
        best_increase = float('inf')

        for i in range(len(tour) + 1):
            test_tour = tour[:i] + [furthest_point] + tour[i:]
            new_dist = calculate_route_distance(test_tour, x_coords, y_coords, bakery_x, bakery_y)
            old_dist = calculate_route_distance(tour, x_coords, y_coords, bakery_x, bakery_y)
            increase = new_dist - old_dist

            if increase < best_increase:
                best_increase = increase
                best_pos = i

        tour.insert(best_pos, furthest_point)

    unvisited.remove(furthest_point)
    tour_steps.append(tour.copy())

# Create visualization showing the construction process
fig, axes = plt.subplots(2, 4)
axes = axes.flatten()

for step_num in range(1, 9):  # Show steps 1-8
    ax = axes[step_num - 1]  # Use index 0-7 for axes

    # Draw all cafés
    ax.scatter(x_coords, y_coords, c=BRAND_COLORS["oneLight"], s=150, zorder=2)
    ax.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=150, marker='s', zorder=3)

    # Draw tour so far
    if step_num <= len(tour_steps):
        current_tour = tour_steps[step_num - 1]

        # Draw tour
        route_x = [bakery_x] + [x_coords[i] for i in current_tour] + [bakery_x]
        route_y = [bakery_y] + [y_coords[i] for i in current_tour] + [bakery_y]
        ax.plot(route_x, route_y, 'o-', color=BRAND_COLORS["oneDark"], linewidth=2, markersize=0, alpha=0.7)

        # Highlight visited cafés
        for idx in current_tour:
            ax.scatter(x_coords[idx], y_coords[idx], c=BRAND_COLORS["oneDark"], s=200, zorder=3)

    # Add labels
    for i, (x, y) in enumerate(zip(x_coords, y_coords)):
        color = 'white' if step_num <= len(tour_steps) and i in tour_steps[step_num - 1] else 'black'
        ax.annotate(f'{i+1}', (x, y), ha='center', va='center', color=color, fontweight='bold', fontsize=9)
    ax.annotate('B', (bakery_x, bakery_y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)

    ax.set_xlim(-1, 13)
    ax.set_ylim(-1, 5)
    ax.set_aspect('equal', adjustable='box')
    ax.grid(True, alpha=0.2)
    ax.set_title(f'Step {step_num}', fontsize=10)
    ax.set_xticks([])
    ax.set_yticks([])

plt.suptitle(f'Furthest Insertion Construction: Final Distance = {fi_dist:.1f} km', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()
```

. . .

:::{.callout-note}
Notice how farthest insertion builds a more balanced tour by establishing the outer structure first, then filling in the gaps!
:::

## Comparison

[Let's compare all three construction methods:]{.highlight}

::: incremental
- **Random:** Usually worst - no strategy at all!
- **Nearest Neighbor:** Fast and decent, but can create long returns
- **Farthest:** Often best initial solution, builds good "skeleton"
:::

. . .

::: callout-tip
The better your starting point, the better your final result after local search!
:::

. . .

::: callout-important
**This is also true for all other problems we are solving!** A good initial heuristic to create a solution will help us later.
:::

## The Problem with Greedy

[Often obvious inefficiencies in the resulting routes]{.highlight}

::: incremental
- **Crossing paths:** Route crosses over itself
- **Long return:** Far from bakery at the end
- **Myopic decisions:** Can't see the "big picture"
:::

. . .

:::{.callout-warning}
Can we improve our greedy solutions?
:::

# [Local Search Framework]{.flow} {.title}

## The Four Pillars of Local Search

[Any problem can be solved with local search by defining:]{.highlight}

::: incremental
1. **Search Space:** All possible solutions (here 10 trillion routes!)
2. **Initial Solution:** Starting point (our greedy route)
3. **Objective Function:** How we measure quality (total distance)
4. **Neighborhood:** How to create "nearby" solutions (2-opt swaps)
:::

. . .

:::{.callout-important}
The power of local search: The same "engine" works for routing, scheduling, or any combinatorial problem - just plug in different components!
:::

## Solution Space: An Intuitive View

[Think of the solution space as a landscape:]{.highlight}

::: incremental
- **Each point:** A different route through the cafés
- **Height:** The total distance of that route (lower is better)
- **Neighbors:** Routes that differ by small change
- **Local optimum:** Best route among nearby alternatives
- **Global optimum:** The absolute best route overall
:::

## Search Strategy

[How can we search this space?]{.highlight}

::: incremental
1. Start somewhere (greedy construction)
2. Look around at neighboring solutions
3. Move to better neighbors
4. Stop when no neighbor is better
:::

. . .

:::{.callout-tip}
Local search transforms "quick and dirty" solutions into "pretty good" ones!
:::

# [Local Search Improvements]{.flow} {.title}

## The 2-Opt Algorithm

[Systematically improve routes by removing crossing paths.]{.highlight}

. . .

**The Idea:** Take two edges and swap them (to uncross the route)

. . .

```{python}
#| eval: true
#| echo: false
# Show a simple 2-opt swap illustration
fig, (ax1, ax2) = plt.subplots(1, 2)

# Before swap - create a crossing
points_x = [2, 6, 8, 4]
points_y = [2, 6, 2, 6]

ax1.plot([points_x[0], points_x[1]], [points_y[0], points_y[1]], 'o-',
         color=BRAND_COLORS["threeDark"], linewidth=3, markersize=10, label='Edge A-B')
ax1.plot([points_x[2], points_x[3]], [points_y[2], points_y[3]], 'o-',
         color=BRAND_COLORS["oneDark"], linewidth=3, markersize=10, label='Edge C-D')

ax1.annotate('A', (points_x[0], points_y[0]), xytext=(-10, -10), textcoords='offset points', fontsize=12)
ax1.annotate('B', (points_x[1], points_y[1]), xytext=(10, 10), textcoords='offset points', fontsize=12)
ax1.annotate('C', (points_x[2], points_y[2]), xytext=(10, -10), textcoords='offset points', fontsize=12)
ax1.annotate('D', (points_x[3], points_y[3]), xytext=(-10, 10), textcoords='offset points', fontsize=12)

ax1.set_title('Before: Crossing Paths', fontweight='bold')
ax1.set_xlim(0, 10)
ax1.set_ylim(0, 8)
ax1.set_aspect('equal', adjustable='box')
ax1.grid(True, alpha=0.2)
ax1.legend()

# After swap
ax2.plot([points_x[0], points_x[2]], [points_y[0], points_y[2]], 'o-',
         color=BRAND_COLORS["twoDark"], linewidth=3, markersize=10, label='Edge A-C')
ax2.plot([points_x[1], points_x[3]], [points_y[1], points_y[3]], 'o-',
         color=BRAND_COLORS["twoLight"], linewidth=3, markersize=10, label='Edge B-D')

ax2.annotate('A', (points_x[0], points_y[0]), xytext=(-10, -10), textcoords='offset points', fontsize=12)
ax2.annotate('B', (points_x[1], points_y[1]), xytext=(10, 10), textcoords='offset points', fontsize=12)
ax2.annotate('C', (points_x[2], points_y[2]), xytext=(10, -10), textcoords='offset points', fontsize=12)
ax2.annotate('D', (points_x[3], points_y[3]), xytext=(-10, 10), textcoords='offset points', fontsize=12)

ax2.set_title('After: Uncrossed = Shorter!', fontweight='bold')
ax2.set_xlim(0, 10)
ax2.set_ylim(0, 8)
ax2.set_aspect('equal', adjustable='box')
ax2.grid(True, alpha=0.2)
ax2.legend()

plt.tight_layout()
plt.show()
```

## Example: Step-by-Step

[Let's see exactly how 2-opt fixes a crossing in a real route:]{.highlight}

```{python}
#| eval: true
#| echo: false
# Create a concrete visual example of 2-opt
fig, axes = plt.subplots(1, 3)

# Define a simple example with a clear crossing
example_coords = {
    'B': (2, 5),
    'C1': (4, 5),
    'C2': (8, 8),
    'C3': (6, 2),
    'C4': (8, 2),
    'C5': (10, 5)
}

# Original route with crossing: B → C1 → C3 → C5 → C2 → C4 → B
original_route = ['B', 'C1', 'C3', 'C5', 'C2', 'C4', 'B']

# Step 1: Show the problem
ax1 = axes[0]
for i in range(len(original_route) - 1):
    start = original_route[i]
    end = original_route[i + 1]
    x_vals = [example_coords[start][0], example_coords[end][0]]
    y_vals = [example_coords[start][1], example_coords[end][1]]
    
    # Highlight the edges to be removed
    if (start, end) in [('C1', 'C3'), ('C2', 'C4')]:
        ax1.plot(x_vals, y_vals, 'o-', color=BRAND_COLORS["threeDark"], linewidth=3, markersize=0, alpha=0.8, label='Edges to remove' if start == 'C1' else '')
    else:
        ax1.plot(x_vals, y_vals, 'o-', color=BRAND_COLORS["twoLight"], linewidth=2, markersize=0, alpha=0.6)

for name, (x, y) in example_coords.items():
    if name == 'B':
        ax1.scatter(x, y, c=BRAND_COLORS["threeDark"], s=500, marker='s', zorder=3)
        ax1.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=12)
    else:
        ax1.scatter(x, y, c=BRAND_COLORS["twoDark"], s=500, zorder=3)
        ax1.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)

ax1.set_title('1. Problem: Several Route Crosses', fontsize=13, fontweight='bold')
ax1.text(0.5, 0.02, 'B → C1 → C3 → C5 → C2 → C4 → B', transform=ax1.transAxes, 
         ha='center', fontsize=10, bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.3))
ax1.set_xlim(0, 12)
ax1.set_ylim(0, 10)
ax1.set_aspect('equal', adjustable='box')
ax1.grid(True, alpha=0.2)
ax1.legend(loc='upper right')

# Step 2: Show the swap operation
ax2 = axes[1]
# Draw non-affected parts faintly
for i in range(len(original_route) - 1):
    start = original_route[i]
    end = original_route[i + 1]
    x_vals = [example_coords[start][0], example_coords[end][0]]
    y_vals = [example_coords[start][1], example_coords[end][1]]
    
    if (start, end) not in [('C1', 'C3'), ('C2', 'C4')]:
        ax2.plot(x_vals, y_vals, 'o-', color=BRAND_COLORS["twoLight"], linewidth=2, markersize=0, alpha=0.3)

# Draw the edges to be removed in dashed red
ax2.plot([example_coords['C1'][0], example_coords['C3'][0]], 
         [example_coords['C1'][1], example_coords['C3'][1]], 
         '--', color=BRAND_COLORS["threeDark"], linewidth=3, alpha=0.5, label='Remove')
ax2.plot([example_coords['C2'][0], example_coords['C4'][0]], 
         [example_coords['C2'][1], example_coords['C4'][1]], 
         '--', color=BRAND_COLORS["threeDark"], linewidth=3, alpha=0.5)

# Draw the new edges to be added
ax2.plot([example_coords['C1'][0], example_coords['C2'][0]], 
         [example_coords['C1'][1], example_coords['C2'][1]], 
         '-', color=BRAND_COLORS["oneDark"], linewidth=3, alpha=0.8, label='Add')
ax2.plot([example_coords['C3'][0], example_coords['C4'][0]], 
         [example_coords['C3'][1], example_coords['C4'][1]], 
         '-', color=BRAND_COLORS["oneDark"], linewidth=3, alpha=0.8)

# Highlight the segment being reversed with shading
segment_x = [example_coords[c][0] for c in ['C3', 'C5', 'C2']]
segment_y = [example_coords[c][1] for c in ['C3', 'C5', 'C2']]
ax2.fill(segment_x + [segment_x[0]], segment_y + [segment_y[0]], 
        color=BRAND_COLORS["oneLight"], alpha=0.2)

for name, (x, y) in example_coords.items():
    if name == 'B':
        ax2.scatter(x, y, c=BRAND_COLORS["threeDark"], s=500, marker='s', zorder=3)
        ax2.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=12)
    else:
        ax2.scatter(x, y, c=BRAND_COLORS["twoDark"], s=500, zorder=3)
        ax2.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)

ax2.set_title('2. Operation: Remove 2 Edges, Add 2 New', fontsize=13, fontweight='bold')
ax2.text(0.5, 0.02, 'Remove C1→C3 & C2→C4, Add C1→C2 & C3→C4', transform=ax2.transAxes,
        ha='center', fontsize=10, bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.3))
ax2.set_xlim(0, 12)
ax2.set_ylim(0, 10)
ax2.set_aspect('equal', adjustable='box')
ax2.grid(True, alpha=0.2)
ax2.legend(loc='upper right')

# Step 3: Show the fixed route
ax3 = axes[2]
# New route: B → C1 → C2 → C5 → C3 → C4 → B
new_route = ['B', 'C1', 'C2', 'C5', 'C3', 'C4', 'B']

for i in range(len(new_route) - 1):
    start = new_route[i]
    end = new_route[i + 1]
    x_vals = [example_coords[start][0], example_coords[end][0]]
    y_vals = [example_coords[start][1], example_coords[end][1]]
    
    # Highlight the new edges
    if (start, end) in [('C1', 'C2'), ('C3', 'C4')]:
        ax3.plot(x_vals, y_vals, 'o-', color=BRAND_COLORS["oneDark"], linewidth=3, markersize=0, alpha=0.8, label='New edges' if start == 'C1' else '')
    else:
        ax3.plot(x_vals, y_vals, 'o-', color=BRAND_COLORS["twoDark"], linewidth=2, markersize=0, alpha=0.6)

for name, (x, y) in example_coords.items():
    if name == 'B':
        ax3.scatter(x, y, c=BRAND_COLORS["threeDark"], s=500, marker='s', zorder=3)
        ax3.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=12)
    else:
        ax3.scatter(x, y, c=BRAND_COLORS["twoDark"], s=500, zorder=3)
        ax3.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)

ax3.set_title('3. Solution: Only 1 Crossing!', fontsize=13, fontweight='bold')
ax3.text(0.5, 0.02, 'B → C1 → C2 → C5 → C3 → C4 → B ✓', transform=ax3.transAxes,
        ha='center', fontsize=10, bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.3))
ax3.set_xlim(0, 12)
ax3.set_ylim(0, 10)
ax3.set_aspect('equal', adjustable='box')
ax3.grid(True, alpha=0.2)
ax3.legend(loc='upper right')

plt.tight_layout()
plt.show()
```

. . .

:::{.callout-tip}
**The Key Insight:** When you reverse a segment between two crossing edges, you automatically eliminate the crossing and create a shorter route!
:::

## How 2-Opt Works

```python
improved = True
while improved:
    improved = False
    best_distance = calculate_route_distance(route, distances)
    for i in range(len(route) - 1):
        for j in range(i + 2, len(route)):
            new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]
            new_distance = calculate_route_distance(new_route, distances)
            if new_distance < best_distance:
                route = new_route
                best_distance = new_distance
                improved = True
                break
        if improved:
            break
```

. . .

:::{.callout-note}
The `[::-1]` reverses the segment, eliminating crossings!
:::

## 2-Opt Applied

[Let's see how this changes the route!]{.highlight}

. . .

```{python}
#| eval: true
#| echo: false
# Implement basic 2-opt for demonstration using the 8-café data from earlier

def two_opt_improvement(route, x_coords, y_coords, start_x, start_y):
    improved = True
    best_route = route.copy()

    while improved:
        improved = False
        for i in range(len(best_route) - 1):
            for j in range(i + 2, len(best_route)):
                # Create new route with swap
                new_route = best_route[:i+1] + best_route[i+1:j+1][::-1] + best_route[j+1:]

                # Calculate distances
                old_dist = calculate_route_distance(best_route, x_coords, y_coords, start_x, start_y)
                new_dist = calculate_route_distance(new_route, x_coords, y_coords, start_x, start_y)

                if new_dist < old_dist:
                    best_route = new_route
                    improved = True
                    break
            if improved:
                break

    return best_route

# Apply 2-opt to our nearest neighbor solution
improved_route = two_opt_improvement(nn_route, x_coords, y_coords, bakery_x, bakery_y)
improved_distance = calculate_route_distance(improved_route, x_coords, y_coords, bakery_x, bakery_y)

# Visualize improved route
fig, (ax1, ax2) = plt.subplots(1, 2)

# Original nearest neighbor route
route_x = [bakery_x] + [x_coords[i] for i in nn_route] + [bakery_x]
route_y = [bakery_y] + [y_coords[i] for i in nn_route] + [bakery_y]
ax1.plot(route_x, route_y, 'o-', color=BRAND_COLORS["twoLight"], linewidth=2, markersize=0, alpha=0.7)
ax1.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], s=200, zorder=3)
ax1.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=300, marker='s', zorder=3)

# Add labels
for i, (x, y) in enumerate(zip(x_coords, y_coords)):
    ax1.annotate(f'{i+1}', (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=9)
ax1.annotate('B', (bakery_x, bakery_y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)

ax1.set_title(f'Nearest Neighbor: {nn_dist:.1f} km', fontweight='bold')
ax1.grid(True, alpha=0.2)
ax1.set_xlim(-1, 13)
ax1.set_ylim(-1, 5)
ax1.set_aspect('equal', adjustable='box')

# Improved route after 2-opt
improved_x = [bakery_x] + [x_coords[i] for i in improved_route] + [bakery_x]
improved_y = [bakery_y] + [y_coords[i] for i in improved_route] + [bakery_y]
ax2.plot(improved_x, improved_y, 'o-', color=BRAND_COLORS["twoDark"], linewidth=2, markersize=0, alpha=0.7)
ax2.scatter(x_coords, y_coords, c=BRAND_COLORS["twoDark"], s=200, zorder=3)
ax2.scatter(bakery_x, bakery_y, c=BRAND_COLORS["threeDark"], s=300, marker='s', zorder=3)

# Add labels
for i, (x, y) in enumerate(zip(x_coords, y_coords)):
    ax2.annotate(f'{i+1}', (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=9)
ax2.annotate('B', (bakery_x, bakery_y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)

ax2.set_title(f'After 2-Opt: {improved_distance:.1f} km', fontweight='bold')
ax2.grid(True, alpha=0.2)
ax2.set_xlim(-1, 13)
ax2.set_ylim(-1, 5)
ax2.set_aspect('equal', adjustable='box')

# Calculate improvement
improvement = (nn_dist - improved_distance) / nn_dist * 100

plt.tight_layout()
plt.show()
```

. . .

:::{.callout-tip}
Notice how 2-opt removed the crossing paths from our nearest neighbor solution, creating a more efficient route!
:::

## Common 2-Opt Bugs

[Debug these scenarios you'll encounter:]{.highlight}

. . .

**Bug 1: Infinite Loop**
```python
# WRONG: Forgot to update route
if new_distance < current_distance:
    improved = True  # But route never changes!
```

. . .

**Bug 2: Missing Return to Start**
```python
# WRONG: Only measures cafe-to-cafe
total = sum(distances between stops)
```

. . .

**Bug 3: Invalid Segment Reversal**
```python
# WRONG: Off-by-one error
new_route = route[:i] + route[i:j][::-1] + route[j:]
```

. . .

**Fix:** `route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]`

## What About 1-Opt?

```{python}
#| eval: true
#| echo: false
fig, (ax1, ax2) = plt.subplots(1, 2)

# Simple tour visualization
tour_coords = [(2, 2), (6, 2), (6, 6), (2, 6)]
labels = ['A', 'B', 'C', 'D']

# Original tour
ax1.plot([tour_coords[i][0] for i in [0, 1, 2, 3, 0]], 
         [tour_coords[i][1] for i in [0, 1, 2, 3, 0]], 
         'o-', color=BRAND_COLORS["twoDark"], linewidth=3, markersize=15)

# Highlight one edge to remove
ax1.plot([tour_coords[1][0], tour_coords[2][0]], 
         [tour_coords[1][1], tour_coords[2][1]], 
         'o-', color=BRAND_COLORS["threeDark"], linewidth=4, markersize=15, label='Remove this edge')

for i, (coord, label) in enumerate(zip(tour_coords, labels)):
    ax1.annotate(label, coord, ha='center', va='center', color='white', fontweight='bold', fontsize=12)

ax1.set_title('Original Tour: A→B→C→D→A', fontweight='bold', fontsize=12)
ax1.set_xlim(0, 8)
ax1.set_ylim(0, 8)
ax1.set_aspect('equal', adjustable='box')
ax1.grid(True, alpha=0.2)
ax1.legend()

# After removing one edge - broken path
ax2.plot([tour_coords[0][0], tour_coords[1][0]], 
         [tour_coords[0][1], tour_coords[1][1]], 
         'o-', color=BRAND_COLORS["twoDark"], linewidth=3, markersize=15)
ax2.plot([tour_coords[2][0], tour_coords[3][0], tour_coords[0][0]], 
         [tour_coords[2][1], tour_coords[3][1], tour_coords[0][1]], 
         'o-', color=BRAND_COLORS["twoDark"], linewidth=3, markersize=15)

# Show the gap
ax2.plot([tour_coords[1][0], tour_coords[2][0]], 
         [tour_coords[1][1], tour_coords[2][1]], 
         '--', color=BRAND_COLORS["threeDark"], linewidth=2, alpha=0.3, label='Gap (must reconnect here!)')

for i, (coord, label) in enumerate(zip(tour_coords, labels)):
    ax2.annotate(label, coord, ha='center', va='center', color='white', fontweight='bold', fontsize=12)

ax2.set_title('After Removing 1 Edge: A→B ... C→D→A', fontweight='bold', fontsize=12)
ax2.set_xlim(0, 8)
ax2.set_ylim(0, 8)
ax2.set_aspect('equal', adjustable='box')
ax2.grid(True, alpha=0.2)
ax2.legend()

plt.tight_layout()
plt.show()
```

. . .

:::{.callout-note}
[Where 1-opt DOES work:]{.highlight} In problems like knapsack (swap 1 item), assignment (reassign 1 person), or facility location (relocate 1 facility).
:::

## Or-Opt: Moving Sequences

[Moves sequence of 1-3 consecutive cities to different position.]{.highlight}

```{python}
#| eval: true
#| echo: false
# Visual explanation of Or-opt
fig, axes = plt.subplots(1, 3)

# Define example route
oropt_coords = {
    'B': (2, 5),
    'C1': (4, 3),
    'C2': (6, 2),
    'C3': (8, 3),
    'C4': (10, 5),
    'C5': (8, 7),
    'C6': (6, 8),
    'C7': (4, 7)
}

original_route = ['B', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'B']

# Panel 1: Original route
ax1 = axes[0]
for i in range(len(original_route) - 1):
    start = original_route[i]
    end = original_route[i + 1]
    
    # Highlight the sequence we'll move
    if start in ['C2', 'C3'] or (start == 'C1' and end == 'C2'):
        ax1.plot([oropt_coords[start][0], oropt_coords[end][0]], 
                [oropt_coords[start][1], oropt_coords[end][1]], 
                'o-', color=BRAND_COLORS["threeDark"], linewidth=4, markersize=0, alpha=0.8,
                label='Sequence to move' if start == 'C1' else '')
    else:
        ax1.plot([oropt_coords[start][0], oropt_coords[end][0]], 
                [oropt_coords[start][1], oropt_coords[end][1]], 
                'o-', color=BRAND_COLORS["twoLight"], linewidth=2, markersize=0, alpha=0.6)

for name, (x, y) in oropt_coords.items():
    if name in ['C2', 'C3']:
        ax1.scatter(x, y, c=BRAND_COLORS["threeDark"], s=400, zorder=3)
        ax1.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)
    elif name == 'B':
        ax1.scatter(x, y, c=BRAND_COLORS["oneDark"], s=400, marker='s', zorder=3)
        ax1.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)
    else:
        ax1.scatter(x, y, c=BRAND_COLORS["twoDark"], s=400, zorder=3)
        ax1.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)

ax1.set_title('1. Original: Identify Sequence', fontweight='bold', fontsize=12)
ax1.text(0.5, 0.05, 'B→C1→[C2→C3]→C4→C5→C6→C7→B', transform=ax1.transAxes,
        ha='center', fontsize=9, bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.3))
ax1.set_xlim(0, 12)
ax1.set_ylim(0, 10)
ax1.set_aspect('equal', adjustable='box')
ax1.grid(True, alpha=0.2)
ax1.legend(loc='upper left')

# Panel 2: Show the move operation
ax2 = axes[1]
# Draw the partial route faintly
for i in range(len(original_route) - 1):
    start = original_route[i]
    end = original_route[i + 1]
    
    if start not in ['C2', 'C3'] and end not in ['C2', 'C3']:
        ax2.plot([oropt_coords[start][0], oropt_coords[end][0]], 
                [oropt_coords[start][1], oropt_coords[end][1]], 
                'o-', color=BRAND_COLORS["twoLight"], linewidth=2, markersize=0, alpha=0.3)

# Show the sequence being moved with an arrow
ax2.annotate('', xy=(7, 7.5), xytext=(7, 2.5),
            arrowprops=dict(arrowstyle='->', color=BRAND_COLORS["threeDark"], lw=4))
ax2.text(7.5, 5, 'Move\nhere!', fontsize=12, fontweight='bold', color=BRAND_COLORS["threeDark"])

for name, (x, y) in oropt_coords.items():
    if name in ['C2', 'C3']:
        ax2.scatter(x, y, c=BRAND_COLORS["threeDark"], s=400, zorder=3, alpha=0.5)
        ax2.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)
    elif name == 'B':
        ax2.scatter(x, y, c=BRAND_COLORS["oneDark"], s=400, marker='s', zorder=3)
        ax2.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)
    else:
        ax2.scatter(x, y, c=BRAND_COLORS["twoDark"], s=400, zorder=3)
        ax2.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)

ax2.set_title('2. Operation: Move [C2→C3]', fontweight='bold', fontsize=12)
ax2.text(0.5, 0.05, 'Extract [C2→C3], insert after C6', transform=ax2.transAxes,
        ha='center', fontsize=9, bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.3))
ax2.set_xlim(0, 12)
ax2.set_ylim(0, 10)
ax2.set_aspect('equal', adjustable='box')
ax2.grid(True, alpha=0.2)

# Panel 3: New route after Or-opt
ax3 = axes[2]
new_route = ['B', 'C1', 'C4', 'C5', 'C6', 'C2', 'C3', 'C7', 'B']

for i in range(len(new_route) - 1):
    start = new_route[i]
    end = new_route[i + 1]
    
    # Highlight new connections
    if (start, end) in [('C1', 'C4'), ('C6', 'C2'), ('C3', 'C7')]:
        ax3.plot([oropt_coords[start][0], oropt_coords[end][0]], 
                [oropt_coords[start][1], oropt_coords[end][1]], 
                'o-', color=BRAND_COLORS["oneDark"], linewidth=3, markersize=0, alpha=0.8,
                label='New edges' if start == 'C1' else '')
    else:
        ax3.plot([oropt_coords[start][0], oropt_coords[end][0]], 
                [oropt_coords[start][1], oropt_coords[end][1]], 
                'o-', color=BRAND_COLORS["twoDark"], linewidth=2, markersize=0, alpha=0.6)

for name, (x, y) in oropt_coords.items():
    if name in ['C2', 'C3']:
        ax3.scatter(x, y, c=BRAND_COLORS["threeDark"], s=400, zorder=3)
        ax3.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)
    elif name == 'B':
        ax3.scatter(x, y, c=BRAND_COLORS["oneDark"], s=400, marker='s', zorder=3)
        ax3.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=11)
    else:
        ax3.scatter(x, y, c=BRAND_COLORS["twoDark"], s=400, zorder=3)
        ax3.annotate(name, (x, y), ha='center', va='center', color='white', fontweight='bold', fontsize=10)

ax3.set_title('3. Result: Sequence Relocated', fontweight='bold', fontsize=12)
ax3.text(0.5, 0.05, 'B→C1→C4→C5→C6→[C2→C3]→C7→B ✓', transform=ax3.transAxes,
        ha='center', fontsize=9, bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.3))
ax3.set_xlim(0, 12)
ax3.set_ylim(0, 10)
ax3.set_aspect('equal', adjustable='box')
ax3.grid(True, alpha=0.2)
ax3.legend(loc='upper left')
plt.tight_layout()
plt.show()
```

. . .

:::{.callout-tip}
Moving a sequence can satisfy time constraints without breaking tour structure!
:::

## Beyond: k-Opt Neighborhoods

[The k-opt family of improvements:]{.highlight}

::: columns
::: {.column width="33%"}
**2-opt**

- Removes 2 edges
- 1 way to reconnect
- n² combinations
- Fast, good results
:::

::: {.column width="33%"}
**3-opt**

- Removes 3 edges
- 7 ways to reconnect
- n³ combinations
- Better but slower
:::

::: {.column width="33%"}
**Or-opt**

- Moves 1-3 nodes
- Good for time windows
- Specialized variant
:::
:::

. . .

:::{.callout-tip}
Start with 2-opt (fast), use 3-opt if you have time! As k increases, solutions improve but computation time grows exponentially.
:::


# [Local Optima]{.flow} {.title}

## Convergence and Local Optima

[When does local search stop? Why might it get stuck?]{.highlight}

. . .

**Convergence:**

- Algorithm stops when no neighboring solution is better

. . .

**The Local Optimum Problem:**

::: increment
- Algorithm can only "see" neighboring solutions
- Might miss better solutions that require multiple changes
- Like being stuck on a small hill when there's a mountain nearby
:::

. . .

:::{.callout-important}
Local search for improvement but does not guarantee global optimality.
:::

## The Local Optimum Trap

[Imagine you're a hiker dropped in foggy mountains at night...]{.highlight}

::: incremental
- **Your Mission:** Find the highest peak (global optimum)
- **Your Tool:** An altimeter (objective function)
- **Your Vision:** Only the ground at your feet (local neighborhood)
:::

. . .

- **The Greedy Strategy:** Always step uphill

. . .

[Question]{.question}: What happens when you reach the top of a small hill?

. . .

:::{.callout-warning}
You're stuck! Every step is downhill, but you might be on a tiny hill while a much larger moutain is nearby. This is the [local optimum trap]{.highlight}!
:::

## Visualizing Local Optima

```{python}
#| eval: true
#| echo: false
# Illustrate local vs global optimum concept
fig, ax = plt.subplots()

x = np.linspace(0, 10, 500)
# Create a simpler function with two clear minima (valleys)
# This represents the "fitness landscape" of different routes
y = 3 + 0.2*x - 1.5*np.exp(-(x-3)**2/0.8) - 2.5*np.exp(-(x-7.5)**2/0.5)

ax.plot(x, y, color=BRAND_COLORS["twoDark"], linewidth=2.5)

# Define our local and global minima explicitly (in valleys)
x_local = 2.9  # Local minimum (shallow valley)
y_local = 3 + 0.2*x_local - 1.5*np.exp(-(x_local-3)**2/0.8) - 2.5*np.exp(-(x_local-7.5)**2/0.5)

x_global = 7.5  # Global minimum (deeper valley)
y_global = 3 + 0.2*x_global - 1.5*np.exp(-(x_global-3)**2/0.8) - 2.5*np.exp(-(x_global-7.5)**2/0.5)

ax.scatter([x_local], [y_local],
           color=BRAND_COLORS["threeDark"], s=200, zorder=3, label='Local Minimum')
ax.scatter([x_global], [y_global],
           color=BRAND_COLORS["oneDark"], s=200, zorder=3, label='Global Minimum')

ax.annotate('Stuck here!', xy=(x_local, y_local), xytext=(x_local - 2.5, y_local + 0.5),
            arrowprops=dict(arrowstyle='->', color=BRAND_COLORS["threeDark"]),
            fontsize=11)
ax.annotate('Want here!', xy=(x_global, y_global), xytext=(x_global, y_global - 0.8),
            arrowprops=dict(arrowstyle='->', color=BRAND_COLORS["oneDark"]),
            fontsize=11)

ax.set_xlabel('Solution Space', fontsize=11)
ax.set_ylabel('Total Distance (km)', fontsize=11)
ax.set_title('The Local Optimum Trap', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.2)
ax.legend()
plt.tight_layout()
plt.show()
```

::: callout-tip
Here, the local minimum is already quite good, but we likely won't reach the global optimum from here.
:::

## The Reality

[Real problems often have thousands of local optima!]{.highlight}

```{python}
#| eval: true
#| echo: false
# Create a complex optimization landscape with many local optima
fig, ax = plt.subplots()

x = np.linspace(0, 20, 1000)
# Build a complex function with many peaks and valleys
# Start with a base trend
y = 5 + 0.1*x
# Add multiple sine/cosine waves of different frequencies
y += 1.5*np.sin(0.5*x)  # Long wavelength
y += 0.8*np.sin(2*x)     # Medium wavelength
y += 0.4*np.sin(5*x)     # Short wavelength
y += 0.3*np.cos(8*x)     # Even shorter
y += 0.2*np.sin(12*x)    # Very short wavelength
# Add some Gaussian valleys for local minima
y -= 0.8*np.exp(-(x-3)**2/0.3)   # Small local minimum
y -= 1.2*np.exp(-(x-7)**2/0.4)   # Medium local minimum
y -= 0.9*np.exp(-(x-11)**2/0.3)  # Another local minimum
y -= 5*np.exp(-(x-16)**2/0.5)    # Deep global minimum

ax.plot(x, y, color=BRAND_COLORS["twoDark"], linewidth=2, alpha=0.8)

# Find and mark several local minima
local_minima_x = [2.0, 7.27, 11.34, 13.55]
local_minima_labels = ['Local 1', 'Local 2', 'Local 3', 'Local 4']

for x_loc, label in zip(local_minima_x, local_minima_labels):
    y_loc = 5 + 0.1*x_loc
    y_loc += 1.5*np.sin(0.5*x_loc) + 0.8*np.sin(2*x_loc) + 0.4*np.sin(5*x_loc)
    y_loc += 0.3*np.cos(8*x_loc) + 0.2*np.sin(12*x_loc)
    y_loc -= 0.8*np.exp(-(x_loc-3)**2/0.3)
    y_loc -= 1.2*np.exp(-(x_loc-7)**2/0.4)
    y_loc -= 0.9*np.exp(-(x_loc-11)**2/0.3)
    y_loc -= 5*np.exp(-(x_loc-16)**2/0.5)

    ax.scatter([x_loc], [y_loc], color=BRAND_COLORS["threeDark"], s=200, zorder=3)

# Mark the global minimum
x_global = 16.05
y_global = 5 + 0.1*x_global
y_global += 1.5*np.sin(0.5*x_global) + 0.8*np.sin(2*x_global) + 0.4*np.sin(5*x_global)
y_global += 0.3*np.cos(8*x_global) + 0.2*np.sin(12*x_global)
y_global -= 0.8*np.exp(-(x_global-3)**2/0.3)
y_global -= 1.2*np.exp(-(x_global-7)**2/0.4)
y_global -= 0.9*np.exp(-(x_global-11)**2/0.3)
y_global -= 5*np.exp(-(x_global-16)**2/0.5)

ax.scatter([x_global], [y_global], color=BRAND_COLORS["oneDark"], s=200, zorder=4)
ax.annotate('GLOBAL\nMINIMUM', xy=(x_global, y_global), xytext=(x_global, y_global - 2),
            fontsize=11, ha='center', fontweight='bold',
            arrowprops=dict(arrowstyle='->', color=BRAND_COLORS["oneDark"], lw=2))

# Add shaded regions to show quality differences
ax.axhspan(ymin=ax.get_ylim()[0], ymax=y_global + 0.5, alpha=0.1, color='green', label='Excellent')
ax.axhspan(ymin=y_global + 0.5, ymax=4, alpha=0.1, color='yellow', label='Good')
ax.axhspan(ymin=4, ymax=6, alpha=0.1, color='orange', label='Mediocre')
ax.axhspan(ymin=6, ymax=ax.get_ylim()[1], alpha=0.1, color='red', label='Poor')

ax.set_xlabel('Solution Space (Different Route Configurations)', fontsize=12)
ax.set_ylabel('Total Distance (km)', fontsize=12)
ax.grid(True, alpha=0.3)

# Add text box with key insight
plt.tight_layout()
plt.show()
```

. . .

:::{.callout-warning}
The probability of finding the global optimum with simple local search is nearly zero!
:::

## Escaping Local Optima

[Depending on the problem: Multi-Start Strategy!]{.highlight}

::: incremental
- Most local minima are much worse than the global optimum
- The global minimum is sometimes isolated and hard to reach
- Starting point dramatically affects final solution quality
- Thus, start with different random solutions
- Use different initial heuristics
:::

. . .

:::{.callout-tip}
**No Free Lunch Theorem:** There's no universal "best" algorithm for all problems.
What works great for routing might fail for scheduling. Always match your tool to your problem!
:::

## How Good is Good Enough?

[Industry usage for delivery optimization]{.highlight}

| Method | Industry Use |
|--------|------------|--------------|
| Human intuition | Still common! |
| Start + 2-opt | Common practice |
| Advanced Meta | Sometimes practice |
| Exact (if possible) | Mostly research |

. . .

:::{.callout-important}
A 10% improvement = millions in savings for large logistics companies. Even a 2-opt implementation could literally save a lot of money if not used yet!
:::

# [Time Constraints]{.flow} {.title}

## Time Windows

[Remember our bakery? Some cafés open earlier than others!]{.highlight}

. . .

**Artisan Bakery's Morning Schedule:**

- **Bakery opens:** 5:00 (van departs)
- **Early Birds (3 cafés):** Must receive by 6:30
  - Café Europa, Sunrise Bistro, Morning Glory
- **Standard (13 cafés):** Must receive by 8:00

. . .

[Question]{.question}: Can we just find the shortest route?

. . .

:::{.callout-warning}
The shortest route might deliver to early cafés last. [Feasibility first, optimization second!]{.highlight}
:::

## Time Windows: Practical Approach

[Each location has a delivery time window:]{.highlight}

**Key Concepts:**

- **Earliest time:** When café opens
- **Latest time:** Delivery deadline
- **Service time:** Time to unload

. . .

**Arrival Time = Previous departure + Travel time**

. . .

- **Feasible route:** All deadlines met
- **Infeasible route:** At least one deadline missed (even if shortest!)

## Time Windows: NN Modification

[Modify greedy construction to prioritize early deadlines:]{.highlight}

```python
unvisited = set(range(len(locations))); route = []; current_time = start_time
while unvisited:
    # Find feasible neighbors (can reach before deadline)
    feasible = [i for i in unvisited
                if current_time + travel_time(current, i)
                    <= time_windows[i]['latest']]
    if not feasible:
        return None  # No feasible route exists!
    # Among feasible, choose most urgent
    next_stop = min(feasible, key=lambda i: (time_windows[i]['latest']))
    # Update state
    route.append(next_stop)
    unvisited.remove(next_stop)
    current_time += travel_time(current, next_stop) + service_time
```

## 2-Opt with Time Windows

[Problem: 2-opt can break time feasibility!]{.highlight}

```{python}
#| eval: true
#| echo: false
# Illustrate time window violation
fig, (ax1, ax2) = plt.subplots(1, 2)

# Original feasible route
stops = ['Bakery', 'Early1', 'Early2', 'Late1', 'Late2']
times_feasible = [5.0, 5.5, 6.2, 7.1, 7.8]
deadlines = [None, 6.75, 6.75, 8.0, 8.0]

ax1.plot(range(len(stops)), times_feasible, 'o-',
         color=BRAND_COLORS["twoDark"], linewidth=2.5, markersize=10)
for i, (stop, deadline) in enumerate(zip(stops, deadlines)):
    if deadline:
        ax1.axhline(y=deadline, xmin=i/5, xmax=(i+0.5)/5,
                   color=BRAND_COLORS["oneDark"], linestyle='--', alpha=0.5)
ax1.set_xticks(range(len(stops)))
ax1.set_xticklabels(stops, rotation=45, ha='right')
ax1.set_ylabel('Hours', fontsize=11)
ax1.set_title('Original Route: FEASIBLE ✓', fontsize=13, fontweight='bold')
ax1.grid(True, alpha=0.2)
ax1.set_ylim(4.5, 8.5)

# After 2-opt: violated
times_infeasible = [5.0, 5.5, 7.2, 6.8, 7.8]
ax2.plot(range(len(stops)), times_infeasible, 'o-',
         color=BRAND_COLORS["threeDark"], linewidth=2.5, markersize=10)
for i, (stop, deadline) in enumerate(zip(stops, deadlines)):
    if deadline:
        ax2.axhline(y=deadline, xmin=i/5, xmax=(i+0.5)/5,
                   color=BRAND_COLORS["oneDark"], linestyle='--', alpha=0.5)
ax2.scatter([2], [times_infeasible[2]], color='red', s=200, zorder=5, marker='x', linewidths=3)
ax2.set_xticks(range(len(stops)))
ax2.set_xticklabels(stops, rotation=45, ha='right')
ax2.set_ylabel('Hours', fontsize=11)
ax2.set_title('After 2-Opt: INFEASIBLE ✗', fontsize=13, fontweight='bold')
ax2.grid(True, alpha=0.2)
ax2.set_ylim(4.5, 8.5)

plt.tight_layout()
plt.show()
```

. . .

:::{.callout-warning}
**Early2 now arrives at 7:12 AM.** Missed its 6:45 deadline by 27 minutes!
:::

## The Solution

[Only accept swaps that maintain feasibility!]{.highlight}

```python
improved = True
while improved:
    improved = False
    for i in range(len(route) - 1):
        for j in range(i + 2, len(route)):
            new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]
            # Check feasibility FIRST
            if not is_feasible(new_route, time_windows, start_time):
                continue  # Skip infeasible swaps
            # Among feasible swaps, take if shorter
            if calculate_distance(new_route) < calculate_distance(route):
                route = new_route
                improved = True
                break
        if improved:
            break
```

. . .

:::{.callout-tip}
Feasibility is a hard constraint, distance is the objective.
:::

# [Briefing]{.flow} {.title}

## Choosing Your Algorithm

[Different situations call for different approaches:]{.highlight}

| Situation | Best Approach | Why |
|---------|----------|-----|
| Solution now | Nearest Neighbor | Lightning fast |
| Have seconds | NN + 2-opt | Good balance |
| Have minutes | Multi-start + 2-opt | Explore more options |
| Time windows | NN (early) + Or-opt | Preserves feasibility |
| Benchmark | 3-opt or meta | Best solutions |

. . .

:::{.callout-tip}
**Competition?** Choose whatever you are comfortable with.
:::

## Implementation Pitfalls to Avoid

[Common bugs that cost you time.]{.highlight}

. . .

**Forgetting return to bakery:**
```python
# WRONG
total = sum(distances between consecutive stops)
# RIGHT
total = sum(distances) + distance(last_stop, bakery)
```

. . .

**Index confusion in 2-opt:**
```python
# The 2-opt swap reverses route[i+1:j+1], not route[i:j]
```

. . .

**Modifying while iterating:**
```python
new_route = current_route.copy()  # Don't modify original
```

## Escaping Local Optima

[When local search gets stuck, we need clever escapes:]{.highlight}

. . .

**Advanced Techniques Coming:**

- **Simulated Annealing:** Sometimes accept worse moves
- **Genetic Algorithms:** Combine good routes to make better ones
- **Tabu Search:** Remember where you've been to avoid circles

. . .

:::{.callout-note}
Today's local search foundation makes advanced methods possible!
:::


## Summary

[Key Takeaways:]{.highlight}

::: incremental
- TSP is computationally hard (factorial growth)
- Local search is a universal framework (4 pillars)
- Greedy construction gives fast initial solutions
- 2-opt improves solutions iteratively
- Multi-start helps escape local optima
- Real constraints (time windows) add complexity
- Two-phase approach: Build then improve!
:::

## Break!

[Take 20 minutes, then we start the practice notebook]{.highlight}

**Next up:** You'll become Bean Counter's route planner

**Then:** The Bakery competition
